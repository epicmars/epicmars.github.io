[{"content":"参考：\n基本类型 相等性 空指针安全性 类型检查与转换 Java中有8种基本类型byte，short，int，long，float，double，boolean，char，还提供了支持字符串的java.lang.String类，最后提供了上述的数组类型。Kotlin中的数据类型与Java基本一致，不过可以将基本数据类型也看做对象。\n数字 类型 |位宽度\r--------|---------\rDouble\t|64\rFloat\t|32\rLong |64\rInt |32\rShort\t|16\rByte\t|8 \b注意，Kotlin中字符不是数字。\n在Java平台中，数字的以JVM中的基本数据类型保存于物理存储，除非我们想要一个可以为空(nullable)的数字或者使用了泛型，那么这时数字会装箱（boxed）为对应的类型。\n数字装箱后不保留同一性（identity），但保留相等性（equality），这与Java中是一样的，两个数字值相等的对象是不同的两个对象，但它们的值是相等的。\n与Java中不同的是，同一性比较使用三个等号符号：===或者!==，相等性比较使用：==或者!=。\n对于数字的\b\b隐式转换和自动\b拆装箱，对比\bJava中和Kotlin中有何区别：\nJava中，表达式中的数字类型会自动拆箱为对应的基础类型，然后向上转型为表达式中较大的基础类型。自动装箱只能发生在对应的基础类型上。 Integer a = 11; Short b = 12; Long c = 13L; int i = 1; short j = 2; long k = 3; k = a; k = a + b; k = i + j; k += i; a = a + b; a = i + j; c += i; c = 14; // error, right expression is \u0026#39;int\u0026#39; c = i + j; // error, right expression is \u0026#39;int\u0026#39; c = a + b; // error, right expression is \u0026#39;int\u0026#39; Kotlin中，与类型系统是相关的，因为所有数字类型都认为是对象，可以认为没有拆箱的说法，并且也没有隐式的类型提升，运算符事实上都是重载的操作符。 var a: Int? = 11 var b: Short? = 12 var c: Long? = 13L var i: Int = 1 var j: Short = 2 var k: Long = 3 k = a // error, no unboxing and explicitly conversion k = a + b // error, no unboxing and explicitly conversion k = i + j // error, assignment has no explicitly conversion k += i // ok a = a + b // error, no unboxing and explicitly conversion a = i + j // ok c += i // error, not allow c = 14 // ok c = i + j // error, assignment has no explicitly conversion c = a + b // error, no unboxing and explicitly conversion 正确通过编译的版本：\nvar a: Int? = 11 var b: Short? = 12 var c: Long? = 13L var i: Int = 1 var j: Short = 2 var k: Long = 3 k = a!!.toLong() k = (i + j).toLong() k = (a!! + b!!).toLong() k += i a = a!! + b!! a = i + j c += i // error, not allow c = 14 c = (i + j).toLong() c = (a!! + b!!).toLong() 字符 字符使用Char表示，它们不能被当做数字使用。\n布尔值 布尔值使用Boolean表示。\n字符串 字符串使用String表示。字符串是不可变的的，字符串的元素是\b字符，可以使用序号操作符[]来访问。\n有两种类型字符字面值，一种是脱字符字符串（escaped string），可以包含脱字符。\b另一种是原始字符串（raw string），没有脱字符，可以包含换行符和其它任意字符。\n字符串模板 字符串可以\b包含模板表达式，也就是一段代码运行的结果转换为字符串并插入到字符串中。一个模板表达式以\b一个美元符号（$）开始，并且由一个简单名字或\b花括弧中任意表达式构成：\nval i = 10 val s = \u0026#34;i = $i\u0026#34; // evaluates to \u0026#34;i = 10\u0026#34; val s = \u0026#34;abc\u0026#34; val str = \u0026#34;$s.length is ${s.length}\u0026#34; // evaluates to \u0026#34;abc.length is 3\u0026#34; val price = \u0026#34;\u0026#34;\u0026#34; ${\u0026#39;$\u0026#39;}9.99 \u0026#34;\u0026#34;\u0026#34; 在原始字符串中，如果要表示美元符号字面值，可以使用单引号，如上所示。\n数组 数字由Array类表示，有get和set方法（通过操作符重载，使用方括号[]来调用)，还有size属性，以及一些有用的方法。\nclass Array\u0026lt;T\u0026gt; private constructor() { val size: Int operator fun get(index: Int): T operator fun set(index: Int, value: T): Unit operator fun iterator(): Iterator\u0026lt;T\u0026gt; // ... } 可以使用库函数来创建数组，有arrayOf()，arrayOfNulls()，以及使用工厂函数，如下所示，它接收一个数组大小，和返回每个序号对应值的方法：\n// Creates an Array\u0026lt;String\u0026gt; with values [\u0026#34;0\u0026#34;, \u0026#34;1\u0026#34;, \u0026#34;4\u0026#34;, \u0026#34;9\u0026#34;, \u0026#34;16\u0026#34;] val asc = Array(5, { i -\u0026gt; (i * i).toString() }) 和Java中不一样，Kotlin中的数组是不变量，这意味着，不能将Array\u0026lt;String\u0026gt;赋值\b给一个Array\u0026lt;Any\u0026gt;，这样避免了一个可能的运行时错误，但可以使用Array\u0026lt;out Any\u0026gt;，见类型投影。\nKotlin还有指定的类用于表示基本数据类型数组，\b可以免去数据装箱的开销，有ByteArray, ShortArray, IntArray等等，这些类与Array类没有继承关系。它们有自己的\b工厂函数：\nval x: IntArray = intArrayOf(1, 2, 3) x[0] = x[1] + x[2] 相等性 Kotlin中有两种形式的相等性：\n引用相等性（即同一性，两个引用指向同一个对象），使用===和!==操作符。 结构相等性（equals()检查），使用==和!=操作符。 通常结构相等性操作符a == b会被翻译为：\na?.equals(b) ?: (b === null) 即如果a不为null，它盗用equals(Any?)函数，否则，a为null，它检查b是否引用相等于null。\n注意没有必要直接与null进行同一性比较，a == null会自动转换为a === null。\n\b空引用安全性（Null safety） Kotlin的类型系统的目的之一是消灭空引用，即传说中的百万美元bug。\n仅有几种情况会引起空指针异常（NullPointerException）：\n代码中直接抛出异常throw NullPointerException() 使用操作符!! 外部Java代码导致的异常 初始化相关的数据不一致问题（一个构造器中未初始化的this使用在了其它地方） 在条件语句中检查null 第一，你可以显式地检查b是否为空，并且分别处理两种情况：\nval l = if (b != null) b.length else -1 注意只有当b不可变（检查和使用间没有被修改的局部变量或者一个有支撑域的不可重写的val成员），因为其它情况下b在使用前检查后可能值被修改了。\n安全调用 使用安全调用操作符（?.）：\nb?.length // 如果b为null则返回null，否则返回b.length // 链式调用，如果有一个为null，就返回null bob?.department?.head?.name // 只在非空的情况下执行某一操作 val listWithNulls: List\u0026lt;String?\u0026gt; = listOf(\u0026#34;A\u0026#34;, null) for (item in listWithNulls) { item?.let { println(it) } // prints A and ignores null } Elvis操作符 当我们有一个可以为空的引用r，我们可以说“如果r不为null，那么就使用它，否则就使用某个非空的值x”：\nval l: Int = if (b != null) b.length else -1 使用Elvis操作符?:表示为:\nval l = b?.length ?: -1 由于throw和return也是表达式，它们也可以用于该操作符的右边，例如：\nfun foo(node: Node): String? { val parent = node.getParent() ?: return null val name = node.getName() ?: throw IllegalArgumentException(\u0026#34;name expected\u0026#34;) // ... } !!操作符 对于NPE爱好者还有一个选择，可以使用b!!，如果b不为空那么返回它，否则抛出一个NPE：\nval l = b!!.length 安全转型 常规的类型转换可能导致ClassCastException，另一种选择是使用在尝试转型失败后返回null的安全转换：\nval aInt: Int? = a as? Int 可以为空类型的集合 如果一个集合的元素可以为空，并且你想过滤出非空的元素，可以使用filterNotNull函数：\nval nullableList: List\u0026lt;Int?\u0026gt; = listOf(1, 2, null, 4) val intList: List\u0026lt;Int\u0026gt; = nullableList.filterNotNull() 类型检查与转换：\u0026ldquo;is\u0026quot;和\u0026quot;as\u0026rdquo; is和!is操作符 使用is和!is操作符可以在运行时检查一个对象是否符合一个给定的类型：\nif (obj is String) { print(obj.length) } if (obj !is String) { // same as !(obj is String) print(\u0026#34;Not a String\u0026#34;) } else { print(obj.length) } 智能转型 很多情形下，不用显式地进行类型转换，因为编译器会跟踪is检查，在需要的时候为不可变值进行显式地转型并自动插入（安全的）类型转换：\nfun demo(x: Any) { if (x is String) { print(x.length) // x is automatically cast to String } } 注意如果编译器不能保证检查和使用之间变量不能改变，那么智能转型就没法进行。更具体来说，智能转型在以下规则下是适用的：\nval局部变量——总是可行的。 val属性——如果属性是private的或者internal的或者检查在属性声明的同一模块下进行。对于open的属性或自定义了getter的属性不适用。 var局部变量——如果变量在检查和使用间没有被改变，并且没有在一个修改它的lambda中被捕获。 var属性——总是不可行的（因为变量可以在任何时间被其它代码修改）。 “不安全的（Unsafe）”转型操作符 通常，如果转型失败会抛出一个异常。因此，我们称之为_不安全的(unsafe)_。不安全的转型使用中缀操作符as来进行：\nval x: String = y as String 注意null不能被转型为String，因为String类型不是可为空的，也就是说，如果y是null，那么上面的代码会抛出一个异常。为了符合java的转型语义我们在转型操作符的右边有可以为空的类型，例如：\nval x: String? = y as String? \u0026ldquo;安全的（safe）\u0026ldquo;转型操作 为了避免抛出一个异常，可以使用_安全的（safe）_转型操作符as?，如果转型失败会返回null：\nval x: String? = y as? String 注意，尽管操作符as?的右边是一个不为null的类型String，转型的结果是可以为空的。\n","permalink":"https://epicmars.github.io/blog/kotlin/2017-11-01-kotlin-data-types/","summary":"参考：\n基本类型 相等性 空指针安全性 类型检查与转换 Java中有8种基本类型byte，short，int，long，float，double，boolean，char，还提供了支持字符串的java.lang.String类，最后提供了上述的数组类型。Kotlin中的数据类型与Java基本一致，不过可以将基本数据类型也看做对象。\n数字 类型 |位宽度\r--------|---------\rDouble\t|64\rFloat\t|32\rLong |64\rInt |32\rShort\t|16\rByte\t|8 \b注意，Kotlin中字符不是数字。\n在Java平台中，数字的以JVM中的基本数据类型保存于物理存储，除非我们想要一个可以为空(nullable)的数字或者使用了泛型，那么这时数字会装箱（boxed）为对应的类型。\n数字装箱后不保留同一性（identity），但保留相等性（equality），这与Java中是一样的，两个数字值相等的对象是不同的两个对象，但它们的值是相等的。\n与Java中不同的是，同一性比较使用三个等号符号：===或者!==，相等性比较使用：==或者!=。\n对于数字的\b\b隐式转换和自动\b拆装箱，对比\bJava中和Kotlin中有何区别：\nJava中，表达式中的数字类型会自动拆箱为对应的基础类型，然后向上转型为表达式中较大的基础类型。自动装箱只能发生在对应的基础类型上。 Integer a = 11; Short b = 12; Long c = 13L; int i = 1; short j = 2; long k = 3; k = a; k = a + b; k = i + j; k += i; a = a + b; a = i + j; c += i; c = 14; // error, right expression is \u0026#39;int\u0026#39; c = i + j; // error, right expression is \u0026#39;int\u0026#39; c = a + b; // error, right expression is \u0026#39;int\u0026#39; Kotlin中，与类型系统是相关的，因为所有数字类型都认为是对象，可以认为没有拆箱的说法，并且也没有隐式的类型提升，运算符事实上都是重载的操作符。 var a: Int?","title":"Kotlin数据类型"},{"content":"参考：\nLambdas 高阶函数 一个高阶函数接收函数作为其参数，或者返回一个函数。举个栗子，如下所示，lock()函数接收一个lock对象和一个函数，获取锁，运行函数，然后释放锁：\nfun \u0026lt;T\u0026gt; lock(lock: Lock, body: () -\u0026gt; T): T { lock.lock() try { return body() } finally { lock.unlock() } } body有一个函数类型：() -\u0026gt; T，它是一个返回类型为T的值的方法。\n如果我们想调用lock()，我们可以将另一个函数作为参数传递给它（参考：方法引用):\nfun toBeSynchronized() = sharedResource.operation() val result = lock(lock, ::toBeSynchronized) 此外，一个更加便捷的方式是传递一个lambda表达式:\nval result = lock(lock, { sharedResource.operation() }) Lambda表达式先简要介绍下，后面小节会有详细描述：\n一个lambda表达式总是由花括弧包围 它的参数在记号-\u0026gt;前声明，参数类型可以忽略 正文跟在-\u0026gt;后 在Kotlin中如果一个函数的最后一个参数是一个函数，并且使用lambda表达式传递对应的参数，有一个简便的方式来表示，即将lambda表达式放在函数参数列表括弧外：\nlock (lock) { sharedResource.operation() } 另一个例子，如下map()函数所示：\nfun \u0026lt;T, R\u0026gt; List\u0026lt;T\u0026gt;.map(transform: (T) -\u0026gt; R): List\u0026lt;R\u0026gt; { val result = arrayListOf\u0026lt;R\u0026gt;() for (item in this) result.add(transform(item)) return result } 该函数可以如下调用：\nval doubled = ints.map { value -\u0026gt; value * 2 } 语法糖\n如果lambda表达式是函数的唯一参数，那么参数括弧也可以省略。\n另一个惯用法是，如果函数仅有一个参数，该参数的声明（以及后面的-\u0026gt;）可以忽略，并使用it代表该参数：\nints.map { it * 2 } 它允许编写LINQ样式的代码：\nstrings.filter { it.length == 5 }.sortedBy { it }.map { it.toUpperCase() } 如果lambda参数未使用，你可以使用一个下划线声明：\nmap.forEach { _, value -\u0026gt; println(\u0026#34;$value!\u0026#34;) } Lambda表达式与匿名函数 一个\blambda表达式或匿名函数是一个“函数\u001b\b字面量（function literal）”，也就是未声明的函数，作为表达式直接传递。考虑如下例子：\nmax(strings, { a, b -\u0026gt; a.length \u0026lt; b.length }) 函数max是一个高阶函数，它接收一个函数值作为第二个参数，第二个参数是自身为函数的一个表达式，也就是函数字面量。作为一个函数，它等价于：\nfun compare(a: String, b: String): Boolean = a.length \u0026lt; b.length 函数类型 为了让一个函数接收另一个函数作为参数，必须为接收的参数指定一个函数类型，上面的例子中，max的定义如下：\nfun \u0026lt;T\u0026gt; max(collection: Collection\u0026lt;T\u0026gt;, less: (T, T) -\u0026gt; Boolean): T? { var max: T? = null for (it in collection) if (max == null || less(max, it)) max = it return max } 参数less的类型是(T, T) -\u0026gt; Boolean，即一个接收两个类型为T的参数并返回一个Boolean值的函数，它的行为是如果第一个参数小于第二个参数就返回true。\n函数类型中的参数可以命名：\nval compare: (x: T, y: T) -\u0026gt; Int = ... 如果声明了一个可以为空的函数类型变量，将函数类型用括弧包围并加一个问号：\nvar sum: ((Int, Int) -\u0026gt; Int)? = null Lambda表达式语法 Lambda表达式的完整语法形式如下：\nval sum = { x: Int, y: Int -\u0026gt; x + y } 一个Lambda表达式总是使用花括弧包围，参数声明在花括号中，可以有可选的类型标识，正文跟在右箭头符号-\u0026gt;后。如果推断出lambda返回类型不是Unit，那么最后一个表达式就是返回值。\n如果将可选的标识移到外面，可以表示如下：\nval sum: (Int, Int) -\u0026gt; Int = { x, y -\u0026gt; x + y } 我们可以使用限定的return语法从lambda中显式地返回一个值，否则会返回最后一个表达式的值，下面两种表示是等价的：\nints.filter { val shouldFilter = it \u0026gt; 0 shouldFilter } ints.filter { val shouldFilter = it \u0026gt; 0 return@filter shouldFilter } 匿名函数 上面的lambda表达式中不能指定函数的返回类型，大多数情况下，可以进行自动推断。然而，如果你想特别指定，可以使用匿名函数：\nfun(x: Int, y: Int): Int = x + y fun(x: Int, y: Int): Int { return x + y } 参数和返回类型的指定和常规函数一样，除了一点以外，即匿名函数参数类型如果可以从上下文中推断出，那么可以将其忽略：\nints.filter(fun(item) = item \u0026gt; 0) 匿名函数和lambda表达式的不同之处在于它不能作为括弧外参数传递，此外，两者的非局部返回(non-local returns)行为也不一样，一个无标签的return总是从fun声明的函数内返回，这表明lambda表达式中的return会从包围函数返回，而匿名函数会从自身返回。\n闭包（Closures） 一个lambda表达式或者匿名函数（以及局部函数和对象表达式）可以访问其闭包，也就是在外部范围声明的变量。\nvar sum = 0 ints.filter { it \u0026gt; 0 }.forEach { sum += it } print(sum) 带接收器的函数字面量 Kotlin允许用一个指定的接收对象调用一个函数字面量。在函数字面量的正文中，你可以直接调用接收对象的方法。这有点类似扩展函数，它允许你在函数体重访问接收对象的成员。\n这种类型的函数字面量是一个带接收器的函数类型：\nsum : Int.(other: Int) -\u0026gt; Int 函数字面量可以像接受对象的成员一样进行调用：\n1.sum(2) 你们函数语法允许你直接指定一个函数字面量的接收器类型。如果你需要声明一个带接收器的函数类型变量，这就十分有用：\nval sum = fun Int.(other: Int): Int = this + other 对于一个带接收器函数类型的非字面量值，在一个接收常规函数作为参数的地方并且该常规函数类型第一个参数与该值的接收器类型一样，那么该值可以作为参数传递，反之亦然。例如，类型String.(Int) -\u0026gt; Boolean和(String, Int) -\u0026gt; Boolean是兼容的：\nval represents: String.(Int) -\u0026gt; Boolean = { other -\u0026gt; toIntOrNull() == other } println(\u0026#34;123\u0026#34;.represents(123)) // true fun testOperation(op: (String, Int) -\u0026gt; Boolean, a: String, b: Int, c: Boolean) = assert(op(a, b) == c) testOperation(represents, \u0026#34;100\u0026#34;, 100, true) // OK 当接收器类型可以从上下文中推断出时，Lambda表达式可以用作带接收器的函数字面量：\nclass HTML { fun body() { ... } } fun html(init: HTML.() -\u0026gt; Unit): HTML { val html = HTML() // create the receiver object html.init() // pass the receiver object to the lambda return html } html { // lambda with receiver begins here body() // calling a method on the receiver object } ","permalink":"https://epicmars.github.io/blog/kotlin/2017-10-30-kotlin-lambdas/","summary":"参考：\nLambdas 高阶函数 一个高阶函数接收函数作为其参数，或者返回一个函数。举个栗子，如下所示，lock()函数接收一个lock对象和一个函数，获取锁，运行函数，然后释放锁：\nfun \u0026lt;T\u0026gt; lock(lock: Lock, body: () -\u0026gt; T): T { lock.lock() try { return body() } finally { lock.unlock() } } body有一个函数类型：() -\u0026gt; T，它是一个返回类型为T的值的方法。\n如果我们想调用lock()，我们可以将另一个函数作为参数传递给它（参考：方法引用):\nfun toBeSynchronized() = sharedResource.operation() val result = lock(lock, ::toBeSynchronized) 此外，一个更加便捷的方式是传递一个lambda表达式:\nval result = lock(lock, { sharedResource.operation() }) Lambda表达式先简要介绍下，后面小节会有详细描述：\n一个lambda表达式总是由花括弧包围 它的参数在记号-\u0026gt;前声明，参数类型可以忽略 正文跟在-\u0026gt;后 在Kotlin中如果一个函数的最后一个参数是一个函数，并且使用lambda表达式传递对应的参数，有一个简便的方式来表示，即将lambda表达式放在函数参数列表括弧外：\nlock (lock) { sharedResource.operation() } 另一个例子，如下map()函数所示：\nfun \u0026lt;T, R\u0026gt; List\u0026lt;T\u0026gt;.map(transform: (T) -\u0026gt; R): List\u0026lt;R\u0026gt; { val result = arrayListOf\u0026lt;R\u0026gt;() for (item in this) result.","title":"Kotlin高阶函数与Lambdas"},{"content":"参考:\n对象声明 对象表达式和声明（Object Expressions and Declarations） 对象表达式（Object expressions） Object表达式可以创建匿名类：\nwindow.addMouseListener(object : MouseAdapter() { override fun mouseClicked(e: MouseEvent) { // ... } override fun mouseEntered(e: MouseEvent) { // ... } }) 与Java匿名类不同的是，Java仅仅只能使用已有类型进行实例化，Kotlin可以在实例化匿名类时对匿名类进行定义，也就是说匿名类不用使用已有类型，如下所示：\n继承已有的类型：\nopen class A(x: Int) { public open val y: Int = x } interface B {...} val ab: A = object : A(1), B { override val y = 15 } 或者不继承已有的类，默认继承Any：\nfun foo() { val adHoc = object { var x: Int = 0 var y: Int = 0 } print(adHoc.x + adHoc.y) } 匿名类对象的类型信息只存在于本地和private声明中，如果匿名类对象可以通过public方法或属性公开访问，那么外部看到的类型是其超类或者Any。\nclass C { // Private function, so the return type is the anonymous object type private fun foo() = object { val x: String = \u0026#34;x\u0026#34; } // Public function, so the return type is Any fun publicFoo() = object { val x: String = \u0026#34;x\u0026#34; } fun bar() { val x1 = foo().x // Works val x2 = publicFoo().x // ERROR: Unresolved reference \u0026#39;x\u0026#39; } } 与Java中匿名内部类不能直接访问包围类的变量不一样，Kotlin中的object表达式可以直接访问这些变量，而且不限定变量是否是final的：\nfun countClicks(window: JComponent) { var clickCount = 0 var enterCount = 0 window.addMouseListener(object : MouseAdapter() { override fun mouseClicked(e: MouseEvent) { clickCount++ } override fun mouseEntered(e: MouseEvent) { enterCount++ } }) // ... } 对象声明（Object declarations） Kotlin中可以使用Object声明来定义单例，称之为对象声明(object declaration)：\nobject DefaultListener : MouseAdapter() { override fun mouseClicked(e: MouseEvent) { // ... } override fun mouseEntered(e: MouseEvent) { // ... } } 直接使用单例名引用该对象：\nDefaultListener.mouseClicked(...) 注意：对象声明不能是局部的（也就是直接嵌套在函数中），但可以嵌套在其它对象声明或非内部类中。\n友对象（Companion Objects） 在一个类中声明的对象可以使用companion关键词定义：\nclass MyClass { companion object Factory { fun create(): MyClass = MyClass() } } 友对象成员直接使用类名作为限定符进行使用：\nval instance = MyClass.create() 友对象名称可以忽略：\nclass MyClass { companion object { } } val x = MyClass.Companion 注意，尽管友对象的成员看上去像其它语言（例如Java）中的静态成员，但在运行时，它们是真实对象的实例成员。在与Java进行互操作中，可以使用@JvmStatic注解使其成为真正的静态方法。\n对象表达式和声明的语义区别 对象表达式和声明有一个重要的语义区别：\n对象表达式是**立即（immediately）**执行（并且初始的） 对象声明是**懒（lazily）**初始化，初始化在第一次访问时进行 一个友对象在对应的类加载时进行初始化，与Java静态初始化器的语义一致 ","permalink":"https://epicmars.github.io/blog/kotlin/2017-10-30-kotlin-object/","summary":"参考:\n对象声明 对象表达式和声明（Object Expressions and Declarations） 对象表达式（Object expressions） Object表达式可以创建匿名类：\nwindow.addMouseListener(object : MouseAdapter() { override fun mouseClicked(e: MouseEvent) { // ... } override fun mouseEntered(e: MouseEvent) { // ... } }) 与Java匿名类不同的是，Java仅仅只能使用已有类型进行实例化，Kotlin可以在实例化匿名类时对匿名类进行定义，也就是说匿名类不用使用已有类型，如下所示：\n继承已有的类型：\nopen class A(x: Int) { public open val y: Int = x } interface B {...} val ab: A = object : A(1), B { override val y = 15 } 或者不继承已有的类，默认继承Any：\nfun foo() { val adHoc = object { var x: Int = 0 var y: Int = 0 } print(adHoc.","title":"Kotlin对象"},{"content":"数据类（Data Classes） 我们常常创建仅仅持有数据的类，类似Java中的POJO或JavaBean，其对象我们一般称为实体（entity），因此它对应我们常说的Entity类。在一般UI应用分层架构中，例如MVC，MVP，MVVM等，都含有一个模型（Model）层，实体类型就属于这一块，它是构建业务的基石。\n为此Kotlin专门定义了data类型：\ndata class User(val name: String, val age: Int) 编译器会根据主构造函数中声明的属性自动生成如下成员：\nequals()/hashCode()对 toString()方法，返回字符串形式为\u0026quot;User(name=John, age=42)\u0026quot; componentN() 方法，其中N对应于属性声明的顺序 copy()函数 为了保持生成代码的一致性和行为的有效性，data类必须满足以下要求：\n主构造器需要至少一个参数 所有主构造器参数需要声明为val或var Data类型不能是abstruct、open、sealed或inner的 此外，对于成员继承，成员生成遵循以下规则：\n如果一个data类正文中明确实现了equals(),hashCode(),toString()方法，或者超类中有final修饰的实现，那么这些方法便不会生成，直接使用已有的实现。 如果超类有open修饰的componentN()方法并且返回兼容的类型，那么对应的生成方法会重写超类的方法，否则会报错。 显式地实现componentN()和copy()是不允许的 在JVM中，如果生成类需要有一个无参构造器，所有属性的默认值必须明确指定。\ndata class User(val name: String = \u0026#34;\u0026#34;, val age: Int = 0) 拷贝 copy()方法有什么用？有时我们需要拷贝一个对象，同时改变它的某些属性，并保持其它属性不变，使用copy()方法就可以了，其实现类似这样：\nfun copy(name: String = this.name, age: Int = this.age) = User(name, age) 对象的属性值作为copy的默认参数值，我们可以传递希望改变的值，而保留其它值不变：\nval jack = User(name = \u0026#34;Jack\u0026#34;, age = 2) val newJack = jack.copy(name = \u0026#34;New Java\u0026#34;) 结构声明（Destructuring Declarations） 生成的component方法可以使它们使用解构声明中：\nval jane = User(\u0026#34;Jane\u0026#34;, 35) val (name, age) = jane println(\u0026#34;$name, $age years of age\u0026#34;) // prints \u0026#34;Jane, 35 years of age\u0026#34; 标准库Data类 标准库提供了两个Data类：Pair和Triple。\n枚举类型（Enum Classes） 枚举类型最常见的基本使用是实现类型安全的枚举：\nenum class Direction { NORTH, SOUTH, WEST, EAST } 每个枚举常量都是一个对象，枚举常量使用逗号分开。\n初始化 由于每个枚举常量都是一个实例，可以这样初始化：\nenum class Color(val rgb: Int) { RED(0xFF0000), GREEN(0x00FF00), BLUE(0x0000FF) } 密封类（Sealed Classes） ","permalink":"https://epicmars.github.io/blog/kotlin/2017-10-30-kotlin-class-definition/","summary":"数据类（Data Classes） 我们常常创建仅仅持有数据的类，类似Java中的POJO或JavaBean，其对象我们一般称为实体（entity），因此它对应我们常说的Entity类。在一般UI应用分层架构中，例如MVC，MVP，MVVM等，都含有一个模型（Model）层，实体类型就属于这一块，它是构建业务的基石。\n为此Kotlin专门定义了data类型：\ndata class User(val name: String, val age: Int) 编译器会根据主构造函数中声明的属性自动生成如下成员：\nequals()/hashCode()对 toString()方法，返回字符串形式为\u0026quot;User(name=John, age=42)\u0026quot; componentN() 方法，其中N对应于属性声明的顺序 copy()函数 为了保持生成代码的一致性和行为的有效性，data类必须满足以下要求：\n主构造器需要至少一个参数 所有主构造器参数需要声明为val或var Data类型不能是abstruct、open、sealed或inner的 此外，对于成员继承，成员生成遵循以下规则：\n如果一个data类正文中明确实现了equals(),hashCode(),toString()方法，或者超类中有final修饰的实现，那么这些方法便不会生成，直接使用已有的实现。 如果超类有open修饰的componentN()方法并且返回兼容的类型，那么对应的生成方法会重写超类的方法，否则会报错。 显式地实现componentN()和copy()是不允许的 在JVM中，如果生成类需要有一个无参构造器，所有属性的默认值必须明确指定。\ndata class User(val name: String = \u0026#34;\u0026#34;, val age: Int = 0) 拷贝 copy()方法有什么用？有时我们需要拷贝一个对象，同时改变它的某些属性，并保持其它属性不变，使用copy()方法就可以了，其实现类似这样：\nfun copy(name: String = this.name, age: Int = this.age) = User(name, age) 对象的属性值作为copy的默认参数值，我们可以传递希望改变的值，而保留其它值不变：\nval jack = User(name = \u0026#34;Jack\u0026#34;, age = 2) val newJack = jack.copy(name = \u0026#34;New Java\u0026#34;) 结构声明（Destructuring Declarations） 生成的component方法可以使它们使用解构声明中：","title":"Kotlin类的定义"},{"content":"参考：\n对象表达式与声明 类属性 类属性是定义在类中的变量或不变量，分别使用var和val定义。这里把Kotlin中的不变量和常量作下区分，不变量只是在第一次初始化后便不可改变，其余特性和变量完全一样，但它不是常量，常量的说明在后面的小节给出。\nKotlin对类属性的完整声明是：\n(var|val) \u0026lt;propertyName\u0026gt;[: \u0026lt;PropertyType\u0026gt;] [= \u0026lt;property_initializer\u0026gt;]\r[\u0026lt;getter\u0026gt;]\r[\u0026lt;setter\u0026gt;]\r方括号[]表示该部分是可选的，其中属性初始化器、getter、setter在任何情况下都是可选的，如果属性类型可以从属性初始化器或getter中推断出，那么它也是可选的。使用val所声明的不变量是没有setter的。\n类属性可以不显式地初始化，但未显式初始化的属性必须在构造器中初始化：\nvar allByDefault: Int? // error: explicit initializer required, default getter and setter implied var initialized = 1 // has type Int, default getter and setter val simple: Int? // has type Int, default getter, must be initialized in constructor val inferredType = 1 // has type Int and a default getter 属性访问器 所谓访问，就是对属性的读与写，类会为每个属性提供默认的访问器。称读访问器为getter，写访问器为setter。对于属性变量两者都会提供，不变量只有getter，显然是由于它不可改变。访问器可以在声明属性时进行重写以替换默认访问器：\nval isEmpty: Boolean private get() = this.size == 0 var stringRepresentation: String get() = this.toString() @Inject set(value) { setDataFromString(value) // parses the string and assigns values to other properties } Kotlin中访问器虽然有像get和set方法一样的形式，但它们并不是方法，不能显式地调用。如果存在默认的或重写了的访问器，所有对属性的读和写会都会直接调用访问器，包括在访问器的声明中进行的读写。例如，重写类A的两个变量的getter和setter，IDE会提示递归调用导致栈溢出。读x和调用调用x的getter是等价的，对y的写和调用y的setter是等价的。\nclass A { var x = 0 get() { return x //recursive getter call } var y = 0 set(value) { if (value \u0026gt; 0) { y = value //recursive setter call } } } 支撑域（Backing Fields）与支撑属性（Backing Properties） 上面这个例子说明访问器有问题，用Java写POJO类时通常用IDE生成set和get方法就完事了，但有时候也会在这些方法中添加一些额外的逻辑对变量作进一步的操作。但上面的示例告诉我们，在Kotlin中这似乎做不到，因为我们拿不到真正的实例变量，只能通过访问器对变量进行操作，然而直接访问变量的需求还是在的，Kotlin也并不想让人抓狂，给出了两个解决方法，那便是支撑域和支撑属性。\nKotlin明确地告诉我们它是没有域（fields）的，Java中我们一直称对象的变量为域(field)，而Kotlin一直称之为属性（property），那么这两者有什么区别呢？\n在面向Google与面向爆栈编程实践中，我搜到了关于这个问题的一个问答和一份Java官方文档中对这些词汇的说明:\nfield\nA data member of a class. Unless specified otherwise, a field is not static.\ninstance variable\nAny item of data that is associated with a particular object. Each instance of a class has its own copy of the instance variables defined in the class. Also called a field. See also class variable.\nclass variable\nA data item associated with a particular class as a whole\u0026ndash;not with particular instances of the class. Class variables are defined in class definitions. Also called a static field. See also instance variable.\nproperty\nCharacteristics of an object that users can set, such as the color of a window.\n也就是说除非特别声明，域指的是类的实例变量（非静态的类变量），属性的概念说的比较抽象，它是一个用户可以改变的对象特征。可以这样理解，由于域可以是私有的和公开的，而上面property词条表明属性是公开的，那么定义为private的域可以通过声明public的get或set方法使其成为对象的一个属性。那么简而言之可以认为属性本质上而言是可以从对象外部公开访问的域。这反应了Kotlin的一种设计意图，即一致性。和Java域相比Kotlin属性的语义约束性更强，Kotlin属性是对外公开的。Kotlin的属性提供了这样一种一致性，即对象的属性只能通过访问器访问。\n所以Kotlin声称它的类没有域，即不能直接访问对象的实例变量。对于public变量，编译器会自动生成访问器，任何对变量的读写，包括访问器自身内部都使用访问器来进行。\n那么类中的private变量算什么呢？根据上述属性的一般性概念，可以认为是的，private实例变量不属于属性，它仅是类内部的一种状态，如果该变量没有明确声明访问器，编译器也不会为其默认生成，此时对变量的访问是直接的，对Kotlin编译出的字节码文件的观察也证实了这一点。但如果为private变量明确声明访问器又会是什么情况？为了保持该变量是对象私有的这种一致性，不允许像Java一样声明public的getter和setter来绕开私有可见性的声明，但不妨碍通过声明其它public方法来访问该变量，而这与对象方法可以访问对象的所有成员是一致的。为了保证这种一致性，这种情况下对该实例变量的读写将分别通过对应的访问器进行访问。\n这种设计原由可以这样理解，在对象内部，对于提供了访问器的私有实例变量而言，访问器是对象中其它成员访问它的唯一途径，那么相对于其它成员而言，它自身是也一个对象，它的值就是它的属性（这里的意思和上面英文词条中的一样，即用户可以改变的对象的特征），这里用户成了对象内部的其它成员，这个可以改变的特征就是它的值，即它的值就是它的属性（Kotlin中的属性），而它的值就是它自身，所以它成了一个属性，这里要加上一个必要条件，即相对对象内部成员。\n那么现在可以将两种情况统一起来，可以认为属性就是指提供了访问器的实例变量。\n那么当真正需要使用域时该怎么办。Kotlin提供了一个自动支撑域，可以通过field标识符在访问器中使用。\nvar counter = 0 // the initializer value is written directly to the backing field set(value) { if (value \u0026gt;= 0) field = value } 但支撑域只能在访问器中使用，如果想像Java那样自由地在任何地方访问原始实例变量又该怎么办，即不通过访问器读写实例变量？从上面的分析中可以看到，这样的变量不是属性，声明一个没有访问器的实例变量就可以了，通过将变量声明为private并且不重写其访问器就可以了，kotlin称其为支撑属性。如下所示：\nprivate var _table: Map\u0026lt;String, Int\u0026gt;? = null public val table: Map\u0026lt;String, Int\u0026gt; get() { if (_table == null) { _table = HashMap() // Type parameters are inferred } return _table ?: throw AssertionError(\u0026#34;Set to null by another thread\u0026#34;) } 懒初始化 上面的类属性必须在声明时或者构造器中进行初始化，但这样有许多不便之处，例如使用依赖注入进行对象初始化或者单元测试中不能提供一个非空的初始化器，但你仍然想在引用属性时避免null检查。此时，可以使用lateinit关键词修饰属性：\npublic class MyTest { lateinit var subject: TestSubject @SetUp fun setup() { subject = TestSubject() } @Test fun test() { subject.method() // dereference directly } } 它只能用于属性变量，并且属性没有自定义访问器，属性的类型必须是不可为null的，并且不能是基础数据类型。\n编译时常量 使用const关键词修饰，并且满足以下条件的属于编译时常量：\n对象的顶级成员 使用String或基本类型进行初始化 没有自定义getter const val constant: String = \u0026#34;Constant string.\u0026#34; ","permalink":"https://epicmars.github.io/blog/kotlin/2017-10-30-kotlin-properties/","summary":"参考：\n对象表达式与声明 类属性 类属性是定义在类中的变量或不变量，分别使用var和val定义。这里把Kotlin中的不变量和常量作下区分，不变量只是在第一次初始化后便不可改变，其余特性和变量完全一样，但它不是常量，常量的说明在后面的小节给出。\nKotlin对类属性的完整声明是：\n(var|val) \u0026lt;propertyName\u0026gt;[: \u0026lt;PropertyType\u0026gt;] [= \u0026lt;property_initializer\u0026gt;]\r[\u0026lt;getter\u0026gt;]\r[\u0026lt;setter\u0026gt;]\r方括号[]表示该部分是可选的，其中属性初始化器、getter、setter在任何情况下都是可选的，如果属性类型可以从属性初始化器或getter中推断出，那么它也是可选的。使用val所声明的不变量是没有setter的。\n类属性可以不显式地初始化，但未显式初始化的属性必须在构造器中初始化：\nvar allByDefault: Int? // error: explicit initializer required, default getter and setter implied var initialized = 1 // has type Int, default getter and setter val simple: Int? // has type Int, default getter, must be initialized in constructor val inferredType = 1 // has type Int and a default getter 属性访问器 所谓访问，就是对属性的读与写，类会为每个属性提供默认的访问器。称读访问器为getter，写访问器为setter。对于属性变量两者都会提供，不变量只有getter，显然是由于它不可改变。访问器可以在声明属性时进行重写以替换默认访问器：\nval isEmpty: Boolean private get() = this.","title":"Kotlin类属性与常量"},{"content":"类定义 类声明由类名、类首部（指定类型参数，主构造器等）、类正文（用花括号包围）。类首部和正文都是可选的。因此最简单的类定义为：\nclass Empty // Implicitly inherits from Any 类似所有Java类都继承类Object，所有Kotlin类都继承类Any，但Any不是与特定平台（例如JVM）相关的，它不是一个java.lang.Object，这表明当Kotlin与Java代码进行互操作时，为了使用Object的成员方法，Kotlin提供了扩展函数。\n例如为了调用Object的wait()/notify()方法，可以将一个kotlin对象foo转型为Object：\n(foo as java.lang.Object).wait() 为了获取一个kotlin对象的Java类，Kotlin1.1之后可以使用class引用的java扩展属性，也可以直接使用扩展属性javaClass:\nval fooClass = foo::class.java // class reference val fooClass = foo.javaClass // extension property: javaClass 与Java代码进行互操作，Kotlin在语言层面上是这样设计的，但在编译为Java字节码以及JVM运行时中，每个类总是默认继承了Object。\n构造器 Kotlin的构造器分为主构造器（primary constructor）和次要构造器（secondary constructors）。两者都是可选的，即可以不用明确定义任何构造器，这时如果该类不是抽象类，就采用默认生成的无参主构造器。主构造器只能有一个，次要构造器可以有多个，次要构造器必须代理到主构造器，可以是直接的代理或使用其它次要构造器间接代理。造器的可见性默认是public的。\n这里讨论下主构造器，先了解下Java对象的初始化，大致说了Java对象初始化机制有三种：实例初始化器（初始化块）、实例变量初始化器、构造器。初始化块和实例变量初始化器可以认为是实例初始化器的两种不同形式，实例变量初始化器只不过定义了实例变量并使用表达式而非块进行了初始化。在对象初始化时，由于存在继承层次结构，每一层级类都需要进行初始化，一个对象从自身开始向上到父类，到父类的父类等等，直到Object类，完成整个类层次的初始化。所以该对象的构造器必须直接或间接地调用父类构造器，这也说明了为什么构造器不属于Java类成员，它不会被子类继承，不然会造成初始化的死循环。构造器是初始化的入口，但不是初始化的全部，并且为了保证初始化过程的顺序，编译器会为每个构造器生成一个\u0026lt;init\u0026gt;方法，包含以下代码：\n对另一个构造函数的调用（为了直接或间接调用父类构造器） 初始化器（包括变量初始器器和块初始化器，为了保证初始化器仅运行一次，如果第1步调用是本地另一个构造函数,那么便不需要 初始化器的代码） 构造函数正文 在Kotlin中，初始化块使用init关键字声明：\ninit { print(\u0026#34;This is a intializer block.\u0026#34;) } 如果一个Kotlin类未继承其它另外定义的类，那么它默认继承类Any, 如下所示：\n未定义主构造器\n未定义次要构造器：编译器会为其生成一个无参主构造器 定义了次要构造器：那么它将仅有次要构造器，不会自动生成无参构造器 class Car { // ... constructor(type: String, name: String) { // ... } } 定义了主构造器，并且定义了次要构造器\nclass Car(type: String, name: String) { // ... constructor(brand: String, type: String, name: String) : this(type, name) { // ... } } 如果一个Kotlin类继承了一个另外定义的类，假设\n未定义主构造器 open class View { constructor(ctx: Context) { // ... } constructor(ctx: Context, attrs: AttributeSet) { // ... } } class CustomView : View { constructor(ctx: Context) : super(ctx) { // ... } constructor(ctx: Context, attrs: AttributeSet) : super(ctx, attrs) { // ... } // ... } 定义了主构造器：\b父类可以（并且必须）使用主构造器的参数在继承时进行初始化 open class Vehicle(type: String) { // ... } class Car(type: String = \u0026#34;Car\u0026#34;, name: String) : Vehicle(type) { // ... } Kotlin中可以使用一个简洁的语法来从主构造函数中定义属性并进行初始化：\nclass Person(val firstName: String, val lastName: String, var age: Int) { // ... } 嵌套与内部类（Nested and Inner Classes） 类可以嵌套在其它类中：\nclass Outer { private val bar: Int = 1 class Nested { fun foo() = 2 } } val demo = Outer.Nested().foo() // == 2 和Java作点对比，Java中有嵌套类，并且分为静态和非静态的，静态的嵌套类实际上是一个顶级类，只不过为了包管理方便，将其嵌套在另一个包围类中，和静态方法一样，它不能直接访问类对象成员，而非静态的嵌套类可以，因为它持有外部类对象的引用，它有另一个专门的名称就是内部类。那么Kotlin中嵌套类默认是不能访问外部类的成员，它不属于内部类。内部类使用inner声明，此时内部类便持有了一个对外部类对象的引用：\nclass Outer { private val bar: Int = 1 inner class Inner { fun foo() = bar } } val demo = Outer().Inner().foo() // == 1 匿名内部类 匿名内部类使用对象表达式声明，如果对象仅仅是一个Java中的功能接口（即仅有一个抽象方法的接口），那么可以使用一个lambda表达式来创建：\nval listener = ActionListener { println(\u0026#34;clicked\u0026#34;) } 抽象类 open class Base { open fun f() {} } abstract class Derived : Base() { override abstract fun f() } 接口 与Java8类似，Kotlin接口中的方法可以包含抽象方法，以及方法实现。与抽象类不同的是它们不能保存状态，即没有实例变量或者静态变量。它们可以有属性，但属性需要是抽象的或者提供访问器实现。\n使用interface关键词定义接口：\ninterface MyInterface { fun bar() fun foo() { // optional body } } 一个类可以实现一个或多个接口：\nclass Child : MyInterface { override fun bar() { // body } } 接口中的属性 接口中声明的属性是抽象的，或者提供了自定义访问器实现，其中接口中的属性没有支撑域（backing field）。\ninterface MyInterface { val prop: Int // abstract val propertyWithImplementation: String get() = \u0026#34;foo\u0026#34; fun foo() { print(prop) } } class Child : MyInterface { override val prop: Int = 29 } 接口继承冲突 如果一个类有多个超类，那么可能会继承同一个方法的多个实现，例如：\ninterface A { fun foo() { print(\u0026#34;A\u0026#34;) } fun bar() } interface B { fun foo() { print(\u0026#34;B\u0026#34;) } fun bar() { print(\u0026#34;bar\u0026#34;) } } class C : A { override fun bar() { print(\u0026#34;bar\u0026#34;) } } class D : A, B { override fun foo() { super\u0026lt;A\u0026gt;.foo() super\u0026lt;B\u0026gt;.foo() } override fun bar() { super\u0026lt;B\u0026gt;.bar() } } 接口A和B都声明了函数foo()和bar()，两者都实现了foo()，但只有B实现了bar()，如果定义一个子类C继承A，那么显然我们需要为bar()提供一个实现。\n然而，如果定义一个类D实现A和B两个接口，我们需要实现继承的多个方法，并且明确应该如何实现。这一规则对只有一个实现的方法(bar())和有多个实现的方法(foo())都适用。\n类方法 方法重写（Overriding Methods） 和类一样，Kotlin类中的方法默认是final的，即\b子类不可以重写，父类方法需要使用open声明，然后子类明确使用override声明才可以。子类override方法默认是可以重写的，如果要禁止重写，可以再加上final。\nopen class Base { open fun v() {} fun nv() {} } class Derived() : Base() { \bfinal override fun v() {} } 属性覆盖（Overriding Properties） 可见性修饰符 类、对象、接口、构造器、函数、属性和其setter可以有访问修饰符，getter的可见性总是和其属性一样。Kotlin中有四种可见性修饰符：private, protected, internal 和 public. 如果没有声明，默认是public的。\nprivate, protected, public和Java基本一致，没有包可见性的概念，internal表示模块内可见，即编译为同一模块或同一应用中的代码。\n类扩展 扩展函数 扩展属性 参考：\n类 接口 ","permalink":"https://epicmars.github.io/blog/kotlin/2017-10-29-kotlin-class-inheritance/","summary":"类定义 类声明由类名、类首部（指定类型参数，主构造器等）、类正文（用花括号包围）。类首部和正文都是可选的。因此最简单的类定义为：\nclass Empty // Implicitly inherits from Any 类似所有Java类都继承类Object，所有Kotlin类都继承类Any，但Any不是与特定平台（例如JVM）相关的，它不是一个java.lang.Object，这表明当Kotlin与Java代码进行互操作时，为了使用Object的成员方法，Kotlin提供了扩展函数。\n例如为了调用Object的wait()/notify()方法，可以将一个kotlin对象foo转型为Object：\n(foo as java.lang.Object).wait() 为了获取一个kotlin对象的Java类，Kotlin1.1之后可以使用class引用的java扩展属性，也可以直接使用扩展属性javaClass:\nval fooClass = foo::class.java // class reference val fooClass = foo.javaClass // extension property: javaClass 与Java代码进行互操作，Kotlin在语言层面上是这样设计的，但在编译为Java字节码以及JVM运行时中，每个类总是默认继承了Object。\n构造器 Kotlin的构造器分为主构造器（primary constructor）和次要构造器（secondary constructors）。两者都是可选的，即可以不用明确定义任何构造器，这时如果该类不是抽象类，就采用默认生成的无参主构造器。主构造器只能有一个，次要构造器可以有多个，次要构造器必须代理到主构造器，可以是直接的代理或使用其它次要构造器间接代理。造器的可见性默认是public的。\n这里讨论下主构造器，先了解下Java对象的初始化，大致说了Java对象初始化机制有三种：实例初始化器（初始化块）、实例变量初始化器、构造器。初始化块和实例变量初始化器可以认为是实例初始化器的两种不同形式，实例变量初始化器只不过定义了实例变量并使用表达式而非块进行了初始化。在对象初始化时，由于存在继承层次结构，每一层级类都需要进行初始化，一个对象从自身开始向上到父类，到父类的父类等等，直到Object类，完成整个类层次的初始化。所以该对象的构造器必须直接或间接地调用父类构造器，这也说明了为什么构造器不属于Java类成员，它不会被子类继承，不然会造成初始化的死循环。构造器是初始化的入口，但不是初始化的全部，并且为了保证初始化过程的顺序，编译器会为每个构造器生成一个\u0026lt;init\u0026gt;方法，包含以下代码：\n对另一个构造函数的调用（为了直接或间接调用父类构造器） 初始化器（包括变量初始器器和块初始化器，为了保证初始化器仅运行一次，如果第1步调用是本地另一个构造函数,那么便不需要 初始化器的代码） 构造函数正文 在Kotlin中，初始化块使用init关键字声明：\ninit { print(\u0026#34;This is a intializer block.\u0026#34;) } 如果一个Kotlin类未继承其它另外定义的类，那么它默认继承类Any, 如下所示：\n未定义主构造器\n未定义次要构造器：编译器会为其生成一个无参主构造器 定义了次要构造器：那么它将仅有次要构造器，不会自动生成无参构造器 class Car { // ... constructor(type: String, name: String) { // ... } } 定义了主构造器，并且定义了次要构造器\nclass Car(type: String, name: String) { // .","title":"Kotlin类与继承"},{"content":"参考:\n函数 函数(Function) Kotlin使用名称函数（function）而非方法（method），我想是为了与Java方法作出区分，和C语言类似函数可以单独定 义和使用，不依赖于类与对象，而Java中的方法只存在于某个类中。由于Kotlin与Java是兼容的，因此在类中定义的函数仍然 适用于方法这个语义。\nKotlin使用fun来声明函数:\nfun double(x: Int): Int { return 2*x } 参数 函数参数使用Pascal的表示来定义，即name: type。\n默认参数值 函数参数可以有默认值，这样在调用函数时如果没有传入某个参数，那么便使用改参数对应的默认值，这样可以从某种程度上减少 方法重载（overload）。在参数类型后，使用=后跟上一个值来定义默认值。\nfun read(b: Array\u0026lt;Byte\u0026gt;, off: Int = 0, len: Int = b.size) { ... } 对于类中方法的重写（override），子类方法总是使用与父类方法相同的默认值，并且子类方法签名中不能有默认值。\nopen class A { open fun foo(i: Int = 10) { ... } } class B : A() { override fun foo(i: Int) { ... } // no default value allowed } 命名参数值 看到这里，发现这和Python语法太TM像了。默认参数传递是根据位置来判断的，称为位置参数，由于有了默认参数，可能调用时 传入的参数比签名中的少，例如调用时，一个参数值前面有一个忽略了的默认参数，该参数值的位置被提前了，这时根据位置就无 法判断参数值与参数的对应关系，此时需要将该非默认参数值使用参数名明确标出。\nfun reformat(str: String, normalizeCase: Boolean = true, upperCaseFirstLetter: Boolean = true, divideByCamelHumps: Boolean = false, wordSeparator: Char = \u0026#39; \u0026#39;) { ... } 该函数可以这样调用：\nreformat(str) reformat(str, wordSeparator = \u0026#39;_\u0026#39;) 命名参数调用方式不能用于Java方法，因为Java字节码并不总是保存参数名。\n不定长参数 不定长参数（Variable number of arguments）使用关键词vararg定义，传入的参数可以使用展开（spread）操作符得到：\nfun foo(vararg strings: String) { /* ... */ } foo(strings = *arrayOf(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;)) foo(strings = \u0026#34;a\u0026#34;) // Not required for a single value 参数列表中，只能有一个参数是不定长的。如果不定长参数不是最后一个参数，那么随后的参数需要使用命名参数进行传递，或者 如果随后的参数是一个函数类型那么，可以通过在参数表括弧外传递lambda表达式。\n如果已经有了一个数组作为传递的参数值, 展开操作符还可以这样使用:\nfoo(\u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;, strings = *arrayOf(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;)) 返回单元（Unit）的函数 如果函数不返回有用的值，那么其返回值就是Unit。Unit是只有一个值的类型，该值即Unit。\n单一表达式函数 当一个函数返回一个单一表达式时，函数体的花括弧可以去掉，并且将表达式以赋值的形式赋值给函数定义。\nfun double(x: Int): Int = x * 2 返回类型可以忽略，因为编译器可以从表达式推断出：\nfun double(x: Int) = x * 2 中缀表示 当一个函数满足以下条件时可以使用中缀表达式进行调用：\n属于成员方法或扩展函数 有单一参数 使用infix关键字标记 // Define extension to Int infix fun Int.shl(x: Int): Int { ... } // call extension function using infix notation 1 shl 2 // is the same as 1.shl(2) 函数作用域 Kotlin中除了可以定义为文件中的顶级函数外，还可以定义为局部函数，成员函数以及扩展函数。\n局部函数 定义在另一个函数中的一个函数，它可以访问外部函数的局部变量：\nfun dfs(graph: Graph) { val visited = HashSet\u0026lt;Vertex\u0026gt;() fun dfs(current: Vertex) { if (!visited.add(current)) return for (v in current.neighbors) dfs(v) } dfs(graph.vertices[0]) } 成员函数 即类或对象中的方法。\n其它类型函数 泛型函数 内联函数 扩展函数 高阶函数与Lambdas 尾递归函数 ","permalink":"https://epicmars.github.io/blog/kotlin/2017-10-29-kotlin-function/","summary":"参考:\n函数 函数(Function) Kotlin使用名称函数（function）而非方法（method），我想是为了与Java方法作出区分，和C语言类似函数可以单独定 义和使用，不依赖于类与对象，而Java中的方法只存在于某个类中。由于Kotlin与Java是兼容的，因此在类中定义的函数仍然 适用于方法这个语义。\nKotlin使用fun来声明函数:\nfun double(x: Int): Int { return 2*x } 参数 函数参数使用Pascal的表示来定义，即name: type。\n默认参数值 函数参数可以有默认值，这样在调用函数时如果没有传入某个参数，那么便使用改参数对应的默认值，这样可以从某种程度上减少 方法重载（overload）。在参数类型后，使用=后跟上一个值来定义默认值。\nfun read(b: Array\u0026lt;Byte\u0026gt;, off: Int = 0, len: Int = b.size) { ... } 对于类中方法的重写（override），子类方法总是使用与父类方法相同的默认值，并且子类方法签名中不能有默认值。\nopen class A { open fun foo(i: Int = 10) { ... } } class B : A() { override fun foo(i: Int) { ... } // no default value allowed } 命名参数值 看到这里，发现这和Python语法太TM像了。默认参数传递是根据位置来判断的，称为位置参数，由于有了默认参数，可能调用时 传入的参数比签名中的少，例如调用时，一个参数值前面有一个忽略了的默认参数，该参数值的位置被提前了，这时根据位置就无 法判断参数值与参数的对应关系，此时需要将该非默认参数值使用参数名明确标出。","title":"Kotlin函数"},{"content":"MVP与MVVM，该选哪一个？ 目前为止，我在工作中用过的应用架构有基于Otto的总线模式和MVP模式，业余时间使用Clean架构和MVVM做过一些开发。对于这些模式有一些很好的开源项目可以参考:\nGoogle应用架构蓝图 Clean结构示例 对于架构的搭建，除了采用第三方库以外，还可以使用Google官方的应用架构组件：\nAndroid应用架构组件指南 架构组件示例 架构这么多，应该怎么选择？建议根据项目实际情况作出选择，如果只是一个小的玩具项目，可以不用任何架构，大的项目也不应该陷入了过度设计的误区。\n概念 为什么需要这些架构以及怎么选择？首先要明确这些架构中的几个概念。从MVC被提出以来，发展到如今的MVP，MVVM等等，所有这些架构中有两个层都没有变化，那就是模型（Model）和视图（View）。\n业务 业务是应用所提供的服务。可以是后端远程提供的服务以本地化的方式展现，也可以是单独的本地服务。\n视图 视图是业务的用户界面（user interface）。它为用户提供操作和展示业务的接口，用户不一定是人，也可以是消息，例如一个外部的推送服务，它通过消息接口与业务交互，所以界面也不一定是肉眼可见的界面。\n模型 模型是对业务在软件工程中的抽象与建模。它提供了开展所有业务需要数据实体和状态，以及管理这些数据和状态的接口。具体实现中一般是简单的数据访问与状态改变。\n领域 一个应用领域指一个独立完整的应用。不同的应用属于不同的领域。它包含了对模型和以及与模型交互的抽象（这里与模型交互的抽象不是指对视图的抽象），一般不涉及具体的实现和具体的用户界面。\n领域架构 这一架构主要是根据Clean架构的思想得来的，如果将Interface替换为UserCase那基本上就是Clean架构了。那么有何改进和区别，在上面链接的示例以及实际使用Clean架构中发现，如果使Domain完全成为一个Java库，然后在各个层之间定义对应的实体进行转换会增加大量的工作和复杂度。虽然说这样是为了达到完全的解耦，但很明显，这个Java库一般并不会用到非Android平台中，这样做的意义不大。还有一点是UserCase的使用过于冗余了，并且现在有了RxJava和LiveData这样的基于观察者模式的响应式编程库，在模型和视图的交互中，不用再编写大量的回调接口。\n其中Domain层中的实体和Data层中的实体是一致的。并且不使用UserCase来进行交互，而是直接调用接口，然后从返回的被观察者更新视图就可以了。\n这种基于Domain的模式是十分灵活和易于扩展的，即可以直接从View调用Domain中的接口，也可以在这两者间添加Presenter/Controller/ViewModel层。它仍具有Clean架构中分层的和解耦方面的优点，易于编写测试。可以说这种方式即适用于小型项目，也适用于中大型项目。\n实现 Domain层是无关具体实现的，可以专门定义面向用户的接口，然后在Data层中实现。Data层中有实体对象访问的Dao和访问服务器的API等接口，并且可以采用仓储模式来隐藏访问的细节，这样Data中会多一层Repository接口。如果这样实现，视图和模型间会有用户接口和仓储接口这两层接口，显得有点冗余了。\n这里有一个接口粒度的问题，可以认为是一个接口方法调用所需要完成工作的量，如果Domain中的接口粒度和Data仓储接口粒度一致，那么可以将两者合并。实际中发现，除非能够在应用开发前就确定两种接口的粒度大小，不然将它们两者分别实现没有太大的意义，但这样做不太现实，因为如果业务频繁地变更，Domain的接口也随之改变，无法在开发之初就完成这项工作。因此一开始将两种接口合并就好了，并且我们不希望业务变化时Data的接口也频繁地变化，不然两层之间的解耦就没有意义了，那么可以从Data层中去掉Repository接口，或者将其提升为Domain层的用户接口。\n","permalink":"https://epicmars.github.io/blog/android/architecture/2018-07-08-from-mvc-to-mvvm/","summary":"MVP与MVVM，该选哪一个？ 目前为止，我在工作中用过的应用架构有基于Otto的总线模式和MVP模式，业余时间使用Clean架构和MVVM做过一些开发。对于这些模式有一些很好的开源项目可以参考:\nGoogle应用架构蓝图 Clean结构示例 对于架构的搭建，除了采用第三方库以外，还可以使用Google官方的应用架构组件：\nAndroid应用架构组件指南 架构组件示例 架构这么多，应该怎么选择？建议根据项目实际情况作出选择，如果只是一个小的玩具项目，可以不用任何架构，大的项目也不应该陷入了过度设计的误区。\n概念 为什么需要这些架构以及怎么选择？首先要明确这些架构中的几个概念。从MVC被提出以来，发展到如今的MVP，MVVM等等，所有这些架构中有两个层都没有变化，那就是模型（Model）和视图（View）。\n业务 业务是应用所提供的服务。可以是后端远程提供的服务以本地化的方式展现，也可以是单独的本地服务。\n视图 视图是业务的用户界面（user interface）。它为用户提供操作和展示业务的接口，用户不一定是人，也可以是消息，例如一个外部的推送服务，它通过消息接口与业务交互，所以界面也不一定是肉眼可见的界面。\n模型 模型是对业务在软件工程中的抽象与建模。它提供了开展所有业务需要数据实体和状态，以及管理这些数据和状态的接口。具体实现中一般是简单的数据访问与状态改变。\n领域 一个应用领域指一个独立完整的应用。不同的应用属于不同的领域。它包含了对模型和以及与模型交互的抽象（这里与模型交互的抽象不是指对视图的抽象），一般不涉及具体的实现和具体的用户界面。\n领域架构 这一架构主要是根据Clean架构的思想得来的，如果将Interface替换为UserCase那基本上就是Clean架构了。那么有何改进和区别，在上面链接的示例以及实际使用Clean架构中发现，如果使Domain完全成为一个Java库，然后在各个层之间定义对应的实体进行转换会增加大量的工作和复杂度。虽然说这样是为了达到完全的解耦，但很明显，这个Java库一般并不会用到非Android平台中，这样做的意义不大。还有一点是UserCase的使用过于冗余了，并且现在有了RxJava和LiveData这样的基于观察者模式的响应式编程库，在模型和视图的交互中，不用再编写大量的回调接口。\n其中Domain层中的实体和Data层中的实体是一致的。并且不使用UserCase来进行交互，而是直接调用接口，然后从返回的被观察者更新视图就可以了。\n这种基于Domain的模式是十分灵活和易于扩展的，即可以直接从View调用Domain中的接口，也可以在这两者间添加Presenter/Controller/ViewModel层。它仍具有Clean架构中分层的和解耦方面的优点，易于编写测试。可以说这种方式即适用于小型项目，也适用于中大型项目。\n实现 Domain层是无关具体实现的，可以专门定义面向用户的接口，然后在Data层中实现。Data层中有实体对象访问的Dao和访问服务器的API等接口，并且可以采用仓储模式来隐藏访问的细节，这样Data中会多一层Repository接口。如果这样实现，视图和模型间会有用户接口和仓储接口这两层接口，显得有点冗余了。\n这里有一个接口粒度的问题，可以认为是一个接口方法调用所需要完成工作的量，如果Domain中的接口粒度和Data仓储接口粒度一致，那么可以将两者合并。实际中发现，除非能够在应用开发前就确定两种接口的粒度大小，不然将它们两者分别实现没有太大的意义，但这样做不太现实，因为如果业务频繁地变更，Domain的接口也随之改变，无法在开发之初就完成这项工作。因此一开始将两种接口合并就好了，并且我们不希望业务变化时Data的接口也频繁地变化，不然两层之间的解耦就没有意义了，那么可以从Data层中去掉Repository接口，或者将其提升为Domain层的用户接口。","title":"从MVC到MVVM"},{"content":"Component注解 Component注解用于注解一个接口或抽象类，以便从其Module集合中生成一个完全成型的依赖注入实现。\n每个使用@Component注解的类型必须包含至少一个抽象组件方法（Component methods），组件方法可以拥有任何名称，但其签名必须遵循供给和成员注入协约。\n供给方法（Provision methods） 供给方法没有参数，并返回一个被注入或者被供给的类型，每个方法也可以有一个限定符注解，以下都是有效的供给方法：\nSomeType getSomeType();\rSet\u0026lt;SomeType\u0026gt; getSomeTypes();\r@PortNumber int getPortNumber();\r供给方法和注入点一样可以使用Provider或Lazy更加显示地控制供给请求，Provider允许组件用户通过调用Provider.get()来请求任意次的供给，Lazy自始至终只会请求单个供给，但会将其推迟到对Lazy.get()的首次调用。以下供给方法都请求对同一类型的供给，但分别应用了不同的机制：\nSomeType getSomeType();\rProvider\u0026lt;SomeType\u0026gt; getSomeTypeProvider();\rLazy\u0026lt;SomeType\u0026gt; getLazySomeType();\r成员注入方法（Members-injection methods） 成员注入方法具有单个参数，并将依赖注入到传入实例的每个使用Inject注解的域和方法，一个成员注入方法可以是void的，也可以返回其单个参数以便链接。以下都是合法的成员注入方法声明：\nvoid injectSomeType(SomeType someType);\rSomeType injectAndReturnSomeType(SomeType someType)\r一个没有参数但返回MembersInjector的方法和成员注入方法是等效的，在返回对象上调用MembersInjector.injectMembers(T)方法和成员注入方法的作用一样：\nMembersInjector\u0026lt;SomeType\u0026gt; getSomeTypeMembersInjector();\r关于协方差的注意事项 尽管一个类型的成员注入方法会可以接收其子类的实例（参数是返回类型的子类），只有参数类型和其超类的Inject注解成员会被注入，而参数类型的子类则不会，例如，如下类型中，当将Child实例作为参数传入成员注入方法injectSelf(Self instance)时只有a和b会被注入，\nclass Parent {\r@Inject A a;\r}\rclass Self extends Parent {\r@Inject B b;\r}\rclass Child extends Self {\r@Inject C c;\r}\r实例化 组件（Component）的实例化主要通过生成的builder。一个builder实例通过组件上的builder()方法获取，返回的builder有一个方法用于设置每个modules() 和组件dependencies()，它们都以每个module或dependency类型的小写驼峰形式命名。每个缺少默认构造函数的组件dependency和module都必须显式地设置，但任何具有默认或无参构造函数（可以被组件实现访问）的module则可以忽略。如下所示：\npublic static void main(String[] args) {\rOtherComponent otherComponent = ...;\rMyComponent component = DaggerMyComponent.builder()\r// required because component dependencies must be set\r.otherComponent(otherComponent)\r// required because FlagsModule has constructor parameters\r.flagsModule(new FlagsModule(args))\r// may be elided because a no-args constructor is visible\r.myApplicationModule(new MyApplicationModule())\r.build();\r}\r一种情形中，组件没有依赖组件，并且仅有无参module，那么生成的builder会有一个工厂方法create()，此时SomeComponent.create() 和 SomeComponent.builder().build() 都是有效并等效的。\n范围（Scope） 每个Dagger组件都可以使用范围注解来赋予其一个范围，组件实现确保每个组件的实例的每个范围绑定只有一个供给，如果组件申明了一个范围，那么它只能包含无范围的绑定或图中任意处属于该范围的绑定，例如：\n@Singleton @Component\rinterface MyApplicationComponent {\r// this component can only inject types using unscoped or @Singleton bindings\r}\r为了获取与一个范围注解相关的适当的行为，它的调用者有责任在适当的时候实例化新的组件，例如，一个Singleton组件在一个应用中只应当实例化一次，而一个RequestScoped组件则应当在每次请求是初始化，因为组件是自包含的实现，跳出一个范围就只是简单地丢弃所有对组件的引用。\n组件关系（Component relationships） 尽管具有单纯无范围绑定的的独立组件十分有用，许多应用还是会调用许多不同范围的不同组件进行交互，Dagger提供了关联组件的两种机制。\n子组件（Subcomponents） 关联两个组件最简单的方式是声明一个子组件，子组件的行为和普通组件极为相似，只不过其实现在一个父组件或子组件内部生成。这一关系允许子组件实现在声明时继承父组件的的全部绑定图，为此，子组件直到关联到一个父组件时才验证其完整性。\n子组件通过父组件或子组件上的工厂方法声明，方法可以任意命名，但必须返回子组件，工厂方法的参数可以是任意数量的子组件模块，但必须至少包含没有可见无参构造函数的。下面的例子中，一个工厂方法从一个singleton范围的父组件中创建了一个request范围的子组件。\n@Singleton @Component\rinterface ApplicationComponent {\r// component methods...\rRequestComponent newRequestComponent(RequestModule requestModule);\r}\r组件依赖（Component dependencies） 尽管子组件是组合绑定的子图（subgraphs of bindings）的最简单的方式，子组件和父组件是强耦合的，他们或许会使用由前辈组件或子组件中定义的任意的绑定，作为一种可选的方法，通过定义一个组件依赖，一个组件只能使用另一个组件的绑定，当一个类型作为组件依赖时，依赖中的每个供给方法作为一个provider进行绑定。注意只有以供给方法暴露的的绑定才可以通过组件依赖获取到。\n","permalink":"https://epicmars.github.io/blog/android/library/2016-07-12-dagger2-api/","summary":"Component注解 Component注解用于注解一个接口或抽象类，以便从其Module集合中生成一个完全成型的依赖注入实现。\n每个使用@Component注解的类型必须包含至少一个抽象组件方法（Component methods），组件方法可以拥有任何名称，但其签名必须遵循供给和成员注入协约。\n供给方法（Provision methods） 供给方法没有参数，并返回一个被注入或者被供给的类型，每个方法也可以有一个限定符注解，以下都是有效的供给方法：\nSomeType getSomeType();\rSet\u0026lt;SomeType\u0026gt; getSomeTypes();\r@PortNumber int getPortNumber();\r供给方法和注入点一样可以使用Provider或Lazy更加显示地控制供给请求，Provider允许组件用户通过调用Provider.get()来请求任意次的供给，Lazy自始至终只会请求单个供给，但会将其推迟到对Lazy.get()的首次调用。以下供给方法都请求对同一类型的供给，但分别应用了不同的机制：\nSomeType getSomeType();\rProvider\u0026lt;SomeType\u0026gt; getSomeTypeProvider();\rLazy\u0026lt;SomeType\u0026gt; getLazySomeType();\r成员注入方法（Members-injection methods） 成员注入方法具有单个参数，并将依赖注入到传入实例的每个使用Inject注解的域和方法，一个成员注入方法可以是void的，也可以返回其单个参数以便链接。以下都是合法的成员注入方法声明：\nvoid injectSomeType(SomeType someType);\rSomeType injectAndReturnSomeType(SomeType someType)\r一个没有参数但返回MembersInjector的方法和成员注入方法是等效的，在返回对象上调用MembersInjector.injectMembers(T)方法和成员注入方法的作用一样：\nMembersInjector\u0026lt;SomeType\u0026gt; getSomeTypeMembersInjector();\r关于协方差的注意事项 尽管一个类型的成员注入方法会可以接收其子类的实例（参数是返回类型的子类），只有参数类型和其超类的Inject注解成员会被注入，而参数类型的子类则不会，例如，如下类型中，当将Child实例作为参数传入成员注入方法injectSelf(Self instance)时只有a和b会被注入，\nclass Parent {\r@Inject A a;\r}\rclass Self extends Parent {\r@Inject B b;\r}\rclass Child extends Self {\r@Inject C c;\r}\r实例化 组件（Component）的实例化主要通过生成的builder。一个builder实例通过组件上的builder()方法获取，返回的builder有一个方法用于设置每个modules() 和组件dependencies()，它们都以每个module或dependency类型的小写驼峰形式命名。每个缺少默认构造函数的组件dependency和module都必须显式地设置，但任何具有默认或无参构造函数（可以被组件实现访问）的module则可以忽略。如下所示：\npublic static void main(String[] args) {\rOtherComponent otherComponent = .","title":"Dagger2 Api"}]