[{"summary":"HTTPS(Hypertext Transfer Protocol Secure)译为超文本传输安全协议，也称为HTTP over TLS，HTTP over SSL或HTTP Secure，它对HTTP协议进行的扩展，用于在计算机网络上进行安全通信。其主要目的是对站点服务器进行身份认证，保护交换数据的隐私与完整性。\nSSL/TLS协议 HTTP协议位于TCP/IP四层模型最高层的应用层。HTTPS是在HTTP所在的应用层加入一个子层，位于HTTP子层之下，传输层之上。\n根据RFC:\nTLS协议的主要目的是为两个通信应用间提供隐私与数据完整性。该协议主要由两层组成：TLS Record协议和TLS Handshake协议。在某个稳定的传输协议（如TCP）之上，在最底层是TLS Record协议。\nTLS Record协议所提供的连接安全性有两个基本属性：\n连接是私有的。\n对称加密用于数据加密（例如AES, RC4等），每个连接都会生成唯一的对称加密秘钥，并且该秘钥是基于另一个协议（例如TLS Handshake协议）经过协商后的秘钥得来的。Record协议也可以不使用加密。\n连接是可靠的。\n消息传输包含一个使用一个使用秘钥的MAC的消息完整性检查。安全哈希函数（例如，SHA-1等）用于MAC计算。Record协议可以不使用MAC进行运行，但这种情况通常仅使用在这种模式下，即另一个协议将Record协议作为协商安全参数的传输器。\nTLS Record协议用于封装更高层级的协议。其中一个就是TLS Handshake协议，它允许服务器和客户端对彼此进行认证并且在应用层协议传输和接收数据的第一个字节前协商一个加密算法以及要使用的秘钥。\nTLS Handshake协议提供的连接安全性有三个基本性质：\n对等端的身份可以使用非对称加密或公钥密码学（如，RSA，DSA等）进行认证，这种认证是可选的，但一般需要对等端至少一方进行认证。\n对共享秘钥的协商是安全的：协商的秘钥是不能被窃听者获取的，并且对任意未认证的连接都不能获取到秘钥，即使攻击者位于连接的中间。\n协商是可靠的：没有攻击者能够修改协商通信内容并且不被通信方发现。\nTLS的一项优点是它是与应用协议独立的，更高层级的协议可以透明地置于TLS协议之上。TLS标准并没有指定什么协议可以使用TLS来添加安全性，如何初始化TLS握手以及如何解释认证证书交换的决定留给TLS之上的协议的设计者和实现者。\nHTTPS连接的建立与加密通信 在实现中，SSL/TLS子层作为HTTP子层和传输层的中间层，对套接字接口进行了一层封装，用于建立安全连接与通信。会话状态的加密参数是通过TLS握手协议来生成的，当一个TLS客户端和服务端首次开始进行通信时，它们在一个协议版本上达成一致、选择密码学算法、可选地对对方进行认证，并使用公钥加密技术来生成共享秘钥。\n它包含如下步骤：\n交换hello消息来对算法达成一致，交换随机值并进行恢复会话的检查 交换必要的机密参数，运行客户端和服务端对预主密钥（premaster secret）达成一致 交换证书和密码学信息，允许客户端和服务端对彼此进行认证 从预主密钥（premaster secret）生成一个主密钥并交换随机值 为Record层提供安全参数 允许客户端和服务端确认它们的对等端计算出相同的安全参数并且握手没有被攻击者干预 TLS握手的完整步骤如下所示（其中带*表示可选的或根据情况进行发送的消息，并不总是会发送）：\nClient Server\rClientHello --------\u0026gt;\rServerHello\rCertificate*\rServerKeyExchange*\rCertificateRequest*\r\u0026lt;-------- ServerHelloDone\rCertificate*\rClientKeyExchange\rCertificateVerify*\r[ChangeCipherSpec]\rFinished --------\u0026gt;\r[ChangeCipherSpec]\r\u0026lt;-------- Finished\rApplication Data \u0026lt;-------\u0026gt; Application Data\r可以使用openssl提供的工具来查看这一步骤的实际数据交换情况：","title":"HTTPS与SSL/TLS协议"},{"summary":"CA 证书颁发机构（CA, Certificate Authorities）根据认证操作规则 (CPS) 授权颁发、暂停、更新或取消证书的实体。在其颁发的所有证书和 CRL 中都可通过识别名称来识别 CA。证书颁发机构必须公布其公钥，或者如果该证书颁发机构隶属一级证书颁发机构，则由更高级的 CA 提供证书证明其公钥的合法性。\n数字证书（Digital Certificates）是可进行验证的包含身份证明的小的数据文件，它可以帮助网站、个人、设备来代表他们真实可信的在线身份（可信是因为CA已经对身份进行了验证）。CA在互联网上的操作以及如何进行透明可信的事务中扮演了关键角色。每年，证书机构都会颁发上百万的数字证书，它们用于保护信息，加密数以十亿计的事务，并确保安全的通信。\n如何保证CA可信 浏览器、操作系统和移动设备会运行一个已授权的CA成员资格程序，其中一个CA必须满足详细的标准才能够被接受作为其中一员。一旦所接受的CA能够颁发直接被浏览器信任的证书，随后，人们和设备就可以依赖该证书进行工作。仅有少量经过授权的CA，从私有公司到政府机构都有，并且CA运作的越久，就会有越多的浏览器和设备信任该CA颁发的证书。\n在颁发一个数字证书前，CA会对申请者的身份进行一些检查。这些检查与所申请的证书类型相关，例如，一个对域名所有权进行验证的SSL证书（Domain Validated (DV SSL) Certificates）会将已经验证了所有权的域名包含到证书中。而一个可扩展SSL(Extended Validation SSL)会包含公司相关的额外信息，这些信息由CA通过许多公司检查进行验证。\n证书有许多种类型，不仅仅是支持SSL，还可以用于对人员和设备进行认证，对代码和文档添加合法性证明等。\nPKI与信任层级 浏览器和设备通过在其根证书库（Root Store）中接受根证书（Root Certificate）来信任一个CA，这个根证书库本质上是一个预先安装在浏览器或设备上的已信任CA数据库。Windows、Apple、Mozilla以及一般的移动媒介都运行自己的根证书库。\n各CA使用这些预安装的根证书来办法中介根证书和终端实体数字证书。CA接收证书请求，验证申请者，颁发证书，并对依赖于该证书的任何人发布已颁发证书的持续的有效性状态。\nCA通常会创建一些中介CA（ICA，Intermediate CA）,用于办法终端实体证书，如SSL证书，这称为一个信任层次。\n遵循最佳安全实践，CA不应该直接从发布给媒介的根证书来颁发数字证书，而应该通过一个或多个ICA。\nCA是如何运作的 作为互联网中一个可信任的锚点，CA具有重大的责任。因此，在满足可审计的需求下运行一个CA是一个复杂的任务。一个CA基础设施由大量运作元素，硬件、软件、政策框架以及实践声明、审计、安保基础设施和人员组成。总体上，这些元素称为一个可信任的PKI(Public Key Infrastructure)。\nSSL与TLS SSL(Secure Socket Layers)是指安全套接字层，它是一项标准技术，用于确保互联网连接安全。 TLS(Transport Layer Security)指传输层安全，它是SSL的升级版。\n历史简介 SSL和TLS都是加密协议，用于提供服务器、设备、应用在网络上的认证和数据加密。SSL是先于TLS设计出的，最初它是由网景公司于1995年首先公布的，最初的版本是SSL2.0（SSL1.0从未公开发布）。在修正若干缺陷后，1996年版本2.0迅速被SSL3.0所取代。\nTLS在1999年作为基于SSL3.0的一个新版本被发布，根据RFC2246：\n该协议和SSL3.0没有十分巨大的差别，但已有的差别就足以使得两者不能进行互操作。\nSSL2.0和SSL3.0分别在2011和2015年已经被IETF废弃，因此现在应该使用TLS协议。\nSSL和TLS采用不同的加密方式。\nSSL和TLS仅仅指客端和服务器端进行的握手，握手并没有进行任何加密，它仅仅是对需要共享的秘钥和加密类型上达成一致。\nSSL/TLS证书 SSL证书是数字证书的一种，它用于将一个网站服务器的所有者详情和加密秘钥进行绑定。在浏览器和持有SSL证书的服务器之间，这些秘钥用于在SSL/TLS协议中激活一个安全会话。为了让浏览器相信一个SSL证书，并在不引起安全性警告的前提下建立SSL/TLS会话，SSL证书必须包含网站的域名，并且由可信任的CA颁发，并且没有过期。\nSSL证书的功能 因此SSL证书主要有两个功能：\n认证与验证\nSSL证书中包含有关于一个人、商业或站点的身份的特定细节的可靠性信息。其中CA颁发的扩展验证SSL证书对申请人的审查标准最为严格，因此它是最值得信赖的SSL证书。\n数据加密\nSSL证书也可以进行加密，也就意味着通过网络交换的敏感信息不回被第三者窃取并破译出。\n其用途举例如下：\n保障站点和用户浏览器通信的安全 保障企业内网内部通信的安全 保障通过网络进行的邮件通信的安全 保障通过因特网或内网进行的服务器间通信的安全 保障移动设备收发信息的安全 SSL证书的类型 目前有如下几种不同类型的证书：\n自签发证书\n主要用于内部使用的非CA颁发的证书。如果在外部使用，因为其不具备可信任的身份认证能力，不能用于辨别伪造的服务器。\n域名验证证书\n可以快速进行颁发的入门级SSL证书。对申请人的验证中唯一需要确认的是其对域名的所有权。\n完全认证证书","title":"CA与SSL/TLS证书"},{"summary":"动态规划（Dynamic programming）通常用来解决最优化问题，在这类问题中，通过做出一组选择来达到最优解。在做出每个选择的同时，通常会生成与原问题形式相同的子问题。当多于一个选择子集都生成相同的子问题时，动态规划技术通常就会很有效，其关键技术就是对每个这样的子问题都保存其解，当重复出现时即可便重复求解。\n动态规划与分治方法相似，都是通过组合子问题的解来求解原问题，分治法将问题划分为不相交的子问题，递归地求解子问题，再将它们组合起来求出原问题的解。与之相反，动态规划应用于子问题重叠的情况，即不同的子问题具有公共的子子问题（子问题的求解是递归进行的，将其划分为更小的子子问题）。\n实现方法 与朴素递归算法之所以效率很低，是因为它反复求解相同的子问题。因此，动态规划方法仔细安排求解顺序，对每个子问题只求解一次，并将结果保存下来，如果随后再次需要此子问题的解，只需查找保存的结果，而不必重新计算。因此，动态规划方法是通过额外的空间来换取时间，是典型的时空权衡（time-memory trade-off）的例子。并且时间上的节约可能是非常巨大的，可能将一个指数时间的解转化为一个多项式时间的解。动态规划有两种等价的实现方法，分别是带备忘的自顶向下法和自底向上法。\n带备忘的自顶向下法(top-down with memoization)\n此方法仍按自然的递归形式编写过程，但过程会保存每个子问题的解（通常保存在一个数组或散列表中)。当需要一个子问题的解时，过程首先检查是否已经保存过此解。如果是则直接返回保存的值，从而节省了计算时间，否则，按通常的方式计算这个子问题。\n自底向上法(bottom-up method)\n这种方法一般需要恰当定义子问题“规模”的概念，使得任何子问题的求解都只依赖于“更小的”子问题的求解。因而可以将子问题按规模排序，按由小至大的顺序进行求解。当求解某个大问题时，它所依赖的那些更小的子问题都已经求解完毕，结果已经保存。么个子问题只需求解一次，当我们求解它时，它所有的前提子问题都已经求解完成。\n两种方法得到的算法具有相同的渐进运行时间，仅有的差异是在某些特殊情况下，自顶向下的方法并未真正递归地考察所有可能的子问题。由于没有频繁递归函数调用的开销，自底向上方法的时间复杂度函数通常具有更小的系数。\n子问题图 在思考一个动态规划问题时，应该弄清楚所涉及的子问题和子问题之间的依赖关系。问题的子问题图准确第表达了这些信息。它是一个有向图，每个顶点对应一个子问题，若求解子问题x的最优解时需要直接用到子问题y的最优解，那么在子问题图中就有一条从子问题x的顶点到子问题y的顶点的有向边。\n自底向上的动态规划方法处理子问题图中顶点的顺序为：对于一个给定的子问题x，在求解它之前求解邻接到它的子问题y。即自底向上动态规划算法是按“逆拓扑序（reserve topological sort）”来处理子问题图中的顶点。类似，可以用“深度优先搜索”来描述自顶向下动态规划算法处理子问题的顺序。","title":"动态规划"},{"summary":"图论问题渗透整个计算机科学，解决图论问题的相关算法对计算机科学领域至关重要。最基本的是对图的遍历与搜索，不过首先要讨论的是如何将图表示为可用的数据结构。\n图的表示 算法导论中介绍了图的两种常用表示方法，分别是邻接链表和邻接矩阵，在面向对象编程中，还有一种常用表示方法，即对象和指针（引用），也有称为边列表（edge list）。\n根据图的定义，有向图和无向图均由一个顶点集合和这个顶点集合$V$中顶点间是否连接以及是否有向所构成的一个边集合$E$组成，定义图为顶点集和相应边集的二元组\\(G = (V, E)\\)，对图的三种表示形式只是对这一定义在编程语言或者说是内存中的表示形式。其中对象和指针（边列表）表示方法是最接近原始的定义的，即顶点集合与边集合。\n将图的n个顶点使用0到n-1的序号进行编号，下面分别对三种表示方法进行描述，并比较其在如下几个方面的不同：\n内存占用 判断两个顶点是否相连(即连接这两个顶点的边是否存在)的时间复杂度 寻找一个顶点的所有邻居顶点 对象指针（边列表） 对象指针 Set\u0026lt;Vertex\u0026gt; vertexSet = new HashSet(); Set\u0026lt;Edge\u0026gt; edgeSet = new HashSet(); Vertex a = new Vertex(0); Vertex b = new Vertex(1); Vertex c = new Vertex(2); Vertex d = new Vertex(3); vertexSet.add(Arrays.asList({})); edgeSet.addAll(Arrays.asList({new Edge(a, b), new Edge(a, c), new Edge(a, d), new Edge(b, a), new Edge(c, a), new Edge(c, d), new Edge(d, a), new Edge(d, c)})); 边列表 边列表中的每个元素表示两个相邻顶点构成的边，其中顶点用其序号给出。 int[][] edgeList = {{0, 1}, {0, 2}, {0, 3}, {1, 0}, {2, 0}, {2, 3}, {3, 0}, {3, 2}}; 邻接链表 邻接链表中第$i$个元素包含与顶点$v[i]$相邻的其它顶点的序号：","title":"图的表示与搜索"},{"summary":"在二叉搜索树的讨论中可以得出各种查询以及插入、删除操作的时间复杂度上界为$O(h)$，其中$h$为树的高度，即树的叶子节点的最大深度。\n因此树的高度很大程度上决定了动态集合操作的时间复杂度。对于一个包含确定数量元素的二叉搜索树，我们希望得到一棵较为“平衡”的二叉树，即后代结点能够较均匀分布在一个祖先结点的两颗子树中，这样相对于元素总量，其高度是一个较小的值。因此，可以将平衡的度量认为是树高h与结点总量n的比率$\\frac{h}{n}$，即结点对树高的平均贡献率。\n考察树的第i层的$k_i$个结点，有：\n$$ n = \\sum\\limits_{i=0}^h k_i, \\space k_i \\leq 2^i $$\n如果树中有大量不平衡的结点，那么每个第i层的结点越少，会导致树高$h$越大。\n红黑树及其性质 红黑树是平衡二叉搜索树的一种，可以保证最坏情况下动态集合操作的时间复杂度为$O(\\lg n)$，它在每个结点上增加一个存储位来表示结点颜色，可以是RED或BLACK，通过对任一条从根到叶子结点的路径上各个结点的颜色进行约束，可以确保没有一条路径会比其它路径长出2倍，因而是近似于平衡的。\n一棵红黑树中的每个结点包含5个属性，color，key，left，right和p，如果一个结点没有子结点或父结点，这改结点相应指针属性的值为NIL，可以把这些NIL视为指向二叉搜索树的叶结点（外部结点）的指针，而把带关键字的结点视为树的内部结点。\n一棵红黑树是满足下面红黑性质的二叉搜索树：\n每个结点是红色的或黑色的 根结点是黑色的 每个叶结点（NIL）是黑色的 如果一个结点是红色的，则它的两个子结点都是黑色的 对每个结点，从该结点到所有后代叶结点的简单路径上，均包含相同数目的黑色结点 从某个结点x出发(不含该结点)到达一个叶结点的任意一条简单路径上的黑色结点个数称为该结点的黑高(black height)，定义红黑树的黑高为其根结点的黑高。\n红黑树动态集合操作 对不修改树的数据结构的操作，如遍历、查询、最大、最小、前驱、后继一类操作对红黑树和普通二叉搜索树都是一样的，对于插入与删除操作，红黑树需要进行额外的变换，不仅改变数据结构，也需要改变结点的颜色以保证红黑树的性质。\n旋转 对于数据结构的修改，可以通过旋转来完成，它是能保持二叉搜索树的性质的局部操作。主要有两种旋转方式，分别为左旋和右旋。\n插入 首先采用稍作修改的普通二叉搜索树插入方法将新的结点插入到树中，为了保证红黑树的性质，还需要对结点进行着色和旋转操作。\n删除 首先采用进行了一定修改的普通的二叉搜索树删除方法将给定结点z从树T中删除，其中需要维持一个结点y为从树中删除的结点或移至树内的结点，并记录y的初始颜色，如果y的初始颜色为黑色，那么需要进行着色和旋转操作来恢复红黑性质。此外还要跟踪移动到结点y原来位置的x结点，因为它也有可能破坏红黑树性质。","title":"红黑树"},{"summary":"定义 自由树 自由树是一个连通的、无环的无向图。一个可能不连通的的无向无环图为森林。\n有根树和有序树 有根树是一棵自由树，其顶点中存在一个与其它顶点不同的顶点，称其为树的根，一棵有根树的顶点常常称为树的结点。\n在一棵有根树T中，从根结点r到结点x的唯一简单路径上的任意结点y为x的一个祖先结点，x称为y的后代结点，每一个结点既是自己的祖先也是自己的后代，如果y是x的祖先，并且y不是x，那么称y为x的真祖先,x为y的真后代。如果y是x的真祖先，并且与x直接相连，则称y为x的父母结点，x为y的孩子结点。根是树中唯一没有父结点的结点，如果两个结点的父结点是同一个，则称它们为兄弟结点。一个没有子结点的结点称为叶子结点或外部结点，而非叶结点是内部结点。\n树T中一个结点x的子结点数称为结点x的度，从根结点r到结点x的一条简单路径的长度称为x在T中的深度，根结点的深度为0。树的一个层包含了同一深度的所有结点。结点在树中的高度是指从该结点到叶结点最长的一条简单路径的边数。树的高度也就是树中结点的最大深度。\n有序树是一棵有根树，其中每个结点的子结点是有序的。\n二叉树与位置树 采用递归的方式定义二叉树，一个二叉树T是定义在有限结点集合上的结构，它不包含任何结点或者包含三个不相交的结点集合：一个根结点，一棵称为左子树的二叉树，以及一棵称为右子树的二叉树。\n不包含任何结点的二叉树称为空树或零树，有时用符号NIL表示。在上述递归定义中，如果左子树非空则它的根称为整棵树的根的左孩子，类似，右子树的根称为整棵树根的右孩子。如果子树是零树，则称该孩子是缺失的或者丢失的。\n位置树是保留了结点位置信息的树，有序树属于位置树。二叉树是结点的度最大为2的有序树，但有序树在子结点仅有一个（即度为1）时可以对子结点进行区分，而二叉树必须区分是左孩子还是右孩子。因此可以使用一个有序树的内部结点来表示二叉树的位置信息，通过将树中每个缺失的孩子使用一个无孩子的结点代替，得到一棵满二叉树，每个结点是叶结点或者度为2，那么就不存在度为1的结点，那么结点的孩子的顺序就保留了位置信息。\n这种位置信息的区分可以扩展到k叉树，即每个结点度最大为k的位置树。完全k叉树是所有叶结点深度相同，且所有内部结点度为k的k叉树。如果树的高度为h，则叶结点数目为$h^k$个。\n二叉搜索树 搜索树数据结构支持许多动态集合操作，包括搜索，最大值，最小值，查找前驱与后继，插入，删除等操作，即适合作为字典也可以作为一个优先队列。\n二叉搜索树是以一棵二叉树来组织的，可以采用链表数据结构来表示，每个结点是一个对象，除了key和卫星数据，每个结点还包含属性left,right和p，分别指向结点的左孩子，右孩子和父母结点。如果某个子结点或者父结点不存在则相应的属性值为NIL。\n二叉搜索树中的关键字总是以满足二叉搜索树性质的方式来存储：\n设x是二叉搜索树的一个结点，如果y是x左子树中的一个结点，那么y.key≤x.key。如果y是x右子树中的一个结点，那么y.key≥x.key。\n遍历 遍历顺序：\n中序遍历：子树根位于左子树和右子树之间 先序遍历：子树根位于左子树和右子树之前 后序遍历：子树根位于左子树和右子树之后 查询 除了search操作，还支持minimum，maximum，successor，predecessor查询，对于高度为h的二叉树，每个操作可以在O(h)时间内完成。\n插入与删除 插入与删除操作会引起二叉搜索树的动态集合变化。必须要修改数据结构来反映这个变化，但修改要保持二叉搜索树的性质成立。\n插入 设要将一个新的值v插入到树T，从根结点r开始进行比较，如果$v \\le r.key$，那么v需要插入到r的左子树中，这个问题便成了将v插入到以r.left为根的左子树的问题，如果$v \\ge r.key$，那么v需要插入到r的右子树中，此外还需要考虑比较相等情况下的处理。\n但这个问题可以一般化为将v插入到T的一个子树的问题，在插入时进行比较的过程中，对于一个比较结点x如果$v \\le x.key$或者$v \\ge x.key$，则继续分别在x的左右子树寻找插入的位置，直到比较结点为空，那么这个空位置即为要寻找的插入位置。\n对于比较相等的情况，将其插入到比较结点的左子树或者右子树都是可行的，此时位置查找方式与上述小于或大于的情况一样，另一种做法可以直接使v成为比较结点左子树或右子树的根。但这样需要采用两种方式来修改数据结构，因此一般采用一致的插入到空位置方法。\n删除 设要从树T中删除一个结点z，分下面三种情况进行考虑：\nz没有孩子结点：直接删除 z有一个孩子结点：用z的孩子替换z z有两个孩子结点：寻找z的后继y，让y占据z的位置 对于第3种情况，y在z的右子树中，并且y没有左孩子，找到y后，需要将y移出原来的位置并进行拼接，然后替换z，考虑两种情况：\ny是z的右孩子，保留y的右孩子并替换z y不是z的右孩子，首先用y的右孩子替换y，然后用y替换z ","title":"树与搜索树"},{"summary":"顺序统计量（Order statistic） 一个n位元素组成的集合中，第i个顺序统计量是该集合中第i小的元素。例如，最小值是第一个顺序统计量（i=1），最大值是第n个顺序统计量(i=n)。\n中位数（Median） 中位数是顺序统计量的一种，它是集合中的中点元素，与上述顺序统计量的描述一致，i从1开始计数。当n为奇数时，中位数有唯一一个，位于i=(n+1)/2处，当n为偶数时，中位数有两个，分别为上中位数(n/2)与下中位数(n/2+1)。\n问题与定义 讨论中一个由n个互异的元素构成集合中选择第i个顺序统计量的问题，为方便讨论，假设元素都是互异的，但实际上这里的讨论都可以推广到包含重复元素的集合中。对这一问题的形式化定义为\n输入：一个包含n个互异元素的集合A和一个整数i，1≤ i ≤n。 输出：元素x属于集合A，且A中恰好有i-1个其它元素小于它。 基本思想 随机划分 使用类似快排的划分思路，选择一个主元（pivot），将序列中的其它元素进行划分为小于等于主元和大于等于主元的两个子序列，如果主元的顺序统计量就是要查找的顺序统计量则查找成功，如果目标顺序统计量小于主元的顺序统计量，则从较小的子序列中根据上述同样的过程进行查找，否则则在较大的子序列中进行查找。\n确定性划分 确定性划分首先将序列分为较小的组，每一组有一个较小常数数量的元素，对每个分组进行排序，找出每组的中位数，然后对每组的中位数用同样的方式进行划分后查找这些中位数的中位数。利用每组中位数的中位数作为主元对序列进行划分，划分后的处理方式与随机划分相似。这里的重点是分组后的中位数的中位数x可以将序列划分为较为平均的两部分，因为，各分组的中位数y小于x的分组中小于中位数y的必定也小于x，中位数y大于x的分组中大于y的元素也必定大于x，它们大约各占整个序列的1/4，这样就避免了随机划分可能出现较差的情况。\n实现 使用随机划分子序列的算法 def swap(A, i, j): temp = A[i] A[i] = A[j] A[j] = temp def random_select(A, p, r, i): \u0026#34;\u0026#34;\u0026#34; A: 要查找的序列 p: 序列开始索引，包含 r: 序列结束索引，包含 i: 要查找的顺序统计量 \u0026#34;\u0026#34;\u0026#34; # 如果只有一个元素，直接返回 if p == r: return A[p] q = random_partition(A, p, r) if i == q: return A[q] if i \u0026lt; q: return random_select(A, p, q-1, i) else: return random_select(A, q+1, r, i) def random_partition(A, p, r): \u0026#34;\u0026#34;\u0026#34; A: 要划分的序列 p: 序列开始索引，包含 r: 序列结束索引，不包含 \u0026#34;\u0026#34;\u0026#34; # 这里直接从中间进行划分 mid = (p + r) / 2 pivot = A[mid] # 主元 left = p # [p,left)间的元素都小于等于主元 right = r # (right,r]间的元素都大于等于主元 while left \u0026lt; right: if A[left] \u0026gt;= pivot and A[right] \u0026lt;= pivot: swap(A, left, right) left += 1 right -= 1 else: if A[left] \u0026lt; pivot: left += 1 if A[right] \u0026gt; pivot: right -= 1 return left def main(): A = [100, 134, -1, 1324, 1123, 9, 34, 3, -98, 132, 3, 3, 12, 29, 36] for i in xrange(0, len(A)-1): print random_select(A, 0, len(A)-1, i) if __name__ == \u0026#39;__main__\u0026#39;: main() 使用确定性划分的算法 def swap(A, i, j): temp = A[i] A[i] = A[j] A[j] = temp def insertion_sort(A, r): for i in xrange(0, len(r)): current = i for j in xrange(i, -1, -1): if A[r[current]] \u0026lt; A[r[j]]: swap(A, r[current], r[j]) current = j def median(A, r): # print \u0026#34;median\u0026#34;, r insertion_sort(A, r) if len(r) % 2 == 1: return r[len(r) / 2] else: return r[len(r) / 2 - 1] def select(A, r, i): # print \u0026#34;select\u0026#34;, r \u0026#34;\u0026#34;\u0026#34; A: 要查找顺序统计量的序列 r: 查找的序号 \u0026#34;\u0026#34;\u0026#34; size = len(r) if size == 1: return r[0] start = r[0] # start index in A end = r[size - 1] # end index in A medians = [] if size % 5 == 0: num = size / 5 else: num = size / 5 + 1 for j in xrange(0, num): s = j * 5 # start index of r e = s + 5 # end index of r if e \u0026gt;= size: e = size m = median(A, r[s : e]) medians.","title":"中位数与顺序统计量"},{"summary":"排序算法下界 对任意的比较排序算法都可以抽象为一棵决策树，它是一棵完全二叉树，可以表示在给定输入规模下对所有元素的比较操作，其中，控制、数据移动等其它操作都被忽略。对于一个正确的排序算法，它都能够生成输入的每一种排列，所以对一个正确的比较排序算法来说，n个元素的$n!$种可能的排列都应该出现在决策树的叶结点上，对于一个给定的输入，其排序结果必然就是这所有可能中的某一个。\n根据这个比较排序的决策树模型，从根结点到一个可达的叶结点之间的最长简单路径的长度，表示的是对应排序算法中最坏情况下的比较次数，它等于决策树的高度。因此，当决策树中的每种排列都是以可达的叶结点形式出现时，该决策树高度的下界也就是比较排序算法运行时间的下界。\n最坏情况的下界 考虑一棵高度为h，具有l个可达叶结点的决策树，它对应一个对n个元素所做的比较排序，输入的$n!$种可能的排序都是叶结点，并且一棵高度为h的二叉树中，叶结点的数量不多于$2^h$，因此有： $$ n! \\leq l \\leq 2^h $$ 得到 $$ h \\geq \\lg (n!) = \\Omega (n\\lg n) $$\n计数排序 适用场景 n个输入元素是0到k区间的整数，或者元素可以通过转换函数，在不丢失大小信息的情况下，唯一地映射到0到k区间某一个整数。\n基本思想 对每一个输入元素x确定小于x的元素个数，利用这一信息可以直接将x放到它在输出数组中的位置上。\n实现 def counting_sort_integer(A, B, k): C = [0 for x in xrange(0, k+1)] for x in A: C[x] += 1 for i in xrange(0, k+1): if i \u0026gt; 0: C[i] += C[i-1] for x in A: # index start with 0, so minus 1 B[C[x]-1] = x C[x] -= 1 if __name__ == \u0026#39;__main__\u0026#39;: A = [123, 21, 14321, 0, 120, 98, 1000, 1024, 123, 1, 0, 123, 24, 123, 3, 2, 12] B = [None] * len(A) counting_sort_integer(A, B, 14321) print B 基数排序 适用场景 对具有多关键字域的记录或某一基数表示的数（二进制位表示，10进制数，16进制数，字符串等）进行排序，其共同的特点是每个元素有d位，每一位有一个固定的取值区间，因此可以利用到计数排序的方法。","title":"线性时间排序"},{"summary":"堆 堆是一个数组，可以看作一个近似的完全二叉树，树中的每一个节点对应于数组中的一个元素。除了最底层的叶节点，往上的所有层都是完全填充的，并且都是从左向右进行填充。表示堆的数组A有两个属性：A.length表示数组大小，A.heap-size表示堆大小，即堆中有多少个元素存在数组中。\n算法导论中将根节点的序号设定为1，但实际使用的数组都是从0开始的，即从偶数开始填充堆，那么为了使数组依次逐层进行填充，对于一个节点在数组中的序号i，其左右孩子为:\nLeft(i): 2i+1\rRight(i): 2i+2\r根据左右孩子可以将一个序号为i的节点的父节点计算为：\nParent(i): floor((i-1)/2)\r最大堆与最小堆 最大堆是父节点的值大于等于子节点的值，反之，最小堆是子节点的值大于等于父节点的值。在堆排序中使用最大堆，最小堆通常用于构造优先队列。\n最大堆与堆排序 class Heap: def __init__(self, array, heap_size = None): if heap_size is not None: self.heap_size = heap_size else: self.heap_size = len(array) self.array = array @classmethod def left(cls, i): return (i \u0026lt;\u0026lt; 1) + 1 @classmethod def right(cls, i): return (i \u0026lt;\u0026lt; 1) + 2 @classmethod def parent(cls, i): return (i - 1) / 2 @classmethod def swap(cls, A, i, j): temp = A[i] A[i] = A[j] A[j] = temp class MaxHeap(Heap): def __init__(self, array, heap_size = None): Heap.","title":"堆与堆排序"},{"summary":"定义 归并排序采用分治策略进行比较操作排序，将待排序的n个元素分解为个含n/2个元素的两部分，使用递归或其它方式迭代地两个子序列进行同样的排序操作，然后合并两个已排序的子序列。\n分析 序列的划分 序列的划分较为简单直接，n为奇数时两部分长度相差1，可以规定将较长的一部分作为第二部分的长度。\n序列的合并 从最基本的合并开始，如果划分到一个子序列仅有一个元素时，不能进一步划分，对该子序列的归并排序会直接返回，对应于n=1时的归并排序，是直接求解的不需要进行归并操作。当单元素子序列归并排序完成时，将两个子序列进行合并得到两个元素的子序列，对应于n=2时的归并排序就完成了，以此类推，不失一般性考虑如何合并任意大小的两个已排序子序列的问题。\n对于序列的划分操作需要进行lgn次，每次都需要对n个元素进行合并操作，而合并本身也是对两个有序子序列的再排序，合并的开销必须尽可能地小，至少需要将所有子序列遍历一遍，其渐进复杂度下界是Ω(n)。如果采用原址排序的方式，由于两个子序列除了自身是有序的，两者之间没有任何联系，这会是一个一般性的排序问题。因此，为了利用已排序的子序列，将两者复制后依次进行比较并合并回原序列中。\n实现 def merge_sort(A, start, end): if end - start \u0026lt;= 1: return mid = (end + start) / 2 merge_sort(A, start, mid) merge_sort(A, mid, end) merge(A, start, mid, end) def merge(A, start, mid, end): left = [] right = [] for i in xrange(start, mid): left.append(A[i]) for i in xrange(mid, end): right.append(A[i]) i = 0 j = 0 current = start left_size = len(left) while i \u0026lt; left_size and j \u0026lt; len(right): if left[i] \u0026lt;= right[j]: A[current] = left[i] i += 1 else: A[current] = right[j] j += 1 current += 1 for k in xrange(i, left_size): A[current] = left[k] current += 1 if __name__ == \u0026#39;__main__\u0026#39;: A = [12, 12, 123, 234, 1, 2, 3, 4000, 12, 234, 1, 891] merge_sort(A, 0, len(A)) print A ","title":"归并排序（Merge sort）"},{"summary":"参考：\n基本类型 相等性 空指针安全性 类型检查与转换 Java中有8种基本类型byte，short，int，long，float，double，boolean，char，还提供了支持字符串的java.lang.String类，最后提供了上述的数组类型。Kotlin中的数据类型与Java基本一致，不过可以将基本数据类型也看做对象。\n数字 类型 |位宽度\r--------|---------\rDouble\t|64\rFloat\t|32\rLong |64\rInt |32\rShort\t|16\rByte\t|8 \b注意，Kotlin中字符不是数字。\n在Java平台中，数字的以JVM中的基本数据类型保存于物理存储，除非我们想要一个可以为空(nullable)的数字或者使用了泛型，那么这时数字会装箱（boxed）为对应的类型。\n数字装箱后不保留同一性（identity），但保留相等性（equality），这与Java中是一样的，两个数字值相等的对象是不同的两个对象，但它们的值是相等的。\n与Java中不同的是，同一性比较使用三个等号符号：===或者!==，相等性比较使用：==或者!=。\n对于数字的\b\b隐式转换和自动\b拆装箱，对比\bJava中和Kotlin中有何区别：\nJava中，表达式中的数字类型会自动拆箱为对应的基础类型，然后向上转型为表达式中较大的基础类型。自动装箱只能发生在对应的基础类型上。 Integer a = 11; Short b = 12; Long c = 13L; int i = 1; short j = 2; long k = 3; k = a; k = a + b; k = i + j; k += i; a = a + b; a = i + j; c += i; c = 14; // error, right expression is \u0026#39;int\u0026#39; c = i + j; // error, right expression is \u0026#39;int\u0026#39; c = a + b; // error, right expression is \u0026#39;int\u0026#39; Kotlin中，与类型系统是相关的，因为所有数字类型都认为是对象，可以认为没有拆箱的说法，并且也没有隐式的类型提升，运算符事实上都是重载的操作符。 var a: Int?","title":"Kotlin数据类型"},{"summary":"参考：\nLambdas 高阶函数 一个高阶函数接收函数作为其参数，或者返回一个函数。举个栗子，如下所示，lock()函数接收一个lock对象和一个函数，获取锁，运行函数，然后释放锁：\nfun \u0026lt;T\u0026gt; lock(lock: Lock, body: () -\u0026gt; T): T { lock.lock() try { return body() } finally { lock.unlock() } } body有一个函数类型：() -\u0026gt; T，它是一个返回类型为T的值的方法。\n如果我们想调用lock()，我们可以将另一个函数作为参数传递给它（参考：方法引用):\nfun toBeSynchronized() = sharedResource.operation() val result = lock(lock, ::toBeSynchronized) 此外，一个更加便捷的方式是传递一个lambda表达式:\nval result = lock(lock, { sharedResource.operation() }) Lambda表达式先简要介绍下，后面小节会有详细描述：\n一个lambda表达式总是由花括弧包围 它的参数在记号-\u0026gt;前声明，参数类型可以忽略 正文跟在-\u0026gt;后 在Kotlin中如果一个函数的最后一个参数是一个函数，并且使用lambda表达式传递对应的参数，有一个简便的方式来表示，即将lambda表达式放在函数参数列表括弧外：\nlock (lock) { sharedResource.operation() } 另一个例子，如下map()函数所示：\nfun \u0026lt;T, R\u0026gt; List\u0026lt;T\u0026gt;.map(transform: (T) -\u0026gt; R): List\u0026lt;R\u0026gt; { val result = arrayListOf\u0026lt;R\u0026gt;() for (item in this) result.","title":"Kotlin高阶函数与Lambdas"},{"summary":"参考:\n对象声明 对象表达式和声明（Object Expressions and Declarations） 对象表达式（Object expressions） Object表达式可以创建匿名类：\nwindow.addMouseListener(object : MouseAdapter() { override fun mouseClicked(e: MouseEvent) { // ... } override fun mouseEntered(e: MouseEvent) { // ... } }) 与Java匿名类不同的是，Java仅仅只能使用已有类型进行实例化，Kotlin可以在实例化匿名类时对匿名类进行定义，也就是说匿名类不用使用已有类型，如下所示：\n继承已有的类型：\nopen class A(x: Int) { public open val y: Int = x } interface B {...} val ab: A = object : A(1), B { override val y = 15 } 或者不继承已有的类，默认继承Any：\nfun foo() { val adHoc = object { var x: Int = 0 var y: Int = 0 } print(adHoc.","title":"Kotlin对象"},{"summary":"数据类（Data Classes） 我们常常创建仅仅持有数据的类，类似Java中的POJO或JavaBean，其对象我们一般称为实体（entity），因此它对应我们常说的Entity类。在一般UI应用分层架构中，例如MVC，MVP，MVVM等，都含有一个模型（Model）层，实体类型就属于这一块，它是构建业务的基石。\n为此Kotlin专门定义了data类型：\ndata class User(val name: String, val age: Int) 编译器会根据主构造函数中声明的属性自动生成如下成员：\nequals()/hashCode()对 toString()方法，返回字符串形式为\u0026quot;User(name=John, age=42)\u0026quot; componentN() 方法，其中N对应于属性声明的顺序 copy()函数 为了保持生成代码的一致性和行为的有效性，data类必须满足以下要求：\n主构造器需要至少一个参数 所有主构造器参数需要声明为val或var Data类型不能是abstruct、open、sealed或inner的 此外，对于成员继承，成员生成遵循以下规则：\n如果一个data类正文中明确实现了equals(),hashCode(),toString()方法，或者超类中有final修饰的实现，那么这些方法便不会生成，直接使用已有的实现。 如果超类有open修饰的componentN()方法并且返回兼容的类型，那么对应的生成方法会重写超类的方法，否则会报错。 显式地实现componentN()和copy()是不允许的 在JVM中，如果生成类需要有一个无参构造器，所有属性的默认值必须明确指定。\ndata class User(val name: String = \u0026#34;\u0026#34;, val age: Int = 0) 拷贝 copy()方法有什么用？有时我们需要拷贝一个对象，同时改变它的某些属性，并保持其它属性不变，使用copy()方法就可以了，其实现类似这样：\nfun copy(name: String = this.name, age: Int = this.age) = User(name, age) 对象的属性值作为copy的默认参数值，我们可以传递希望改变的值，而保留其它值不变：\nval jack = User(name = \u0026#34;Jack\u0026#34;, age = 2) val newJack = jack.copy(name = \u0026#34;New Java\u0026#34;) 结构声明（Destructuring Declarations） 生成的component方法可以使它们使用解构声明中：","title":"Kotlin类的定义"},{"summary":"参考：\n对象表达式与声明 类属性 类属性是定义在类中的变量或不变量，分别使用var和val定义。这里把Kotlin中的不变量和常量作下区分，不变量只是在第一次初始化后便不可改变，其余特性和变量完全一样，但它不是常量，常量的说明在后面的小节给出。\nKotlin对类属性的完整声明是：\n(var|val) \u0026lt;propertyName\u0026gt;[: \u0026lt;PropertyType\u0026gt;] [= \u0026lt;property_initializer\u0026gt;]\r[\u0026lt;getter\u0026gt;]\r[\u0026lt;setter\u0026gt;]\r方括号[]表示该部分是可选的，其中属性初始化器、getter、setter在任何情况下都是可选的，如果属性类型可以从属性初始化器或getter中推断出，那么它也是可选的。使用val所声明的不变量是没有setter的。\n类属性可以不显式地初始化，但未显式初始化的属性必须在构造器中初始化：\nvar allByDefault: Int? // error: explicit initializer required, default getter and setter implied var initialized = 1 // has type Int, default getter and setter val simple: Int? // has type Int, default getter, must be initialized in constructor val inferredType = 1 // has type Int and a default getter 属性访问器 所谓访问，就是对属性的读与写，类会为每个属性提供默认的访问器。称读访问器为getter，写访问器为setter。对于属性变量两者都会提供，不变量只有getter，显然是由于它不可改变。访问器可以在声明属性时进行重写以替换默认访问器：\nval isEmpty: Boolean private get() = this.","title":"Kotlin类属性与常量"},{"summary":"类定义 类声明由类名、类首部（指定类型参数，主构造器等）、类正文（用花括号包围）。类首部和正文都是可选的。因此最简单的类定义为：\nclass Empty // Implicitly inherits from Any 类似所有Java类都继承类Object，所有Kotlin类都继承类Any，但Any不是与特定平台（例如JVM）相关的，它不是一个java.lang.Object，这表明当Kotlin与Java代码进行互操作时，为了使用Object的成员方法，Kotlin提供了扩展函数。\n例如为了调用Object的wait()/notify()方法，可以将一个kotlin对象foo转型为Object：\n(foo as java.lang.Object).wait() 为了获取一个kotlin对象的Java类，Kotlin1.1之后可以使用class引用的java扩展属性，也可以直接使用扩展属性javaClass:\nval fooClass = foo::class.java // class reference val fooClass = foo.javaClass // extension property: javaClass 与Java代码进行互操作，Kotlin在语言层面上是这样设计的，但在编译为Java字节码以及JVM运行时中，每个类总是默认继承了Object。\n构造器 Kotlin的构造器分为主构造器（primary constructor）和次要构造器（secondary constructors）。两者都是可选的，即可以不用明确定义任何构造器，这时如果该类不是抽象类，就采用默认生成的无参主构造器。主构造器只能有一个，次要构造器可以有多个，次要构造器必须代理到主构造器，可以是直接的代理或使用其它次要构造器间接代理。造器的可见性默认是public的。\n这里讨论下主构造器，先了解下Java对象的初始化，大致说了Java对象初始化机制有三种：实例初始化器（初始化块）、实例变量初始化器、构造器。初始化块和实例变量初始化器可以认为是实例初始化器的两种不同形式，实例变量初始化器只不过定义了实例变量并使用表达式而非块进行了初始化。在对象初始化时，由于存在继承层次结构，每一层级类都需要进行初始化，一个对象从自身开始向上到父类，到父类的父类等等，直到Object类，完成整个类层次的初始化。所以该对象的构造器必须直接或间接地调用父类构造器，这也说明了为什么构造器不属于Java类成员，它不会被子类继承，不然会造成初始化的死循环。构造器是初始化的入口，但不是初始化的全部，并且为了保证初始化过程的顺序，编译器会为每个构造器生成一个\u0026lt;init\u0026gt;方法，包含以下代码：\n对另一个构造函数的调用（为了直接或间接调用父类构造器） 初始化器（包括变量初始器器和块初始化器，为了保证初始化器仅运行一次，如果第1步调用是本地另一个构造函数,那么便不需要 初始化器的代码） 构造函数正文 在Kotlin中，初始化块使用init关键字声明：\ninit { print(\u0026#34;This is a intializer block.\u0026#34;) } 如果一个Kotlin类未继承其它另外定义的类，那么它默认继承类Any, 如下所示：\n未定义主构造器\n未定义次要构造器：编译器会为其生成一个无参主构造器 定义了次要构造器：那么它将仅有次要构造器，不会自动生成无参构造器 class Car { // ... constructor(type: String, name: String) { // ... } } 定义了主构造器，并且定义了次要构造器\nclass Car(type: String, name: String) { // .","title":"Kotlin类与继承"},{"summary":"参考:\n函数 函数(Function) Kotlin使用名称函数（function）而非方法（method），我想是为了与Java方法作出区分，和C语言类似函数可以单独定 义和使用，不依赖于类与对象，而Java中的方法只存在于某个类中。由于Kotlin与Java是兼容的，因此在类中定义的函数仍然 适用于方法这个语义。\nKotlin使用fun来声明函数:\nfun double(x: Int): Int { return 2*x } 参数 函数参数使用Pascal的表示来定义，即name: type。\n默认参数值 函数参数可以有默认值，这样在调用函数时如果没有传入某个参数，那么便使用改参数对应的默认值，这样可以从某种程度上减少 方法重载（overload）。在参数类型后，使用=后跟上一个值来定义默认值。\nfun read(b: Array\u0026lt;Byte\u0026gt;, off: Int = 0, len: Int = b.size) { ... } 对于类中方法的重写（override），子类方法总是使用与父类方法相同的默认值，并且子类方法签名中不能有默认值。\nopen class A { open fun foo(i: Int = 10) { ... } } class B : A() { override fun foo(i: Int) { ... } // no default value allowed } 命名参数值 看到这里，发现这和Python语法太TM像了。默认参数传递是根据位置来判断的，称为位置参数，由于有了默认参数，可能调用时 传入的参数比签名中的少，例如调用时，一个参数值前面有一个忽略了的默认参数，该参数值的位置被提前了，这时根据位置就无 法判断参数值与参数的对应关系，此时需要将该非默认参数值使用参数名明确标出。","title":"Kotlin函数"},{"summary":"MVP与MVVM，该选哪一个？ 目前为止，我在工作中用过的应用架构有基于Otto的总线模式和MVP模式，业余时间使用Clean架构和MVVM做过一些开发。对于这些模式有一些很好的开源项目可以参考:\nGoogle应用架构蓝图 Clean结构示例 对于架构的搭建，除了采用第三方库以外，还可以使用Google官方的应用架构组件：\nAndroid应用架构组件指南 架构组件示例 架构这么多，应该怎么选择？建议根据项目实际情况作出选择，如果只是一个小的玩具项目，可以不用任何架构，大的项目也不应该陷入了过度设计的误区。\n概念 为什么需要这些架构以及怎么选择？首先要明确这些架构中的几个概念。从MVC被提出以来，发展到如今的MVP，MVVM等等，所有这些架构中有两个层都没有变化，那就是模型（Model）和视图（View）。\n业务 业务是应用所提供的服务。可以是后端远程提供的服务以本地化的方式展现，也可以是单独的本地服务。\n视图 视图是业务的用户界面（user interface）。它为用户提供操作和展示业务的接口，用户不一定是人，也可以是消息，例如一个外部的推送服务，它通过消息接口与业务交互，所以界面也不一定是肉眼可见的界面。\n模型 模型是对业务在软件工程中的抽象与建模。它提供了开展所有业务需要数据实体和状态，以及管理这些数据和状态的接口。具体实现中一般是简单的数据访问与状态改变。\n领域 一个应用领域指一个独立完整的应用。不同的应用属于不同的领域。它包含了对模型和以及与模型交互的抽象（这里与模型交互的抽象不是指对视图的抽象），一般不涉及具体的实现和具体的用户界面。\n领域架构 这一架构主要是根据Clean架构的思想得来的，如果将Interface替换为UserCase那基本上就是Clean架构了。那么有何改进和区别，在上面链接的示例以及实际使用Clean架构中发现，如果使Domain完全成为一个Java库，然后在各个层之间定义对应的实体进行转换会增加大量的工作和复杂度。虽然说这样是为了达到完全的解耦，但很明显，这个Java库一般并不会用到非Android平台中，这样做的意义不大。还有一点是UserCase的使用过于冗余了，并且现在有了RxJava和LiveData这样的基于观察者模式的响应式编程库，在模型和视图的交互中，不用再编写大量的回调接口。\n其中Domain层中的实体和Data层中的实体是一致的。并且不使用UserCase来进行交互，而是直接调用接口，然后从返回的被观察者更新视图就可以了。\n这种基于Domain的模式是十分灵活和易于扩展的，即可以直接从View调用Domain中的接口，也可以在这两者间添加Presenter/Controller/ViewModel层。它仍具有Clean架构中分层的和解耦方面的优点，易于编写测试。可以说这种方式即适用于小型项目，也适用于中大型项目。\n实现 Domain层是无关具体实现的，可以专门定义面向用户的接口，然后在Data层中实现。Data层中有实体对象访问的Dao和访问服务器的API等接口，并且可以采用仓储模式来隐藏访问的细节，这样Data中会多一层Repository接口。如果这样实现，视图和模型间会有用户接口和仓储接口这两层接口，显得有点冗余了。\n这里有一个接口粒度的问题，可以认为是一个接口方法调用所需要完成工作的量，如果Domain中的接口粒度和Data仓储接口粒度一致，那么可以将两者合并。实际中发现，除非能够在应用开发前就确定两种接口的粒度大小，不然将它们两者分别实现没有太大的意义，但这样做不太现实，因为如果业务频繁地变更，Domain的接口也随之改变，无法在开发之初就完成这项工作。因此一开始将两种接口合并就好了，并且我们不希望业务变化时Data的接口也频繁地变化，不然两层之间的解耦就没有意义了，那么可以从Data层中去掉Repository接口，或者将其提升为Domain层的用户接口。","title":"从MVC到MVVM"},{"summary":"Component注解 Component注解用于注解一个接口或抽象类，以便从其Module集合中生成一个完全成型的依赖注入实现。\n每个使用@Component注解的类型必须包含至少一个抽象组件方法（Component methods），组件方法可以拥有任何名称，但其签名必须遵循供给和成员注入协约。\n供给方法（Provision methods） 供给方法没有参数，并返回一个被注入或者被供给的类型，每个方法也可以有一个限定符注解，以下都是有效的供给方法：\nSomeType getSomeType();\rSet\u0026lt;SomeType\u0026gt; getSomeTypes();\r@PortNumber int getPortNumber();\r供给方法和注入点一样可以使用Provider或Lazy更加显示地控制供给请求，Provider允许组件用户通过调用Provider.get()来请求任意次的供给，Lazy自始至终只会请求单个供给，但会将其推迟到对Lazy.get()的首次调用。以下供给方法都请求对同一类型的供给，但分别应用了不同的机制：\nSomeType getSomeType();\rProvider\u0026lt;SomeType\u0026gt; getSomeTypeProvider();\rLazy\u0026lt;SomeType\u0026gt; getLazySomeType();\r成员注入方法（Members-injection methods） 成员注入方法具有单个参数，并将依赖注入到传入实例的每个使用Inject注解的域和方法，一个成员注入方法可以是void的，也可以返回其单个参数以便链接。以下都是合法的成员注入方法声明：\nvoid injectSomeType(SomeType someType);\rSomeType injectAndReturnSomeType(SomeType someType)\r一个没有参数但返回MembersInjector的方法和成员注入方法是等效的，在返回对象上调用MembersInjector.injectMembers(T)方法和成员注入方法的作用一样：\nMembersInjector\u0026lt;SomeType\u0026gt; getSomeTypeMembersInjector();\r关于协方差的注意事项 尽管一个类型的成员注入方法会可以接收其子类的实例（参数是返回类型的子类），只有参数类型和其超类的Inject注解成员会被注入，而参数类型的子类则不会，例如，如下类型中，当将Child实例作为参数传入成员注入方法injectSelf(Self instance)时只有a和b会被注入，\nclass Parent {\r@Inject A a;\r}\rclass Self extends Parent {\r@Inject B b;\r}\rclass Child extends Self {\r@Inject C c;\r}\r实例化 组件（Component）的实例化主要通过生成的builder。一个builder实例通过组件上的builder()方法获取，返回的builder有一个方法用于设置每个modules() 和组件dependencies()，它们都以每个module或dependency类型的小写驼峰形式命名。每个缺少默认构造函数的组件dependency和module都必须显式地设置，但任何具有默认或无参构造函数（可以被组件实现访问）的module则可以忽略。如下所示：\npublic static void main(String[] args) {\rOtherComponent otherComponent = .","title":"Dagger2 Api"},{"summary":"http://www.cs.cmu.edu/~15122/handouts/05-sort.pdf","title":""},{"summary":"哈希表 许多应用只需要一个动态集合能够进行字典操作，即INSERT，SEARCH，DELETE。哈希表便是实现字典的高效数据结构。哈希表是对更简单的常规数组概念的推广。\n直接寻址表 当键的全集(universe)相当小时，直接寻址是一种行的通的简单技术。\n哈希表 当全集U非常大时，以直接寻址的方式存储便不切实际了。我们使用一个哈希函数将要存储的键值集合映射到一个大小为m的表中，m的大小一般比|U|小得多，其中每个键值对应表的一个槽。然而两个不同键值可能映射到同一个槽中，这种情况称为碰撞（collide）。链接是解决碰撞的一种最简单方法，即将落入同一个槽中的元素放入一个链表中。","title":""},{"summary":"","title":"Jetpack Compose这一篇就够了"},{"summary":"1. 两数之和 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。\n你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。\n你可以按任意顺序返回答案。\n示例 1：\n输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 示例 2：\n输入：nums = [3,2,4], target = 6 输出：[1,2] 示例 3：\n输入：nums = [3,3], target = 6 输出：[0,1] 提示：\n2 \u0026lt;= nums.length \u0026lt;= 104\n-109 \u0026lt;= nums[i] \u0026lt;= 109\n-109 \u0026lt;= target \u0026lt;= 109\n只会存在一个有效答案\n进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？","title":"leetcode 10题"},{"summary":" How to Write a Spelling Corrector ","title":"中文文章错误检查"}]