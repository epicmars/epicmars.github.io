<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" >
        <meta lang="zh">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title>用户名与密码认证系统设计 | 风格与布局</title>
<meta name="description" content="用户身份 用户名 这里的用户名是用于标识用户唯一身份的，不同于昵称之类的用户信息。显然，作为用户身份的代表，用户名必须是全局唯一的。一般而言使用">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" type="text/css" media="screen" href="/css/main.css" />
        <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.0/css/solid.css" integrity="sha384-TbilV5Lbhlwdyc4RuIV/JhD8NR+BfMrvz4BL5QFa2we1hQu6wvREr3v6XSRfCTRp" crossorigin="anonymous">
        <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.0/css/brands.css" integrity="sha384-7xAnn7Zm3QC1jFjVc1A6v/toepoG3JXboQYzbM0jrPzou9OFXm/fY6Z/XiIebl/k" crossorigin="anonymous">
        <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.0/css/fontawesome.css" integrity="sha384-ozJwkrqb90Oa3ZNb+yKFW2lToAWYdTiF1vt8JiH5ptTGHTGcN7qdoR1F95e0kYyG" crossorigin="anonymous">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet">
        
    <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet">
    <link rel="stylesheet" type="text/css" media="screen" href="/css/article.css" />

    </head>

    <body>
        <div class="site-wrapper">
                <header>
    <nav>
        <a class="home" href="https://www.androidpi.com/">首页</a>
    </nav>
    
</header>
                <div class="site-main">
                    
    <div class="main">
        <div class="article">
            <aside>
                    <nav id="TableOfContents">
  <ul>
    <li><a href="#用户身份">用户身份</a>
      <ul>
        <li><a href="#用户名">用户名</a></li>
        <li><a href="#密码">密码</a></li>
        <li><a href="#生物id">生物ID</a></li>
      </ul>
    </li>
    <li><a href="#用户名与密码安全性">用户名与密码安全性</a>
      <ul>
        <li><a href="#明文用户名">明文用户名</a></li>
        <li><a href="#密码hash">密码Hash</a></li>
        <li><a href="#认证提示">认证提示</a></li>
      </ul>
    </li>
    <li><a href="#提升认证安全性">提升认证安全性</a>
      <ul>
        <li><a href="#双重验证two-factor-verfication">双重验证（Two Factor Verfication）</a></li>
      </ul>
    </li>
  </ul>
</nav>
            </aside>
            <article>
                <div class="title">
                    <h1 id="title">用户名与密码认证系统设计</h1>
                </div>
                <div class="content">
                        <h2 id="用户身份">用户身份</h2>
<h3 id="用户名">用户名</h3>
<p>这里的用户名是用于标识用户唯一身份的，不同于昵称之类的用户信息。显然，作为用户身份的代表，用户名必须是全局唯一的。一般而言使用英文、数字以及限定类型特殊符号所组成的字符串就可以了，一般也必须绑定邮箱或者手机，已用于密码修改与找回。移动互联网时代一般使用手机号作为用户名。</p>
<blockquote>
<p>题外话，有一次与朋友讨论换手机号的事，大家都会有这样的经历，由于看房或买房时留下了自己的联系方式，因为大家都懂的原因，后续每周隔三差五地会接到中介或装修公司的电话，烦不胜烦，所以有些人学精了，一般不会留下自己平时常用的号码。但是我当时没经验，现在算是长知识了，考虑再入一个号，现在的号作为小号。但现在的号绑定了太多手机App账号等等，可能不会立马就换过去。</p>
<p>由于换手机号的事，我想到另外一件事，如今微信的发展已经有7个年头，当初在移动互联网最火爆的那段时间，有些人感慨，要不是微信做成功了，可能腾讯社交领域老大的地位就要拱手让给竞争对手了。一个大的公司内部不同部门之间也必然存在竞争关系，传言腾讯也是认识到移动互联网的重要性，通过革自己曾经的命脉QQ的命来拿下微信这一张船票，当初也是从QQ引流了大量用户。想想，大家现在用QQ还多么，可能有些人说必须的啊，但我有朋友说他现在都不用QQ了，手机里就没装QQ。</p>
<p>那这个微信和QQ的发展和这个换手机号的事有什么关系？现在移动互联网时代了，大家注册微信账号都必须绑定手机账号了，但就像我上面说的，由于某些原因，手机号可能会经常换，可能有些人会说，你换了重新绑定下不就好了，好像是那么回事。但你的QQ号会经常换么？好多人用的QQ号可能都是用了十几年的吧。但可能这些都是我的主观判断，并没有数据来支撑。</p>
<p>我想说的是，关于用户名这一点，当初QQ采用数字号码的方式可能要优于如今采用手机号作为用户名的方式，因为手机号更换的可能性比QQ号码要大，这一点可能不同人有不同的看法，也可能是受限于时代吧，QQ发展的那会连互联网和手机都还没普及。</p>
</blockquote>
<blockquote>
<p>谈到这里，我又想到一个问题，使用纯数字的账号名是一种安全性较低的做法，早年经常听说到QQ号被盗的事，现在似乎很少听说微信号被盗，可能是现在互联网技术更成熟了，也可能使用手机号绑定的方式进行身份认证的安全性更高。有一点可以确定的是，纯数字的账号名可以方便攻击者枚举用户的账号名，从而有利于对有保密缺陷的账号实施攻击。</p>
<p>那换用户名又有什么问题，换就换呗？可能有是一个较为主观的判断，但至少我是有那么一次经历，在微信才推出的那年我是注册过一个账号的，并且与QQ账号是进行了绑定的，在我更换手机号后，之前的手机号直接注销了，但由于微信的安全验证机制不断升级，当我再次使用QQ账号登录这个账号时，它提示我必须用之前绑定的手机进行短信认证，但怎么可能呢？于是现在再也没用过之前的账号了，这也是我认为QQ账号名更好的原因吧，我认为经常更换账号可能导致用户社交链的断裂。</p>
</blockquote>
<h3 id="密码">密码</h3>
<p>密码关系到账户安全性，一般限定在6位以上，较为安全的密码会限定用户使用英文、字母、特殊字符相结合的字符串。和用户名中可以使用的特殊字符相比，密码中可以使用的特殊字符的范围更广泛。</p>
<h3 id="生物id">生物ID</h3>
<p>如指纹等，它可以完全确定用户身份，等效于用户名与密码的结合。</p>
<h2 id="用户名与密码安全性">用户名与密码安全性</h2>
<p>之所以用户名中一般只允许使用特定的特殊字符，而密码中可以使用所有特殊字符，是因为用户名一般以明文的形式进行处理，而密码则一般通过加密Hash后再进行处理。</p>
<h3 id="明文用户名">明文用户名</h3>
<p>关于用户名只能使用限定特殊字符（如只能使用下划线“_”）的安全性等问题，适用以明文形式直接处理用户输入的情况。其目的主要出于如下几方面的<a href="http://www.cnblogs.com/xzwblog/p/6959500.html">讨论</a>：</p>
<ul>
<li>防止SQL注入，如等号<code>=</code>，单引号<code>'</code>等，这些会干扰查询或者报错，甚至引来恶意注入攻击。</li>
<li>展示异常问题，如果用户名中包含HTML的标签，可能会导致Web页面展示错误，或者如果用户名为<code>&lt;strong&gt;username&lt;/strong&gt;</code>，那么会展示加粗的用户名，这样就不平等。</li>
<li>输入不便的问题，特殊字符可能不利于内容的展示，比如<code>☆</code>，可能其他用户无法打出来，导致操作的不便。</li>
</ul>
<p>对于SQL注入攻击的防范，可以采取以下方式：</p>
<ol>
<li>严格限制客户端请求服务器时的数据库操作权限，仅提供满足其工作的最低权限，从而最大限度地减少注入攻击对数据库的危害。例如，禁止Delete操作，仅能通过Update操作将数据的一个字段设置为<code>deleted</code>，标识该条目被删除了。</li>
<li>检查输入的数据是否具有所期望的数据格式，严格限制变量的类型，例如使用正则表达式进行匹配验证。</li>
<li>对输入的特殊字符进行转义处理或编码转换。</li>
<li>所有的查询语句建议使用数据库提供的参数化查询接口，参数化的接口内部也会对参数进行转义处理，而不是将用户输入参数直接拼接到SQL语句中。</li>
<li>避免打印SQL错误信息，比如类型错误、字段不匹配等，这会将代码中的SQL语句暴露出来，而攻击者可以利用这些错误信息进行SQL注入。</li>
</ol>
<h3 id="密码hash">密码Hash</h3>
<p>用户保护密码的哈希函数和一般的用于数据结构中构建hash表的哈希函数不一样，hash表采用的哈希函数是为了进行快速的计算与查询，并不考虑安全性。只有**加密哈希函数(ryptographic hash functions)**应当用于实现密码哈希，例如SHA256，SHA512，RipeMD，WHIRLPOOL等。</p>
<p>仅仅采用加密hash函数对密码进行hash是远远不够的，有许多方式可以快速地从朴素的hash字符串恢复出密码，有若干种易于实现的技术可以降低这种攻击的效率。</p>
<h4 id="加密hash的破解方法">加密Hash的破解方法</h4>
<ul>
<li><strong>字典攻击和暴力破解(Dictionary and Brute Force Attacks)</strong>
这是最简单粗暴的破解方式，也就是采用猜密码的方法，对每个猜测的密码进行hash，然后检查该hash是否与被破解的密码hash相等，如果相等，那么破解成功，两种最常用的猜密码方式是**字典攻击(dictionary attacks)**和__暴力破解(dictionary attacks)__。
<ul>
<li>字典攻击：使用一个包含单词、短语、常用密码以及其它可能用作密码的字符串的文件。文件中的每个单词经过hash后于密码hash比较，如果相等那么该单词就是密码。</li>
<li>暴力破解：顾名思义，密码被限定为有限字符的任意组合，那么完全可以枚举出所有可能的字符组合，将其hash后于密码hash进行比较。但这种攻击需要消耗大量算力，并且在每CPU时间的hash破解上常常是最低效的。</li>
</ul>
</li>
<li><strong>查表法(Lookup Tables)</strong>
查表发在破解大量相同类型hash上及其高效。其大体思路是预先计算并存储密码字典中的hash和对应的密码。</li>
<li><strong>逆向查表法(Reverse Lookup Tables)</strong>
这种攻击允许一个攻击者对大量hash同时使用一个字典攻击或暴力破解，这并不需要预先计算一个查找表。首先，攻击者根据被盗用户账号数据库创建一个查找表将每个密码hash映射到一个拥有改hash的用户列表。然后攻击者对猜测的密码进行hash并使用该查找表获取与猜测匹配的用户。这种攻击方式非常有效，因为很多用户的密码常常是相同的。</li>
<li><strong>彩虹表（Rainbow Tables）</strong>
彩虹表是一种时间-内存折中的技术，除了他通过牺牲hash破解速度使得查找表更小，它们和查找表类似。因为它们较小，在同一个存储空间中可以存储更多的hash，使得它们更加有效。彩虹表可以破解一个任意一个8字符长度内密码的md5哈希。</li>
</ul>
<h4 id="加盐">加盐</h4>
<p>查表法和彩虹表只有在每个密码已相同的方式进行hash时才有效。如果用户有相同的密码，那么它们的密码hash也一样。通过对每个hash进行随机化可以避免这些攻击，因此同一个密码进行两次hash的结果会不一样。</p>
<p>在进行hash前，通过在密码后加入一个随机字符串，可以将hash随机化，称这个随机字符串为<strong>盐</strong>。为了检查密码是否正确，需要将盐值和hash一起存储，或者将其附加为hash的一部分。</p>
<h4 id="密码hash的正确方式">密码Hash的正确方式</h4>
<ul>
<li>
<p>基本方式：加盐hash
盐值应当使用一个密码学上安全的伪随机数生成器（Cryptographically Secure Pseudo-Random Number Generator）。每个用户每个密码的盐值都应当是唯一的，每次用户新建账号或者改变密码，都应当使用一个新的随机盐值。永远不要重复使用一个盐值。盐值应当较长，因此才会有足够多的值可用。根据经验，盐值至少应当和hash函数的输出一样长。盐值应当和密码hash一起存在用户账号表中。</p>
</li>
<li>
<p>加大密码破解的难度：慢速hash函数
加盐可以保证攻击者不能使用类似查表法和彩虹表这样的方法来快速破解大量的hash，但不能阻止他们使用字典或暴力破解方式对每个单独的hash进行破解。高端的显卡(GPU)和定制的硬件可以每秒计算数十亿个hash，如今比特币流行，矿机的ASCI芯片就是专门用于计算Hash的硬件设备。因此，这些供给仍然十分有效，为了使这种攻击不那么有效，我们可以使用一种称为**键延伸(key stretching)**的技术。</p>
<p>其思想是使hash函数变得非常慢，使得即使利用GPU或者定制的硬件时，字典和暴力攻击都十分慢，这样就提升了破解的成本。这种做法的目的是使得hash函数慢到足以阻碍攻击，但也仍然足够快使得用户不会注意到有延迟存在。</p>
</li>
<li>
<p>无法攻破的hash：使用秘钥hash和密码哈希硬件
只要攻击者可以使用一个hash来检查一个猜测的密码是否是正确的，他们都可以在hash上进行字典或暴力破解。下一步是使用一个秘钥进行hash，只有知道秘钥的人才可以使用hash来验证密码的正确性。可以使用两种方式进行实现，要么使用一种类似AES的加密方式对hash进行加密，或者可以使用一种类似HMAC这样的秘钥hash算法将秘钥包含在hash中。</p>
<p>这并不像听起来这么简单。秘钥必须对攻击者保密。秘钥可以保存在一个外部系统中，例如一个与服务器物理上分离的专用于密码验证的服务器，或者一个类似<a href="https://www.yubico.com/YubiHSM">YubiHSM</a>的附加到服务器的特殊硬件设备。</p>
</li>
</ul>
<h3 id="认证提示">认证提示</h3>
<p>如果用户在登录认证过程中输入了错误的用户名或密码，永远不要给出明确的“用户名输入错误”或者“密码错误”这样的提示，总是展示一个通用的消息，例如“无效的用户名或密码”。这样可以避免攻击者在不知道密码的情况下去枚举有效的用户名。</p>
<h2 id="提升认证安全性">提升认证安全性</h2>
<h3 id="双重验证two-factor-verfication">双重验证（Two Factor Verfication）</h3>
<p><a href="http://www.cnblogs.com/xzwblog/p/6959500.html">为什么用户名不能特殊字符</a>
<a href="https://crackstation.net/hashing-security.htm">Salted Password Hashing - Doing it Right</a>
<a href="http://blog.jobbole.com/61872/">加盐密码哈希：如何正确使用</a></p>

                </div>
                
            </article>
        </div>
    </div>

                </div>
                <footer>
    Powered by <a target="_blank" href="https://gohugo.io/">Hugo</a> And 
    <a target="_blank" href="https://pages.github.com/">Github Pages</a>
</footer>
                <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
                

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.3.5/jquery.fancybox.min.css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.3.5/jquery.fancybox.min.js"></script>

                <link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.12.0/styles/default.min.css">
                <script src="/js/highlight.pack.js"></script>
                <script src="https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js"></script>
                <script type="text/javascript" async src="https://cdn.bootcss.com/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [
                ['$', '$'],
                ['\\(', '\\)']
            ],
            displayMath: [
                ['$$', '$$']
            ],
            processEscapes: true,
            processEnvironments: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            TeX: {
                equationNumbers: {
                    autoNumber: "AMS"
                },
                extensions: ["AMSmath.js", "AMSsymbols.js"]
            }
        }
    });
    MathJax.Hub.Queue(function () {



        var all = MathJax.Hub.getAllJax(),
            i;
        for (i = 0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });

    MathJax.Hub.Config({

        TeX: {
            equationNumbers: {
                autoNumber: "AMS"
            }
        }
    });
</script>
                <script type="text/javascript" src="/js/main.js"></script>
        </div>
    </body>

</html>