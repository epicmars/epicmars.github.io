<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" >
        <meta lang="zh">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title>比特币：一个点对点电子货币系统[翻译] | 风格与布局</title>
<meta name="description" content="原文 摘要 一个纯粹的点对点电子现金可以允许参与方之间直接进行在线支付，而无需经过一个第三方金融机构。数字签名可以提供部分解决方案，但如果仍然需">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" type="text/css" media="screen" href="/css/main.css" />
        <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.0/css/solid.css" integrity="sha384-TbilV5Lbhlwdyc4RuIV/JhD8NR+BfMrvz4BL5QFa2we1hQu6wvREr3v6XSRfCTRp" crossorigin="anonymous">
        <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.0/css/brands.css" integrity="sha384-7xAnn7Zm3QC1jFjVc1A6v/toepoG3JXboQYzbM0jrPzou9OFXm/fY6Z/XiIebl/k" crossorigin="anonymous">
        <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.0/css/fontawesome.css" integrity="sha384-ozJwkrqb90Oa3ZNb+yKFW2lToAWYdTiF1vt8JiH5ptTGHTGcN7qdoR1F95e0kYyG" crossorigin="anonymous">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet">
        
    <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet">
    <link rel="stylesheet" type="text/css" media="screen" href="/css/article.css" />

    </head>

    <body>
        <div class="site-wrapper">
                <header>
    <nav>
        <a class="home" href="https://www.androidpi.com/">首页</a>
    </nav>
    
</header>
                <div class="site-main">
                    
    <div class="main">
        <div class="article">
            <aside>
                    <nav id="TableOfContents">
  <ul>
    <li><a href="#摘要">摘要</a></li>
    <li><a href="#1-导引">1. 导引</a></li>
    <li><a href="#2-交易">2. 交易</a></li>
    <li><a href="#3-时间戳服务器">3. 时间戳服务器</a></li>
    <li><a href="#4-工作证明">4. 工作证明</a></li>
    <li><a href="#5-网络">5. 网络</a></li>
    <li><a href="#6-激励">6. 激励</a></li>
    <li><a href="#7-回收磁盘空间">7. 回收磁盘空间</a></li>
    <li><a href="#8-简化支付验证">8. 简化支付验证</a></li>
    <li><a href="#9-合并与拆分值">9. 合并与拆分值</a></li>
    <li><a href="#10-隐私">10. 隐私</a></li>
    <li><a href="#11-计算">11. 计算</a></li>
    <li><a href="#12-总结">12. 总结</a></li>
  </ul>
</nav>
            </aside>
            <article>
                <div class="title">
                    <h1 id="title">比特币：一个点对点电子货币系统[翻译]</h1>
                </div>
                <div class="content">
                        <p><a href="https://bitcoincore.org/bitcoin.pdf">原文</a></p>
<h2 id="摘要">摘要</h2>
<p>一个纯粹的点对点电子现金可以允许参与方之间直接进行在线支付，而无需经过一个第三方金融机构。数字签名可以提供部分解决方案，但如果仍然需要一个可信任的第三方参与者来避免双重支付，那么就丧失了点对点交易这一主要优点。我们提出了一个使用P2P网络解决双重支付的问题。该网络通过将交易散列(哈希)到一个不间断的基于散列的工作证明链中，这样就为交易打上了一个时间戳，形成一个无法被更改的记录，除非重新进行工作证明。最长的链不仅仅服务于作为被见证事件序列的证明，也可以证明序列来自于最大的CPU算力池。只要大多数CPU算力被非攻击方的结点所控制，他们就可以生成最长的链并且超越攻击者。网络本身只需要最小化的结构。消息基于尽力传输模型进行广播，结点可以任意离开或者加入到网络中，并接收最长的工作证明链作为结点离开期间所发生事件的证明。</p>
<h2 id="1-导引">1. 导引</h2>
<p>互联网上的贸易基本上主要依赖于金融机构作为可信任的第三方来处理电子支付。尽管对于大多数交易该系统工作的不错，它仍然有着基于信任模型所与生俱来的弱点。即完全不可逆的交易不太可能达成，因为金融机构不能避免中介纠纷。中介的代价提升了交易代价，限制了最小实际交易大小并阻断了小额的随机交易，并且在缺失为不可逆服务提供不可逆支付的能力下有着更广泛的代价。有了可逆的可能，那么信任的需要就会扩散。商家必须谨慎对待其消费者，麻烦消费者提供更多他们实际可能本不需要的信息，一定比例的诈骗还是不可避免地会被接受。这些代价和支付的不确定性可以通过现金支付来避免，但没有机制可以在缺少第三方信任机构的情况下通过通信渠道进行支付。</p>
<p>因此所需要的是一个基于加密证明而非信任的电子支付系统，允许任意两方直接进行交易而不需要可信任的第三方。交易被逆转在计算上是不切实际的，这可以保护卖方免受诈骗，也可以很容易地实现一个常规的第三方委托机构来保护买方。在本文中，我们提出了一个使用点对点分布式时间戳服务器来为交易的年代时间排序生成一个计算证明，以解决双重支付的问题。只要诚信的结点集合控制了比攻击者结点集合更多的CPU算力那么该系统就是安全的。</p>
<!-- raw HTML omitted -->
<h2 id="2-交易">2. 交易</h2>
<p>我们将电子硬币定义为一个数字签名链。硬币的每个所有者通过对前一个交易和下一个所有者的公钥的哈希进行数字签名并且将其加入到硬币的尾部，这样就可以将硬币从当前所有者传给下一个所有者。一个收款人可以通过验证签名来验证链的所有权。</p>
<p><img src="/assets/images/bitcoin/bitcoin-transaction.png" alt="bitcoin transaction"></p>
<p>这一过程中的问题在于收款人不能验证其中一个所有者没有双重支付。一个通常的解决方案是引入一个可信赖的中央权威机构，或者造币厂，来检查每笔交易是否双重支付。在每笔交易中，硬币必须返还到造币厂来发行一个新的硬币，并且只有直接从造币厂发行的硬币才可以认为没有双重支付。这种解决方案的问题在于整个货币系统取决于运行造币厂的公司，每笔交易必须经过它，就像一个银行一样。</p>
<p>我们需要一种方式使得收款人知道前一个所有者没有对更早的交易进行签名。为了达到这个目的，最早的一笔交易才算数，因此我们不用关心后面可能进行的双重支付。确认一个交易缺失的唯一方式就是知晓所有的交易。在造币厂模型中，造币厂就知晓所有的交易并且可以判断谁第一个到达。在没有一个可信赖机构的情况下要完成这一点，交易必须是公开声明的，并且我们需要一个系统让参与者达成一个共识，即交易被接收的顺序具有一个单一历史记录。收款人需要证明，在每个交易中，大多数结点认为它是第一个被接收到的。</p>
<h2 id="3-时间戳服务器">3. 时间戳服务器</h2>
<p>我们提出的方案以一个时间戳服务器开始。一个时间戳服务这样运行，通过获取一个需要打上时间戳的包含多个条目的块的hash，并且将该hash广泛地传播出去，就像新闻报纸或者Usenet邮报中那样。显然，为了进入hash块中，时间戳证明数据在那个时刻必然是存在的。每个时间戳在其hash中包含前一个时间戳，形成一个链，这样每个额外的时间戳就强化了它前面的时间戳。</p>
<p><img src="/assets/images/bitcoin/timestamp-server.png" alt="timestamp server"></p>
<h2 id="4-工作证明">4. 工作证明</h2>
<p>为了基于P2P实现一个分布式时间戳服务器，我们需要一个类似于Adam Back的Hashcash那样的工作证明系统，而非新闻报纸或Usenet邮报。工作证明涉及扫描出一个被hash的值，例如使用SHA-256，该hash以一些0比特开始。所需要的平均工作量是0比特数量的指数级大小，并且可以通过执行单个hash对该工作进行验证。</p>
<p>对于我们的时间戳服务器，我们采用这样的方式来实现工作证明，即增长区块中的随机数直到找到一个值，它给出了区块hash所需要的0比特。一旦CPU所做的工作被花费在满足工作证明上面，如果不重新进行这一工作那么区块就不能被更改。由于后续的区块是链接在其后的，如果要改变一个区块就要重新进行包括该区块后的所有区块的工作证明。</p>
<p><img src="/assets/images/bitcoin/proof-of-work.png" alt="proof of work"></p>
<p>工作证明也解决了在多数决策中的代表的判定。如果多数方的判定是基于一IP地址一投票权，那么它易于受到可以分配很多IP的人的破坏。工作证明本质上是一CPU一投票权的。多数决策是由最长的链所代表的，它拥有所投入的最大的工作证明量。如果大多数CPU算力被诚信的结点所控制，那么诚信的链增长最快并且会超越任何与之竞争的链。为了修改一个过去的区块，一个攻击者必须重新对该区块和其后的所有区块进行工作证明，并且追赶上诚信的结点。待会我们会展示在当一个后续区块被添加后，一个较慢的攻击者追赶上诚信结点的概率会成指数级降低。</p>
<p>为了弥补逐渐增长的硬件速度和随着时间对运行结点的利益的变化，工作证明的难度将会随之变化，它由所设定的平均每小时产生若干区块所决定。如果区块生成的太快，那么难度系数就会提高。</p>
<h2 id="5-网络">5. 网络</h2>
<p>运行网络的步骤如下：</p>
<ol>
<li>新的交易被广播到所有结点</li>
<li>每个结点收集新的交易到一个区块</li>
<li>每个结点进行工作，为其区块寻找一个难度工作证明</li>
<li>当一个结点找到了一个工作证明，就将区块广播到所有结点</li>
<li>只有当区块中的所有交易都是有效的并且还未存在，那么结点接受该区块</li>
<li>结点通过使用接受的区块作为前一个区块开始进行创建下一个区块的工作，表明该区块被接受了</li>
</ol>
<p>结点总是认为最长的链是正确的，并且会为了延长它而工作。如果两个结点同时广播了下个区块的不同版本，一些结点会先接收到其中一个，而另一些结点会先接收到另一个。这种情况下，它们会在先接收到的区块上进行工作，但会保存另一个分支，以防另一个分支变得更长。当下一个工作证明被发现并且一个分支变的更长那么链接就会断开，在另一个分支进行工作的结点就会切换到更长的链上。</p>
<p>新的交易广播没有必要到达所有结点。只要他们能达到一些结点，他们就在不久后进入一个区块。区块广播对消息丢失也是容许的。如果一个结点没有接收到一个区块，那么在接收到下一个区块时发现缺少了一个区块，它便会进行请求。</p>
<h2 id="6-激励">6. 激励</h2>
<p>通常而言，一个区块中的第一笔交易是特殊的，它激活了一个新的虚拟硬币，该硬币由区块创建者所有。这为支持网络的结点添加了一种激励，并且提供了将硬币首次分发到流通环节中的一种方式，因为没有中央权威机构来发布它们。一定数量的新硬币的稳定增长类似于金矿采集者花费资源将黄金添加到流通环节中。对于我们的情形，那就是所使用的CPU时间和电力。</p>
<p>激励也可以从交易费中获得。如果一个交易的输出值比输入值小，那么这两者的差就是一笔交易费，它被添加到交易所在区块的激励值中。一旦预定数量的硬币进入流通中，激励就可以完全转换为交易费并且可以完全免受通货膨胀。</p>
<p>激励可以帮助鼓励结点保持诚信，如果一个贪婪的攻击者有能力组织多于诚信结点的算力，他必须在两者间进行选择，要么使用它偷回他的交易付款来进行诈骗，或者使用它生成新的硬币。相比于破坏系统以及其财富的有效性，他应该会发现按游戏规则进行更有利可图，这些规则会帮助他获得更多新的硬币，比其它所有人加起来都多。</p>
<h2 id="7-回收磁盘空间">7. 回收磁盘空间</h2>
<p>一旦一个硬币中的最后一笔交易被记录到足够多的区块中，为了节省磁盘空间可以将之前的交易忽略。为了利用这一点，同时不破坏区块的hash，交易都被hash到一个Merkle树中，只有树根被保留在区块的hash中。那么老的区块就可以通过将树枝去掉从而进行压缩。内部的hash没有必要进行存储。</p>
<p><img src="/assets/images/bitcoin/merkle-tree.png" alt="merkle tree"></p>
<p>一个没有交易的的区块头大约是80字节。如果我们假设区块以每10分钟一个的速度生成，那么就是$$80bytes \times 6 \times 24 \times 365 = 4.2MB$$每年。在2008年市面上计算机系统的内存一般为2GB大小，根据摩尔定律估计其每年增长1.2GB，那么即使区块头必须保存在内存中也不是问题。</p>
<h2 id="8-简化支付验证">8. 简化支付验证</h2>
<p>在不运行一个完全的网络结点情况下对支付进行验证是可行的。一个用户只需要保留最长POW链的区块头的一份副本就可以了，他可以通过查询网络结点直到他确信获取到了最长的链，并且获取到Merkle树枝，这个树枝将交易链接到它被打上时间戳的区块。他不能为自己检查交易，但通过将它链接到链中的一个位置，他可以看到网络结点已经接受了它，并且在它进一步确认网络已经接受它后区块被添加到链中。</p>
<p><img src="/assets/images/bitcoin/simplified-payment-verification.png" alt="simplified payment verification"></p>
<p>同样地，只要诚信的结点控制了网络，那么验证就是可靠的，但如果网络被一个攻击者掌控就更危险。尽管网络结点可以自行验证交易，只要攻击者可以继续控制网络，简化的方式就会被欺骗。一种防御策略就是在网络结点检测到一个无效区块后从中接受警报，提醒用户软件去下载完整的区块并修改交易来确认这中不一致。频繁支付的商业可能仍然想运行自己的结点来保证更独立的安全性和更快的验证。</p>
<h2 id="9-合并与拆分值">9. 合并与拆分值</h2>
<p>尽管可能独立地处理硬币，但在一个传输过程中为每分都进行分开交易是不实用的。为了允许值被划分和结合，交易包含多个输入和输出。通常要么有一个从之前的一大笔交易而来的单一输入，要么是将多个更小数量结合起来的多个输入，并且最多有两个输出：一个是支付，另一个如果有的话，就是找回给发送者的零钱。</p>
<p><img src="/assets/images/bitcoin/combining-and-splitting-value.png" alt="combining and splitting value"></p>
<p>应该注意到这一扇出，其中一笔交易依赖于多笔交易，这多笔交易又依赖于更多的交易，这并不是一个问题。没有必要去提取一笔交易的完整独立的历史复本。</p>
<h2 id="10-隐私">10. 隐私</h2>
<p>传统的银行模型通过限制交易参与方和可信赖第三方对信息的访问，达到一定程度的隐私保护。将所有交易公开广播出去的必要性没有这样做，但通过在另外的地方阻断信息的流通仍然可以保护隐私：即匿名保存公钥。公众可以看到一个人发送了一定数量的比特币给另一个人，但不知道发送的人是谁。这类似于股市交易中的信息发布，单个交易大小和时间是公开的，但不会公开交易者是谁。</p>
<p><img src="/assets/images/bitcoin/privacy.png" alt="privacy"></p>
<p>作为一个额外的防火墙，每笔交易应当使用一个新的秘钥对，以防止它们被链接到同一个所有者。对于多输入的交易有些链接仍然是不可避免的，它必然暴露了它们的输入属于同一个所有者。其风险在于如果一个秘钥的所有者被暴露了，那么链接会将属于该所有者的其它交易也暴露出来。</p>
<h2 id="11-计算">11. 计算</h2>
<p>考虑这样的情形，相较于诚信的结点，一个攻击者试图更快地生成一个候选链。即使他做到了这件事，并不会使得系统向随意的改变开放，例如凭空创建硬币或者窃取从不属于攻击者的钱。结点并不会接受一个无效的交易来进行支付，并且诚信的结点永远不会接受包含这种交易的区块。一个攻击者只能尝试改变他自己的交易来将他最近花费的钱拿回来。</p>
<p>诚信的链和一个攻击者的链之间的竞赛的特征可以表示为一个二项式随机游走。成功的事件就是诚信的链由一个区块进行了延长，使其领先位置+1，失败的事件就是攻击者链由一个区块进行了延长，将差距-1。</p>
<p>给定一个逆差，一个攻击者追赶上的概率类似于一个赌徒破产问题，假设一个拥有无限筹码的赌徒从一个赤字开始，并可能进行无数次的尝试来视图导到盈亏平衡。我们可以计算他达到保本的概率，或者是一个攻击者追赶上诚信链的概率，如下所示：</p>
<p>$$
\begin{align}
p &amp;= 诚信结点寻找到下一个区块的概率 \\\<br>
q &amp;= 攻击者找到下一个区块的概率 \\\<br>
q_z &amp;= 攻击者在落后z个区块的情况下追赶上的概率 \\\<br>
q_z &amp;= \left\{\begin{array}{ll}1 &amp; \text{if $p \le q$} \\(q/p)^z &amp; \text{if $p \gt q$}\end{array}\right\}
\end{align}
$$</p>
<p>在给定的假设下，当$p &gt; q$时，如果攻击者需要追赶上的区块数增加，那么其追赶上的概率将会成指数下降。由于这一几率的限制，如果他没有在早期就大幅追赶，那么他越落后，其追赶上的希望将越来越渺茫。</p>
<p>对于一笔新的交易，我们现在考察接收者在发送者不能更改交易前需要等待多久。我们假设发送者是一个攻击者，在短时间内他想让接收者认为他已经支付了，但随后又将这笔支付款转给了他自己。如果这种情况发生了，接收者会接收到提醒，但发送者希望这已经太迟了。</p>
<p>在签名前，接收者生成了一个新的秘钥对，并且将公钥给予发送者。这防止了发送者通过持续工作预先准备好一个区块链直到他足够幸运地提前了足够多的区块，然后在那个时刻执行交易。一旦交易被送出，攻击者开始秘密地在一个并行的包含他自己版本的交易链上工作。</p>
<p>接收者等待知道交易被添加到一个区块并且z个区块已经被链接到它后面，他不知道攻击者的确切进展，但假设诚信的结点在每个区块上花费了平均期望时间，攻击者的潜在进程就是该期望值的泊松分布：</p>
<p>$$
\lambda = z \frac{q}{p}
$$</p>
<p>为了获取攻击者仍然可以追赶上的概率，我们将概率密度乘以他在那个点上以他能追赶上的概率而已经取得的进展：</p>
<p>$$
\sum_{k=0}^{\infty}\frac{\lambda^k e^{-\lambda}}{k!}\cdot
\left\{
\begin{array}
\\(q/p)^{(z-k)} &amp;\text{if $k \le z$} \\<br>
1 &amp;\text{if $k \gt z$}
\end{array}
\right\}
$$</p>
<p>重新组织表达式以避免分布中无限长的尾部&hellip;
$$
1 - \sum_{k=0}^{z}\frac{\lambda^k e^{-\lambda}}{k!}(1 - (q/p)^{(z-k)})
$$</p>
<p>转换为C代码就是&hellip;</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;math.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">double</span> <span style="color:#a6e22e">AttackerSuccessProbability</span>(<span style="color:#66d9ef">double</span> q, <span style="color:#66d9ef">int</span> z)
{
    <span style="color:#66d9ef">double</span> p <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.0</span> <span style="color:#f92672">-</span> q;
    <span style="color:#66d9ef">double</span> lambda <span style="color:#f92672">=</span> z <span style="color:#f92672">*</span> (q <span style="color:#f92672">/</span> p);
    <span style="color:#66d9ef">double</span> sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.0</span>;
    <span style="color:#66d9ef">int</span> i, k;
    <span style="color:#66d9ef">for</span> (k <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; k <span style="color:#f92672">&lt;=</span> z; k<span style="color:#f92672">++</span>)
    {
    <span style="color:#66d9ef">double</span> poisson <span style="color:#f92672">=</span> exp(<span style="color:#f92672">-</span>lambda);
    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> k; i<span style="color:#f92672">++</span>)
    poisson <span style="color:#f92672">*=</span> lambda <span style="color:#f92672">/</span> i;
    sum <span style="color:#f92672">-=</span> poisson <span style="color:#f92672">*</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> pow(q <span style="color:#f92672">/</span> p, z <span style="color:#f92672">-</span> k));
    }
    <span style="color:#66d9ef">return</span> sum;
}
</code></pre></div><p>运行一些结果可以看出概率以指数z下降：</p>
<pre><code>q=0.1
z=0 P=1.0000000
z=1 P=0.2045873
z=2 P=0.0509779
z=3 P=0.0131722
z=4 P=0.0034552
z=5 P=0.0009137
z=6 P=0.0002428
z=7 P=0.0000647
z=8 P=0.0000173
z=9 P=0.0000046
z=10 P=0.0000012

q=0.3
z=0 P=1.0000000
z=5 P=0.1773523
z=10 P=0.0416605
z=15 P=0.0101008
z=20 P=0.0024804
z=25 P=0.0006132
z=30 P=0.0001522
z=35 P=0.0000379
z=40 P=0.0000095
z=45 P=0.0000024
z=50 P=0.0000006
</code></pre>
<p>对于小于0.1%的P&hellip;</p>
<pre><code>P &lt; 0.001
q=0.10 z=5
q=0.15 z=8
q=0.20 z=11
q=0.25 z=15
q=0.30 z=24
q=0.35 z=41
q=0.40 z=89
q=0.45 z=340
</code></pre>
<h2 id="12-总结">12. 总结</h2>
<p>我们提出了一个无需依赖于信任的电子交易系统。从一个由电子签名生成硬币的常规框架开始，它提供了对所有权的强有力控制，但如果不能避免双重支付它就是不完整的。为了解决这一问题，我们提出了一个使用工作证明的点对点网络来记录交易的公共历史，如果诚信的结点控制了大多数CPU算力，它会迅速使得攻击者从计算上更改这一历史变得不现实。网络在其非结构化精简性上是健壮的。所有结点同时一起工作但几乎不进行合作。他们不需要被识别，因为消息并不是路由到某个特定的地方并且只需要尽力传输即可。结点可以任意离开和重新加入到网络中，接受POW链作为他们离开期间所发生事件的证明。他们以CPU算力进行投票，具体表现就是通过在有效的区块上工作来扩展它们以接受它们，并且通过拒绝在无效的区块上工作来对它们进行拒收。任何需要的规则和激励都可以通过这种共识机制来加以实施。</p>

                </div>
                
            </article>
        </div>
    </div>

                </div>
                <footer>
    Powered by <a target="_blank" href="https://gohugo.io/">Hugo</a> And 
    <a target="_blank" href="https://pages.github.com/">Github Pages</a>
</footer>
                <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
                

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.3.5/jquery.fancybox.min.css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.3.5/jquery.fancybox.min.js"></script>

                <link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.12.0/styles/default.min.css">
                <script src="/js/highlight.pack.js"></script>
                <script src="https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js"></script>
                <script type="text/javascript" async src="https://cdn.bootcss.com/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [
                ['$', '$'],
                ['\\(', '\\)']
            ],
            displayMath: [
                ['$$', '$$']
            ],
            processEscapes: true,
            processEnvironments: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            TeX: {
                equationNumbers: {
                    autoNumber: "AMS"
                },
                extensions: ["AMSmath.js", "AMSsymbols.js"]
            }
        }
    });
    MathJax.Hub.Queue(function () {



        var all = MathJax.Hub.getAllJax(),
            i;
        for (i = 0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });

    MathJax.Hub.Config({

        TeX: {
            equationNumbers: {
                autoNumber: "AMS"
            }
        }
    });
</script>
                <script type="text/javascript" src="/js/main.js"></script>
        </div>
    </body>

</html>