<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta lang="zh"/>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title>
            
    Java内存模型：Why，What，How &ndash; DevNote

        </title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" type="text/css" media="screen" href="/css/main.css" />
        
    <link rel="stylesheet" type="text/css" media="screen" href="/css/article.css" />

    </head>

    <body>
        <header>
    <a href="https://www.jastrelax.com/">DevNote</a>
</header>
        
    <div class="main">
        <div class="article">
            <article>
                <div class="title">
                    <h1 id="title">Java内存模型：Why，What，How</h1>
                </div>
                <div class="content">
                        

<p>在总结Java内存模型之前想先谈谈最近几年来关于学习方式的一点心得。对于一种知识的应用，如果不求甚解，最简单粗暴的是粘贴复制，甚至不需要知道如何使用，如果用的多了，拿来主义搞不定，可能还是需要知道如何使用，这一过程基本只涉及记忆的能力，这就是<strong>How</strong>。抛开单纯的记忆，如果想用的好和熟练，需要知道这种知识是什么以及可以解决什么问题，这里有一定程度的理解过程，但需要更大量的记忆，也就是<strong>What</strong>。但把这种知识本身也抛掉还剩什么，反问一个为什么是这样的，比如“为什么苹果掉了下来”，这时就有可能进入一个全新的领域，不再受限于知识本身，这便是<strong>Why</strong>了。</p>

<p>在软件开发工作中常常听说“Don&rsquo;t reinvent wheel”，对应于how，what，why就是怎么用一个wheel，wheel是什么，以及怎样造一个wheel。</p>

<p>也许对于初学者，这种自顶向下从how-what-why的方式学习曲线会更容易接受。但对于有了一定知识积累的人，很多时候包括我本人在内可能停留在What甚至是how的阶段，没有更进一步，没有去多问是什么以及为什么。但回到现实中，有些时候是需要有所折中的，这些过程都需要记忆的能力，况且不可能人人都去搞理论，或者去重新编写一个操作系统，也许从统计学意义上而言，大多数的问题可以在<strong>what</strong>阶段就被解决，并且解决的还不错，也就是够用了，但多问为什么总是一个好的开始。</p>

<p>所以这里会是一个Java进阶的学习过程，我将反过来采用自底向上的方式。</p>

<h2 id="why-为什么需要内存模型">Why：为什么需要内存模型?</h2>

<p>“更快，更高，更强”不仅仅是奥林匹克的口号，我们也需要更快，更稳定的计算机硬件和软件。谈到内存模型，到底在谈什么，对的就是在谈内存，但这里需要一个上下文，它就是运行中的使用内存的程序，也就是进程。在现代的计算机系统中，为了加快存储访问速度，有寄存器，高速缓存，主存，磁盘等存储层次结构。为了加快运行速度，计算的核心CPU采用了包括多核和指令乱序执行等等众多技术。系统层面上，由于CPU的性能增长已甩开主存等存储器访问性能几个量级，为了充分利用CPU的性能，系统提供了多任务执行能力，以进行逻辑流的调度，即同时运行多个进程，每个进程中又可以运行多个线程以及IO多路复用等并发机制。</p>

<p>对于进程并发，各个进程间也是共享CPU和主存，也存在不同进程访问同一位置存储器可能出现的问题，同时当创建了众多进程后将主存分配完，可能导致后来的进程没有可使用的内存，也就无法运行。系统为有效管理存储器并减少错误的发送，提供了对主存的抽象，即虚拟存储器。虚拟存储器的概念是通用的，因为Java程序运行在JVM中，但此时JVM本身也是系统创建的一个进程。一个进程有自己的虚拟地址空间和对应的物理地址空间，统称为进程的私有存储器，为了防止对存储器的随意篡改，系统不允许一个进程读写另一个进程的私有存储器，并且也不允许修改它与另一个进程间共享的虚拟页面，任何修改都会触发写时拷贝，除非这两个线程间达成一致的协议，允许修改发生，所以需要IPC机制，如共享内存，管道等。这里便引出了存储器管理或者内存模型需要解决的主要问题，即<strong>共享内存正确性问题（shared memory correctness）</strong>。</p>

<p>对于线程并发，及其内存模型的讨论，因为线程是应用层面的，没有进程中共享内存的访问限制，因此不能与进程的并发来进行类比讨论。虽然JVM本身属于一个较为完整的计算机系统，拥有自己的字节码指令集与执行系统，以及自己的运行时内存结构。但它一般也以进程的形式运行于外部操作系统中。在多线程并发环境下，线程所使用的存储仍然是外部硬件以及操作系统所提供的存储层次结构，线程拥有自己的私有内存以及线程间共享的内存。这正好与多核心CPU并行问题类似，各CPU拥有自己的寄存器以及高速缓存，并共享主存，有些多核CPU还拥有共享的高速缓存，但需要解决的问题是相似的。因此一旦CPU具有了这种正确执行并行程序的机制，即CPU所提供的内存模型，在应用层面上，多线程的执行便可以利用这种内存模型实现自己专属的内存模，例如JVM的内存模型，以编写正确的并发程序。</p>

<p>共享内存的正确性可以分为即内存一致性与缓存一致（相关）性（Memory Consistency and Cache Coherence），如果不作这种划分，可以将其统一概括为内存一致性问题，并发或并行逻辑流即可以从共享主存中访问数据，为了提高性能也常从私有缓存中访问数据，而缓存中的数据也是访问共享主存而来的，之所以做这种划分可以更有利于将复杂的内存一致性问题采用分治策略进行简化。</p>

<h3 id="内存一致性-memory-consistency">内存一致性（Memory Consistency）</h3>

<p>内存一致性或者内存模型定义了共享内存的正确性，它提供了加载和存储（内存读写）的规则以及这些规则如何与内存交互。例如两个CPU核心，一个写数据A到内存，另一个从内存读取数据A，如果两个同时发生，那么读到的结果是不确定的。如何保证另一个核心读取到的A是第一个核心写入的最新的值，这是一个时间上的问题。</p>

<blockquote>
<p>对于共享内存的访问，需要解决的问题是：
1. 什么行为是程序员所期望的
2. 系统实现者可以进行什么样的优化</p>

<p>内存一致性模型是一个具有共享内存的并发程序执行时所允许行为的规范，对于一个并发程序，执行时拥有特定的输入数据，它指定了动态加载时可能会返回什么值以及内存最终的状态是什么。与单线程不一样的是，常常会允许多种正确的行为发生。</p>
</blockquote>

<h3 id="缓存一致性-cache-coherence">缓存一致性（Cache Coherence）</h3>

<p>缓存一致性是支撑内存一致性的一部分，对于程序而言是不可见的或者说不需要，缓存一致性作为内存一致性的一部分，向外界隐藏了这种复杂性的考虑，向外提供一致的内存一致性规则供外部程序使用。缓存一致性一般由缓存一致性协议（cache coherence protocol）实现，一般考虑解决这样的问题，如果一个CPU核心访问了共享内存中的数据A，并将其保存在私有数据缓存中，如果另一个CPU核心更新了共享内存中的数据A，那么第一个CPU中的缓存的A便会过期。</p>

<p>缓存一致性便需要解决这种私有缓存与共享内存中数据的一致性问题，它是一个空间上的问题。只有保证了空间上内存的一致性，才能进一步保证上面内存模型中时间上的一致性问题。例如一个CPU核心（也可以是DMA，外设）更新了自己的缓存，当它再将缓存中的值写到共享内存，那么就回到上面的内存一致性问题了。</p>

<p>因此，若要明确定义缓存一致性，需要满足两个条件，一是在任意时刻对于任意给定的内存区域只有一个核心可以进行写操作（也可以读）或者多个核心可以进行读操作，因此不存在多个核心同时对一个内存区域进行读写的问题。除了这一条件，还需要对一个给定内存位置的值进行正确的传递，以使其它核心观察到最新的值，因此缓存的值总是最新的。</p>

<blockquote>
<p>需要保证两个缓存一致性不变量：
1. 单一写，多个读（Single-Write, Multiple-Read）不变量，在任意时间，对于任意给定内存位置，要么只有一个核心进行写数据A，要么就是多个线程读数据A。
2. 数据值（Data-Value）不变量。内存位置在一个时刻的值与上一个时刻读写结束后的值相同。</p>
</blockquote>

<p>这仅是定义缓存一致性的一种方式，还有其它定义方式。</p>

<h2 id="what-内存模型是什么">What：内存模型是什么?</h2>

<p>在<a href="2">JSR 133（Java内存模型常见问答）</a>，有一个较为详细的回答，是通过对多核处理器系统来的并行问题引入的。</p>

<blockquote>
<p>在多核系统中，处理器有一个或更多的内存缓存，可以通过加速数据访问（因为数据离处理器更近）和降低共享主存总线上的流量（因为许多内存操作可以被局部缓存满足）来提高性能。但多个处理器核心同时检查同一块内存区域时它们是否能看到相同的值？</p>

<p>在处理器层面，一个内存模型定义了必要和充分的条件来知晓其它处理器对内存的写入对当前处理器是可见的，以及当前处理器的写入对其它处理器是可见的。一些处理器表现出一个较强的内存模型，其中在任意时间对任意给定的内存所有处理器看到的值都是一样的。其它一些处理器表现一个较弱的内存模型，只有特殊的指令，称为内存屏障（memory barriers）要求冲洗掉（flush or invalidate）本地处理器缓存，以便看到其它处理器的写或者使该处理器的写对其它处理器可见。这些内存屏障通常采用锁与解锁的动作进行，在高级编程语言中是不可见的。</p>

<p>一个写操作对另一个线程可见的问题包括了编译器对代码的重排序。例如，编译器可能决定将一个写操作放到程序中更靠后的位置会更高效，只要这种重排序不改变程序的语义，编译器可以自由地这样做。如果编译器延后了一个操作，直到这一操作被执行之前，另一个线程都不会看到这一操作的效果，这也反应了缓存的效果。</p>

<p>此外一个写操作也可能被提前，其它线程可能看到写操作比它在代码中实际“发生”的要早。这些灵活性都是在内存模型的范畴内特意设计的，是为了使得编译器，运行时或者硬件可以以最优的次序执行操作，这样可以获得更高的性能表现。</p>

<p>例如一个简单的例子：</p>

<pre><code class="language-java">   Class Reordering {
       int x = 0, y = 0;
       public void writer() {
           x = 1;
           y = 2;
       }

       public void reader() {
           int r1 = y;
           int r2 = x;
       }
   }
</code></pre>

<p>假设这一代码在两个线程中并发执行，对y的读看到的值为2。因为这一写操作发生在对x的写之后，程序员可能会假设对x的读的值为1。然而，写操作可能重排序了，如果是这样的情况，那么线程1中对y的写发生了，随后线程2中读取了两个变量的值，然后线程1中对x的写发生了。那么线程2最终读取到r1的值为2，而r2的值为0。</p>

<p><strong>Java内存模型描述了多线程代码中什么行为是合法的，以及线程间如何通过内存进行交互。它描述了一个程序中的变量与一个真实的计算机系统中从内存或寄存器中存储或获取这些变量的底层细节间的关系，通过一种可以使用广泛的各式硬件以及广泛的各种编译优化来正确地实现的方式，它可以做到这一点。</strong></p>
</blockquote>

<p>在<a href="1">JLS</a>中对内存模型是这样定义：
&gt;给定一个程序以及改程序的一个执行轨迹，内存模型描述执行轨迹是否是改程序的合法执行。Java编程语言内存模型是这样工作的，检查一个执行轨迹中的每个读操作并且根据特定规则检查被该读操作观察到的写操作是有效的。</p>

<p>所以Java内存模型并不仅仅是描述多线程如何访问堆中的共享变量，它是与整个计算机存储体系相关的。</p>

<h2 id="how-如何使用内存模型">How：如何使用内存模型?</h2>

<p>如何使用便是关于如何编写正确的并发程序了，这一部分将会在后续关于Java多线程的文章中讲述。</p>

<p>[3]: 《深入理解计算机系统 第二版》Randal E.Bryant David R.O&rsquo;Hallaron 著 龚奕利 雷迎春 译
[4]: 《深入理解Java虚拟机 第二版》周志明著 p360-365</p>

                </div>
                
            </article>
            <aside>
                <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#why-为什么需要内存模型">Why：为什么需要内存模型?</a>
<ul>
<li><a href="#内存一致性-memory-consistency">内存一致性（Memory Consistency）</a></li>
<li><a href="#缓存一致性-cache-coherence">缓存一致性（Cache Coherence）</a></li>
</ul></li>
<li><a href="#what-内存模型是什么">What：内存模型是什么?</a></li>
<li><a href="#how-如何使用内存模型">How：如何使用内存模型?</a></li>
</ul></li>
</ul>
</nav>
            </aside>
        </div>
    </div>

        <footer>
    Powered by <a target="_blank" href="https://gohugo.io/">Hugo</a>
</footer>
        <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
        


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.3.5/jquery.fancybox.min.css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.3.5/jquery.fancybox.min.js"></script>

        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css">
        <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
        <script src="https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js"></script>
        <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML">
        </script>
        <script type="text/javascript" src="/js/main.js"></script>
    </body>

</html>