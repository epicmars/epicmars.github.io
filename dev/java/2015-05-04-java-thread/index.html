<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta lang="zh"/>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title>
            
    Java线程及其状态 &ndash; DevNote

        </title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" type="text/css" media="screen" href="/css/main.css" />
        
    <link rel="stylesheet" type="text/css" media="screen" href="/css/article.css" />

    </head>

    <body>
        <header>
    <a href="https://www.jastrelax.com/">DevNote</a>
</header>
        
    <div class="main">
        <div class="article">
            <article>
                <div class="title">
                    <h1 id="title">Java线程及其状态</h1>
                </div>
                <div class="content">
                        

<h2 id="线程状态">线程状态</h2>

<p>线程可以处于下列状态之一：</p>

<ul>
<li>NEW
至今尚未启动的线程处于这种状态。</li>
<li>RUNNABLE
正在 Java 虚拟机中执行的线程处于这种状态。</li>
<li>BLOCKED
受阻塞并等待某个监视器锁的线程处于这种状态。</li>
<li>WAITING
无限期地等待另一个线程来执行某一特定操作的线程处于这种状态。</li>
<li>TIMED_WAITING
等待另一个线程来执行取决于指定等待时间的操作的线程处于这种状态。</li>
<li>TERMINATED
已退出的线程处于这种状态。</li>
</ul>

<p>在给定时间点上，一个线程只能处于一种状态。这些状态是虚拟机状态，它们并没有反映所有操作系统线程状态。</p>

<h2 id="thread-sleep">Thread.sleep()</h2>

<p>如果当前线程为currentThread，调用currentThread.sleep(millis)会使当前线程休眠，进入TIMED_WAITING状态。该线程不丢失任何监视器的所属权。</p>

<h2 id="thread-join">Thread.join()</h2>

<p>如果当前线程为currentThread，另一个正在运行的线程为t，在currentThread所执行的代码中调用t.join()，会使当前线程暂停执行，进入WAITING状态，直到线程t终止。从源码中也可以看到，join()是一个同步方法，并且在一个守卫块调用wait()方法暂停了当前线程。</p>

<pre><code class="language-java">    public final void join(long millis) throws InterruptedException {
        synchronized(lock) {
        long base = System.currentTimeMillis();
        long now = 0;

        if (millis &lt; 0) {
            throw new IllegalArgumentException(&quot;timeout value is negative&quot;);
        }

        if (millis == 0) {
            while (isAlive()) {
                lock.wait(0);
            }
        } else {
            while (isAlive()) {
                long delay = millis - now;
                if (delay &lt;= 0) {
                    break;
                }
                lock.wait(delay);
                now = System.currentTimeMillis() - base;
            }
        }
        }
    }
</code></pre>

<h2 id="object-wait-与object-notify">object.wait()与object.notify()</h2>

<h3 id="object-wait">object.wait()</h3>

<p>在其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量前，导致当前线程等待。
当前线程必须拥有此对象监视器。</p>

<p>此方法导致当前线程（称之为 T）将其自身放置在对象的等待集中，然后放弃此对象上的所有同步要求。出于线程调度目的，在发生以下四种情况之一前，线程 T 被禁用，且处于休眠状态：</p>

<p>其他某个线程调用此对象的 notify 方法，并且线程 T 碰巧被任选为被唤醒的线程。
其他某个线程调用此对象的 notifyAll 方法。
其他某个线程中断线程 T。
大约已经到达指定的实际时间。但是，如果 timeout 为零，则不考虑实际时间，在获得通知前该线程将一直等待。
然后，从对象的等待集中删除线程 T，并重新进行线程调度。然后，该线程以常规方式与其他线程竞争，以获得在该对象上同步的权利；一旦获得对该对象的控制权，该对象上的所有其同步声明都将被恢复到以前的状态，这就是调用 wait 方法时的情况。然后，线程 T 从 wait 方法的调用中返回。所以，从 wait 方法返回时，该对象和线程 T 的同步状态与调用 wait 方法时的情况完全相同。
在没有被通知、中断或超时的情况下，线程还可以唤醒一个所谓的虚假唤醒 (spurious wakeup)。虽然这种情况在实践中很少发生，但是应用程序必须通过以下方式防止其发生，即对应该导致该线程被提醒的条件进行测试，如果不满足该条件，则继续等待。换句话说，等待应总是发生在循环中，如下面的示例：</p>

<pre><code class="language-java">synchronized (obj) {
while (&lt;condition does not hold&gt;)
obj.wait(timeout);
... // Perform action appropriate to condition
     }
</code></pre>

<p>（有关这一主题的更多信息，请参阅 Doug Lea 撰写的 Concurrent Programming in Java (Second Edition) (Addison-Wesley, 2000) 中的第 3.2.3 节或 Joshua Bloch 撰写的 Effective Java Programming Language Guide (Addison-Wesley, 2001) 中的第 50 项。
如果当前线程在等待之前或在等待时被任何线程中断，则会抛出 InterruptedException。在按上述形式恢复此对象的锁定状态时才会抛出此异常。</p>

<p>注意，由于 wait 方法将当前线程放入了对象的等待集中，所以它只能解除此对象的锁定；可以同步当前线程的任何其他对象在线程等待时仍处于锁定状态。</p>

<p>此方法只应由作为此对象监视器的所有者的线程来调用。有关线程能够成为监视器所有者的方法的描述，请参阅 notify 方法。</p>

<h3 id="object-notify">object.notify()</h3>

<p>唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生。线程通过调用其中一个 wait 方法，在对象的监视器上等待。
直到当前线程放弃此对象上的锁定，才能继续执行被唤醒的线程。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争；例如，唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势。</p>

<p>此方法只应由作为此对象监视器的所有者的线程来调用。通过以下三种方法之一，线程可以成为此对象监视器的所有者：</p>

<p>通过执行此对象的同步实例方法。
通过执行在此对象上进行同步的 synchronized 语句的正文。
对于 Class 类型的对象，可以通过执行该类的同步静态方法。
一次只能有一个线程拥有对象的监视器。</p>

                </div>
                
            </article>
            <aside>
                <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#线程状态">线程状态</a></li>
<li><a href="#thread-sleep">Thread.sleep()</a></li>
<li><a href="#thread-join">Thread.join()</a></li>
<li><a href="#object-wait-与object-notify">object.wait()与object.notify()</a>
<ul>
<li><a href="#object-wait">object.wait()</a></li>
<li><a href="#object-notify">object.notify()</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
            </aside>
        </div>
    </div>

        <footer>
    Powered by <a target="_blank" href="https://gohugo.io/">Hugo</a>
</footer>
        <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
        


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.3.5/jquery.fancybox.min.css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.3.5/jquery.fancybox.min.js"></script>

        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css">
        <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
        <script src="https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js"></script>
        <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML">
        </script>
        <script type="text/javascript" src="/js/main.js"></script>
    </body>

</html>