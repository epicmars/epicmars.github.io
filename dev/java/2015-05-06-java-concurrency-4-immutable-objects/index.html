<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta lang="zh"/>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title>
            
    Java Concurrency 4、不可变对象（Immutable Objects） &ndash; DevNote

        </title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" type="text/css" media="screen" href="/css/main.css" />
        
    <link rel="stylesheet" type="text/css" media="screen" href="/css/article.css" />

    </head>

    <body>
        <header>
    <a href="https://www.jastrelax.com/">DevNote</a>
</header>
        
    <div class="main">
        <div class="article">
            <article>
                <div class="title">
                    <h1 id="title">Java Concurrency 4、不可变对象（Immutable Objects）</h1>
                </div>
                <div class="content">
                        

<h2 id="不可变对象-immutable-objects">不可变对象（Immutable Objects）</h2>

<p>一个对象在创建后其状态不能被改变，那么就称其为不可变的（immutable）。最大程度地依赖不可变对象被广泛认可为创建简单、可靠代码的合理策略。</p>

<p>不可变对象在并发应用中尤为有用，由于他们不能改变状态，因此不受线程干扰的影响或者被观察到非一致状态。</p>

<p>开发者常常不情愿使用不可变对象，因为与更新一个对象相比，他们担心创建一个新的对象的开销。然而对象创建的影响常常被高估了，他们可以被与不可变对象带来的高效性所弥补。这些包括减少内存回收的开销，和消除用于保护可变对象被污染的代码。</p>

<p>以下小节采用一个实例可变的类派生出一个实例不可变的类。这样做，给予这种转换的通用规则并且展示了不可变对象的优势。</p>

<h2 id="一个同步类示例-a-synchronized-class-example">一个同步类示例（A Synchronized Class Example）</h2>

<p>SynchronizedRGB类定义了表示颜色的对象，每个对象将颜色表示为三个整形，代表基础颜色值，以及一个字符串给出颜色的名称。</p>

<pre><code class="language-java">public class SynchronizedRGB {
    // Values must be between 0 and 255.
    private int red;
    private int green;
    private int blue;
    private String name;

    private void check(int red, int green, int blue) {
        if (red &lt; 0 || red &gt; 255 || green &lt; 0 || green &gt; 255 || blue &lt; 0 || blue &gt; 255) {
            throw new IllegalArgumentException();
        }
    }

    public SynchronizedRGB(int red, int green, int blue, String name) {
        check(red, green, blue);
        this.red = red;
        this.green = green;
        this.blue = blue;
        this.name = name;
    }

    public void set(int red, int green, int blue, String name) {
        check(red, green, blue);
        synchronized (this) {
            this.red = red;
            this.green = green;
            this.blue = blue;
            this.name = name;
        }
    }

    public synchronized int getRGB() {
        return ((red &lt;&lt; 16) | (green &lt;&lt; 8) | blue);
    }

    public synchronized String getName() {
        return name;
    }

    public synchronized void invert() {
        red = 255 - red;
        green = 255 - green;
        blue = 255 - blue;
        name = &quot;Inverse of &quot; + name;
    }
}
</code></pre>

<p>对SynchronizedRGB的使用必须非常小心以避免不一致的状态，例如，假设一个线程执行了以下代码：</p>

<pre><code class="language-java">SynchronizedRGB color = new SynchronizedRGB(0, 0, 0, &quot;Pitch Black&quot;);
...
int myColorInt = color.getRGB(); //Statement 1
String myColorName = color.getName(); //Statement 2
</code></pre>

<p>如果另一个线程在Statement 1之后，Statement 2之前调用了color.set方法，那么myColorInt的值将不会与myColorName匹配。为了避免这一结果，必须将两个语句绑定到一起：</p>

<pre><code class="language-java">synchronized (color) {
    int myColorInt = color.getRGB();
    String myColorName = color.getName();
}
</code></pre>

<p>仅对可变对象这种不一致性才可能发生，对SynchronizedRGB的不可变版本则不会成为问题。</p>

<h2 id="一种定义不可变对象的策略-a-strategy-for-defining-immutable-objects">一种定义不可变对象的策略（A Strategy for Defining Immutable Objects）</h2>

<p>以下规则定义了用于创建不可变对象的简单策略，不是所有声称“不可变”的类都遵循这些规则。这不必意味着这些类的创建是草率（sloppy）的——他们有好的理由来相信这些类的实例在构建后保持不变。然而，这种策略需要精妙的（sophisticated）分析，并不是为初学者准备的。
1. 不要提供“setter”方法——也就是用于改变域或者域所引用的对象。
2. 将所有的域声明为final和private的。
3. 不要允许子类复写方法。这样做的最简单方式就是将类声明为final的。一个更精妙的方法是将构造器声明为private并且在工厂方法中构造实例。
4. 如果实例域包括了对可变对象的引用，不要允许这些对象被改变：
    * 不要提供改变可变对象的方法。
    * 不要共享对可变对象的引用。永远不要将传给构造器的外部的、可变的对象的引用进行存储，如果需要，创建复本，并存储复本的引用。类似地，必要时创建内部可变对象的复本，以避免在方法中返回源对象。</p>

<p>将这一策略用于SynchronizedRGB可以得到以下步骤：
1. 该类有两个setter方法，第一个，set方法，任意改变对象，在类的不可变版本中应当去掉。第二个，invert方法，可以改变用于创建一个新的对象而非改变已有的对象。
2. 所有的域已经是private的，可以进一步声明为final的。
3. 类本身声明为final。
4. 只有一个域引用了一个对象，并且该对象自身不可变。因此，不需要对所含可变对象的状态的改变做必要的防护措施。</p>

<p>这些改变之后，我们得到ImmutableRGB：</p>

<pre><code class="language-java">final public class ImmutableRGB { // Values must be between 0 and 255.
    final private int red;
    final private int green;
    final private int blue;
    final private String name;

    private void check(int red, int green, int blue) {
        if (red &lt; 0 || red &gt; 255 || green &lt; 0 || green &gt; 255 || blue &lt; 0 || blue &gt; 255) {
            throw new IllegalArgumentException();
        }
    }

    public ImmutableRGB(int red, int green, int blue, String name) {
        check(red, green, blue);
        this.red = red;
        this.green = green;
        this.blue = blue;
        this.name = name;
    }

    public int getRGB() {
        return ((red &lt;&lt; 16) | (green &lt;&lt; 8) | blue);
    }

    public String getName() {
        return name;
    }

    public ImmutableRGB invert() {
        return new ImmutableRGB(255 - red, 255 - green, 255 - blue, &quot;Inverse of &quot; + name);
    }
}
</code></pre>

                </div>
                
            </article>
            <aside>
                <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#不可变对象-immutable-objects">不可变对象（Immutable Objects）</a></li>
<li><a href="#一个同步类示例-a-synchronized-class-example">一个同步类示例（A Synchronized Class Example）</a></li>
<li><a href="#一种定义不可变对象的策略-a-strategy-for-defining-immutable-objects">一种定义不可变对象的策略（A Strategy for Defining Immutable Objects）</a></li>
</ul></li>
</ul>
</nav>
            </aside>
        </div>
    </div>

        <footer>
    Powered by <a target="_blank" href="https://gohugo.io/">Hugo</a>
</footer>
        <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
        


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.3.5/jquery.fancybox.min.css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.3.5/jquery.fancybox.min.js"></script>

        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css">
        <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
        <script src="https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js"></script>
        <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML">
        </script>
        <script type="text/javascript" src="/js/main.js"></script>
    </body>

</html>