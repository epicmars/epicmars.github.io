<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" >
        <meta lang="zh">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title>Gradle构建脚本开发指南 | androidpi</title>
<meta name="description" content="Groovy语言 Gradle构建脚本提供了Groovy这一强大的语言工具： task upper { doLast { String someString = &#39;mY_nAmE&#39; println &#34;Original: &#34; &#43; someString println &#34;Upper case: &#34; &#43; someString.toUpperCase() } } API 核心类 Gradle构">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" type="text/css" media="screen" href="/css/main.css" />
        <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.0/css/solid.css" integrity="sha384-TbilV5Lbhlwdyc4RuIV/JhD8NR+BfMrvz4BL5QFa2we1hQu6wvREr3v6XSRfCTRp" crossorigin="anonymous">
        <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.0/css/brands.css" integrity="sha384-7xAnn7Zm3QC1jFjVc1A6v/toepoG3JXboQYzbM0jrPzou9OFXm/fY6Z/XiIebl/k" crossorigin="anonymous">
        <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.0/css/fontawesome.css" integrity="sha384-ozJwkrqb90Oa3ZNb+yKFW2lToAWYdTiF1vt8JiH5ptTGHTGcN7qdoR1F95e0kYyG" crossorigin="anonymous">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet">
        
    <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet">
    <link rel="stylesheet" type="text/css" media="screen" href="/css/article.css" />

    </head>

    <body>
        <div class="site-wrapper">
                <header>
    <nav>
        <a class="home" href="https://www.androidpi.com/">首页</a>
    </nav>
    
</header>
                <div class="site-main">
                    
    <div class="main">
        <div class="article">
            <aside>
                    <nav id="TableOfContents">
  <ul>
    <li><a href="#groovy语言">Groovy语言</a></li>
    <li><a href="#api">API</a>
      <ul>
        <li><a href="#核心类">核心类</a></li>
        <li><a href="#外部依赖库">外部依赖库</a></li>
      </ul>
    </li>
    <li><a href="#脚本基础">脚本基础</a>
      <ul>
        <li><a href="#局部变量">局部变量</a></li>
        <li><a href="#附加属性extra-properties">附加属性（Extra properties）</a></li>
        <li><a href="#配置任意对象">配置任意对象</a></li>
        <li><a href="#使用外部脚本配置任意对象">使用外部脚本配置任意对象</a></li>
      </ul>
    </li>
    <li><a href="#方法">方法</a></li>
    <li><a href="#任务">任务</a>
      <ul>
        <li><a href="#任务间的依赖">任务间的依赖</a></li>
        <li><a href="#动态任务">动态任务</a></li>
        <li><a href="#附加任务属性">附加任务属性</a></li>
        <li><a href="#默认任务">默认任务</a></li>
        <li><a href="#使用任务dag有向无环图进行配置">使用任务DAG（有向无环图）进行配置</a></li>
      </ul>
    </li>
    <li><a href="#使用插件">使用插件</a>
      <ul>
        <li><a href="#脚本插件">脚本插件</a></li>
        <li><a href="#二进制插件">二进制插件</a></li>
      </ul>
    </li>
    <li><a href="#gradle工程结构">Gradle工程结构</a>
      <ul>
        <li><a href="#将不同语言的源代码分开">将不同语言的源代码分开</a></li>
        <li><a href="#将不同测试类型的源代码分开">将不同测试类型的源代码分开</a></li>
        <li><a href="#总是定义一个settings文件">总是定义一个settings文件</a></li>
        <li><a href="#使用buildsrc来抽象命令式逻辑">使用<code>buildSrc</code>来抽象命令式逻辑</a></li>
        <li><a href="#在gradleproperties文件中声明属性">在gradle.properties文件中声明属性</a></li>
      </ul>
    </li>
  </ul>
</nav>
            </aside>
            <article>
                <div class="title">
                    <h1 id="title">Gradle构建脚本开发指南</h1>
                </div>
                <div class="content">
                        <h2 id="groovy语言">Groovy语言</h2>
<p>Gradle构建脚本提供了Groovy这一强大的语言工具：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-groovy" data-lang="groovy">task upper <span style="color:#f92672">{</span>
    doLast <span style="color:#f92672">{</span>
        String someString <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;mY_nAmE&#39;</span>
        println <span style="color:#e6db74">&#34;Original: &#34;</span> <span style="color:#f92672">+</span> someString
        println <span style="color:#e6db74">&#34;Upper case: &#34;</span> <span style="color:#f92672">+</span> someString<span style="color:#f92672">.</span><span style="color:#a6e22e">toUpperCase</span><span style="color:#f92672">()</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h2 id="api">API</h2>
<h3 id="核心类">核心类</h3>
<p><a href="https://docs.gradle.org/current/dsl/">Gradle构建语言参考</a>:</p>
<ul>
<li><a href="https://docs.gradle.org/current/dsl/org.gradle.api.Project.html">Project</a></li>
<li><a href="https://docs.gradle.org/current/dsl/org.gradle.api.Task.html">Task</a></li>
<li><a href="https://docs.gradle.org/current/dsl/org.gradle.api.invocation.Gradle.html">Gradle</a></li>
<li><a href="https://docs.gradle.org/current/dsl/org.gradle.api.initialization.Settings.html">Settings</a></li>
<li><a href="https://docs.gradle.org/current/dsl/org.gradle.api.Script.html">Script</a></li>
</ul>
<h3 id="外部依赖库">外部依赖库</h3>
<p>如果构建脚本需要外部的库，可以将其加入到构建脚本的classpath中，这通过使用<code>buildscript()</code>方法来配置：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-groovy" data-lang="groovy">buildscript <span style="color:#f92672">{</span>
    repositories <span style="color:#f92672">{</span>
        mavenCentral<span style="color:#f92672">()</span>
    <span style="color:#f92672">}</span>
    dependencies <span style="color:#f92672">{</span>
        classpath group: <span style="color:#e6db74">&#39;commons-codec&#39;</span><span style="color:#f92672">,</span> name: <span style="color:#e6db74">&#39;commons-codec&#39;</span><span style="color:#f92672">,</span> version: <span style="color:#e6db74">&#39;1.2&#39;</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>传递给<code>buildscript()</code>的闭包会配置一个<code>ScriptHandler</code>实例。</p>
<blockquote>
<p>注意：构建脚本本身也有<code>repositories {}</code>和<code>dependencies {}</code>配置模块：</p>
<table>
<thead>
<tr>
<th>块</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>buildscript { }</td>
<td>Configures the build script classpath for this project.</td>
</tr>
<tr>
<td>dependencies { }</td>
<td>Configures the dependencies for this project.</td>
</tr>
<tr>
<td>repositories { }</td>
<td>Configures the repositories for this project.</td>
</tr>
<tr>
<td>其区别在于<code>buildscript()</code>中<code>repositories {}</code>和<code>dependencies {}</code>块是针对构建脚本的配置，例如引入的Gradle插件等。而构建脚本的顶级<code>repositories {}</code>和<code>dependencies {}</code>块是代理到Project的配置，也就是针对工程的配置，即实际项目中使用到的依赖库。</td>
<td></td>
</tr>
</tbody>
</table>
</blockquote>
<h2 id="脚本基础">脚本基础</h2>
<p>参考<a href="https://docs.gradle.org/current/userguide/writing_build_scripts.html">Writing Build Scripts</a></p>
<h3 id="局部变量">局部变量</h3>
<p>局部变量使用<code>def</code>关键词定义，它们仅在声明的地方可见。局部变量是Groovy语言的一项特性。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-groovy" data-lang="groovy"><span style="color:#66d9ef">def</span> dest <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;dest&#34;</span>

task <span style="color:#a6e22e">copy</span><span style="color:#f92672">(</span>type: Copy<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    from <span style="color:#e6db74">&#34;source&#34;</span>
    into dest
<span style="color:#f92672">}</span>
</code></pre></div><h3 id="附加属性extra-properties">附加属性（Extra properties）</h3>
<p>Gradle领域模型中强化了的对象可以持有附加的用户自定义属性。这包括但不限于project，task和source set。附加属性可以通过所在对象的<code>ext</code>属性进行添加和读取。此外，一个<code>ext</code>块可以用于一次性添加多个属性。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-groovy" data-lang="groovy">apply plugin: <span style="color:#e6db74">&#34;java&#34;</span>

<span style="color:#75715e">// 添加两个属性
</span><span style="color:#75715e"></span>ext <span style="color:#f92672">{</span>
    springVersion <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;3.1.0.RELEASE&#34;</span>
    emailNotification <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;build@master.org&#34;</span>
<span style="color:#f92672">}</span>

<span style="color:#75715e">// 添加一个purpose属性到每个source set中
</span><span style="color:#75715e"></span>sourceSets<span style="color:#f92672">.</span><span style="color:#a6e22e">all</span> <span style="color:#f92672">{</span> ext<span style="color:#f92672">.</span><span style="color:#a6e22e">purpose</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">}</span>
<span style="color:#75715e">// 一旦属性被添加，就可以像预先定义的属性那样进行访问
</span><span style="color:#75715e"></span>sourceSets <span style="color:#f92672">{</span>
    main <span style="color:#f92672">{</span>
        purpose <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;production&#34;</span>
    <span style="color:#f92672">}</span>
    test <span style="color:#f92672">{</span>
        purpose <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;test&#34;</span>
    <span style="color:#f92672">}</span>
    plugin <span style="color:#f92672">{</span>
        purpose <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;production&#34;</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

task printProperties <span style="color:#f92672">{</span>
    doLast <span style="color:#f92672">{</span>
        println springVersion
        println emailNotification
        sourceSets<span style="color:#f92672">.</span><span style="color:#a6e22e">matching</span> <span style="color:#f92672">{</span> it<span style="color:#f92672">.</span><span style="color:#a6e22e">purpose</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;production&#34;</span> <span style="color:#f92672">}.</span><span style="color:#a6e22e">each</span> <span style="color:#f92672">{</span> println it<span style="color:#f92672">.</span><span style="color:#a6e22e">name</span> <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p><strong>附加属性可以从所有者对象的任意地方进行访问，它具有比局部变量更大的作用域。一个project的附加属性对其子工程subproject是可见的。</strong></p>
<h3 id="配置任意对象">配置任意对象</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-groovy" data-lang="groovy">task configure <span style="color:#f92672">{</span>
    doLast <span style="color:#f92672">{</span>
        <span style="color:#75715e">// configure是Project中的方法
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// Configures an object via a closure, with the closure&#39;s delegate set to the 
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// supplied object. This way you don&#39;t have to specify the context of a configuration statement multiple times.
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">def</span> pos <span style="color:#f92672">=</span> configure<span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> java<span style="color:#f92672">.</span><span style="color:#a6e22e">text</span><span style="color:#f92672">.</span><span style="color:#a6e22e">FieldPosition</span><span style="color:#f92672">(</span><span style="color:#ae81ff">10</span><span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
            beginIndex <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
            endIndex <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>
        <span style="color:#f92672">}</span>
        println pos<span style="color:#f92672">.</span><span style="color:#a6e22e">beginIndex</span>
        println pos<span style="color:#f92672">.</span><span style="color:#a6e22e">endIndex</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h3 id="使用外部脚本配置任意对象">使用外部脚本配置任意对象</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-groovy" data-lang="groovy">task configure <span style="color:#f92672">{</span>
    doLast <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">def</span> pos <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> java<span style="color:#f92672">.</span><span style="color:#a6e22e">text</span><span style="color:#f92672">.</span><span style="color:#a6e22e">FieldPosition</span><span style="color:#f92672">(</span><span style="color:#ae81ff">10</span><span style="color:#f92672">)</span>
        <span style="color:#75715e">// Apply the script
</span><span style="color:#75715e"></span>        apply from: <span style="color:#e6db74">&#39;other.gradle&#39;</span><span style="color:#f92672">,</span> to: pos
        println pos<span style="color:#f92672">.</span><span style="color:#a6e22e">beginIndex</span>
        println pos<span style="color:#f92672">.</span><span style="color:#a6e22e">endIndex</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>other.gradle</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-groovy" data-lang="groovy"><span style="color:#75715e">// Set properties.
</span><span style="color:#75715e"></span>beginIndex <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
endIndex <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>
</code></pre></div><h2 id="方法">方法</h2>
<p>组织构建逻辑的第一个抽象层级就是使用方法：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-groovy" data-lang="groovy">task checksum <span style="color:#f92672">{</span>
    doLast <span style="color:#f92672">{</span>
        fileList<span style="color:#f92672">(</span><span style="color:#e6db74">&#39;../antLoadfileResources&#39;</span><span style="color:#f92672">).</span><span style="color:#a6e22e">each</span> <span style="color:#f92672">{</span> File file <span style="color:#f92672">-&gt;</span>
            ant<span style="color:#f92672">.</span><span style="color:#a6e22e">checksum</span><span style="color:#f92672">(</span>file: file<span style="color:#f92672">,</span> property: <span style="color:#e6db74">&#34;cs_$file.name&#34;</span><span style="color:#f92672">)</span>
            println <span style="color:#e6db74">&#34;$file.name Checksum: ${ant.properties[&#34;</span>cs_$file<span style="color:#f92672">.</span><span style="color:#a6e22e">name</span><span style="color:#e6db74">&#34;]}&#34;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

task loadfile <span style="color:#f92672">{</span>
    doLast <span style="color:#f92672">{</span>
        fileList<span style="color:#f92672">(</span><span style="color:#e6db74">&#39;../antLoadfileResources&#39;</span><span style="color:#f92672">).</span><span style="color:#a6e22e">each</span> <span style="color:#f92672">{</span> File file <span style="color:#f92672">-&gt;</span>
            ant<span style="color:#f92672">.</span><span style="color:#a6e22e">loadfile</span><span style="color:#f92672">(</span>srcFile: file<span style="color:#f92672">,</span> property: file<span style="color:#f92672">.</span><span style="color:#a6e22e">name</span><span style="color:#f92672">)</span>
            println <span style="color:#e6db74">&#34;I&#39;m fond of $file.name&#34;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

File<span style="color:#f92672">[]</span> <span style="color:#a6e22e">fileList</span><span style="color:#f92672">(</span>String dir<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    file<span style="color:#f92672">(</span>dir<span style="color:#f92672">).</span><span style="color:#a6e22e">listFiles</span><span style="color:#f92672">({</span>file <span style="color:#f92672">-&gt;</span> file<span style="color:#f92672">.</span><span style="color:#a6e22e">isFile</span><span style="color:#f92672">()</span> <span style="color:#f92672">}</span> <span style="color:#66d9ef">as</span> FileFilter<span style="color:#f92672">).</span><span style="color:#a6e22e">sort</span><span style="color:#f92672">()</span>
<span style="color:#f92672">}</span>
</code></pre></div><h2 id="任务">任务</h2>
<p>参考<a href="https://docs.gradle.org/current/userguide/tutorial_using_tasks.html">Build Script Basics</a></p>
<h3 id="任务间的依赖">任务间的依赖</h3>
<p>可以定义依赖于其它任务的任务：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-groovy" data-lang="groovy">task hello <span style="color:#f92672">{</span>
    doLast <span style="color:#f92672">{</span>
        println <span style="color:#e6db74">&#39;Hello world!&#39;</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
task <span style="color:#a6e22e">intro</span><span style="color:#f92672">(</span>dependsOn: hello<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    doLast <span style="color:#f92672">{</span>
        println <span style="color:#e6db74">&#34;I&#39;m Gradle&#34;</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>被依赖的任务可以是懒加载的，即可以后于所依赖的任务进行定义。这对于多工程的构建是非常重要的一点。</p>
<h3 id="动态任务">动态任务</h3>
<p>任务可以动态地进行创建：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-groovy" data-lang="groovy"><span style="color:#ae81ff">4</span><span style="color:#f92672">.</span><span style="color:#a6e22e">times</span> <span style="color:#f92672">{</span> counter <span style="color:#f92672">-&gt;</span>
    task <span style="color:#e6db74">&#34;task$counter&#34;</span> <span style="color:#f92672">{</span>
        doLast <span style="color:#f92672">{</span>
            println <span style="color:#e6db74">&#34;I&#39;m task number $counter&#34;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>这段代码会创建task0，task1，task2，task3共4个任务。</p>
<h3 id="附加任务属性">附加任务属性</h3>
<p>和工程的附加属性类似，可以向一个任务中添加自定义的附加属性：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-groovy" data-lang="groovy">task myTask <span style="color:#f92672">{</span>
    ext<span style="color:#f92672">.</span><span style="color:#a6e22e">myProperty</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;myValue&#34;</span>
<span style="color:#f92672">}</span>

task printTaskProperties <span style="color:#f92672">{</span>
    doLast <span style="color:#f92672">{</span>
        println myTask<span style="color:#f92672">.</span><span style="color:#a6e22e">myProperty</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h3 id="默认任务">默认任务</h3>
<p>如果在命令行中没有指定要执行的任务，可以在脚本中定义这种情况下默认需要执行的任务。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-groovy" data-lang="groovy">defaultTasks <span style="color:#e6db74">&#39;clean&#39;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#39;run&#39;</span>

task clean <span style="color:#f92672">{</span>
    doLast <span style="color:#f92672">{</span>
        println <span style="color:#e6db74">&#39;Default Cleaning!&#39;</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

task run <span style="color:#f92672">{</span>
    doLast <span style="color:#f92672">{</span>
        println <span style="color:#e6db74">&#39;Default Running!&#39;</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

task other <span style="color:#f92672">{</span>
    doLast <span style="color:#f92672">{</span>
        println <span style="color:#e6db74">&#34;I&#39;m not a default task!&#34;</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h3 id="使用任务dag有向无环图进行配置">使用任务DAG（有向无环图）进行配置</h3>
<p>Gradle构建的生命周期中有一个配置阶段和一个执行阶段，在配置阶段完成后，Gradle知晓所有应当执行的任务，并且提供了利用这一信息的Hook。一种用例就是检查release任务是否在将要执行的任务中，依据这一点你可以对一些变量进行赋值：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-groovy" data-lang="groovy">task distribution <span style="color:#f92672">{</span>
    doLast <span style="color:#f92672">{</span>
        println <span style="color:#e6db74">&#34;We build the zip with version=$version&#34;</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

task <span style="color:#a6e22e">release</span><span style="color:#f92672">(</span>dependsOn: <span style="color:#e6db74">&#39;distribution&#39;</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    doLast <span style="color:#f92672">{</span>
        println <span style="color:#e6db74">&#39;We release now&#39;</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

gradle<span style="color:#f92672">.</span><span style="color:#a6e22e">taskGraph</span><span style="color:#f92672">.</span><span style="color:#a6e22e">whenReady</span> <span style="color:#f92672">{</span>taskGraph <span style="color:#f92672">-&gt;</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>taskGraph<span style="color:#f92672">.</span><span style="color:#a6e22e">hasTask</span><span style="color:#f92672">(</span>release<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
        version <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;1.0&#39;</span>
    <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
        version <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;1.0-SNAPSHOT&#39;</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h2 id="使用插件">使用插件</h2>
<p>Gradle中有两种常见的插件，脚本插和二进制插件。脚本插件是用于进一步配置构建的附加构建脚本，通常用一种<strong>声明式</strong>的方式来操作构建，它们通常用于构建内部。二进制插件是实现了<code>Plugin</code>接口的类，并且采用了一种**编程方式(命令式)**来操作构建。</p>
<p>为了使用插件中封装的构建逻辑，Gradle需要进行两步操作。首先，它需要解析插件，然后他需要将插件应用到目标，目标通常是一个<code>Project</code>。</p>
<p>**解析(Resolving)<strong>一个插件意味着找到包含指定插件的jar包的正确版本并将其加入到classpath中。一旦一个插件解析完成，就可以在构建脚本中使用其API。脚本插件是更具</strong>应用(applying)**时提供的文件路径或者URL进行自解析的。作为Gradle发布的一部分的核心插件则是自动解析的。</p>
<p>**应用(Applying)**一个插件意味着在Project上执行插件的<code>Plugin.apply(T) </code>，以增强该Project的功能。插件的应用时幂等的，这意味着多次应用同一个插件不会有副作用。</p>
<h3 id="脚本插件">脚本插件</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-groovy" data-lang="groovy">apply from: <span style="color:#e6db74">&#39;other.gradle&#39;</span>
</code></pre></div><p>脚本插件可以从本地文件系统或一个远程位置进行解析和应用。文件系统位置时相对于工程目录的路径，而远程位置使用HTTP URL指定。</p>
<h3 id="二进制插件">二进制插件</h3>
<p>通过使用插件id进行应用，它是一个全局唯一的插件标识。核心的Gradle插件提供简称进行标识，例如<code>java</code>对应核心<code>JavaPlugin</code>。所有其它二进制插件必须提供全限定形式的插件id，例如<code>com.github.foo.bar</code>。插件id可以使用插件DSL或者<code>buildscript</code>块进行应用。</p>
<p>二进制插件的解析和应用可以使用如下几种方式：</p>
<ul>
<li>使用插件DSL将插件从插件门户或自定义仓库包含进来</li>
<li>使用<code>buildscript</code>块的依赖将插件从外部jar包含进来</li>
<li>在工程的<code>buildScr</code>目录中定义插件源代码</li>
<li>在构建脚本内将插件定义为内部类</li>
</ul>
<h4 id="使用插件dsl应用插件">使用插件DSL应用插件</h4>
<p>注意：插件DSL还处于孵化阶段</p>
<p>新的插件DSL提供了一种声明插件依赖的简洁便利的方式。它和<a href="http://plugins.gradle.org/?_ga=2.53362856.1200471276.1531149141-1924098524.1531149141">Gradle插件门户</a>一起提供了访问核心和社区插件的简单方法。插件DSL块配置一个<code>PluginDependenciesSpec</code>实例：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-groovy" data-lang="groovy">plugins <span style="color:#f92672">{</span>
    <span style="color:#75715e">// 应用核心插件
</span><span style="color:#75715e"></span>    id <span style="color:#e6db74">&#39;java&#39;</span>
    <span style="color:#75715e">// 从插件门户应用社区插件
</span><span style="color:#75715e"></span>    id <span style="color:#e6db74">&#39;com.jfrog.bintray&#39;</span> version <span style="color:#e6db74">&#39;0.4.1&#39;</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>和“传统”的<code>apply()</code>方法机制相比，它有一些限制，有些是暂时的，因为该机制还处于开发中:</p>
<ul>
<li>
<p>有限的语法
新的<code>plugins {}</code>块不支持任意的Groovy代码，这是为了达到幂等的目的。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-groovy" data-lang="groovy">plugins <span style="color:#f92672">{</span>
    id <span style="color:#960050;background-color:#1e0010">«</span>plugin id<span style="color:#960050;background-color:#1e0010">»</span> version <span style="color:#960050;background-color:#1e0010">«</span>plugin version<span style="color:#960050;background-color:#1e0010">»</span> <span style="color:#f92672">[</span>apply <span style="color:#960050;background-color:#1e0010">«</span><span style="color:#66d9ef">false</span><span style="color:#960050;background-color:#1e0010">»</span><span style="color:#f92672">]</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>其中<code>«plugin id»</code>和<code>«plugin version»</code>必须是常量。</p>
</li>
<li>
<p>只能应用到构建脚本中
<code>plugins {}</code>只能在工程的构建脚本中使用，不能在脚本插件、settings.gradle和init脚本中使用。</p>
<p><strong>未来的版本会移除这种限制</strong>。</p>
</li>
</ul>
<h2 id="gradle工程结构">Gradle工程结构</h2>
<p>参考<a href="https://docs.gradle.org/current/userguide/organizing_gradle_projects.html">Organizing Gradle Projects</a></p>
<h3 id="将不同语言的源代码分开">将不同语言的源代码分开</h3>
<p>Gradle的语言插件为发现和编译源代码建立了一套约定。例如，一个使用Java插件的的工程会自动编译目录<code>src/main/java</code>中的代码，其它语言遵循相同的模式：</p>
<pre><code>.
├── build.gradle
├── settings.gradle
└── src
    └── main
        ├── java
        │   └── HelloWorld.java
        └── kotlin
            └── Utils.kt
</code></pre><h3 id="将不同测试类型的源代码分开">将不同测试类型的源代码分开</h3>
<p>常见的用例是工程会定义并执行不同类型的测试，如：单元测试，集成测试，功能测试或者smoke测试。最佳的做法是将不同类型的测试代码分别放到特定的目录下。这对于维护和独立运行不同类型的测试都有帮助：</p>
<pre><code>.
├── build.gradle
├── gradle
│   └── integration-test.gradle
├── settings.gradle
└── src
    ├── integTest
    │   └── java
    │       └── DefaultFileReaderIntegrationTest.java
    ├── main
    │   └── java
    │       ├── DefaultFileReader.java
    │       ├── FileReader.java
    │       └── StringUtils.java
    └── test
        └── java
            └── StringUtilsTest.java
</code></pre><p>Gradle使用<a href="https://docs.gradle.org/4.8/userguide/organizing_gradle_projects.html">源集</a>的概念来对源代码目录进行建模。</p>
<p>gradle/integration-test.gradle</p>
<pre><code>sourceSets {
    integTest {
        java.srcDir file('src/integTest/java')
        resources.srcDir file('src/integTest/resources')
        compileClasspath += sourceSets.main.output + configurations.testRuntimeClasspath
        runtimeClasspath += output + compileClasspath
    }
}

task integTest(type: Test) {
    description = 'Runs the integration tests.'
    group = 'verification'
    testClassesDirs = sourceSets.integTest.output.classesDirs
    classpath = sourceSets.integTest.runtimeClasspath
    mustRunAfter test
}

check.dependsOn integTest
</code></pre><h3 id="总是定义一个settings文件">总是定义一个settings文件</h3>
<p>在每次进行构建时Gradle尝试定位一个<code>settings.gradle</code>文件或一个<code>settings.gradle.kts</code>文件。为了达到这个目的，运行时会从当前目录到根目录进行遍历，直到直到该设置文件。因此总是将该文件放到根目录是效率最高的做法。这个文件可以是空的，也可以定义工程的名字。</p>
<h3 id="使用buildsrc来抽象命令式逻辑">使用<code>buildSrc</code>来抽象命令式逻辑</h3>
<p>将复杂的构建逻辑封装成自定义任务或者二进制插件都是一个好的选项。自定义任务和插件实现不应当存在于构建脚本中，如果不需要将这些任务和插件在许多独立的项目中进行分享，那么使用<code>buildSrc</code>就是一个十分便利的方式。</p>
<p><code>buildSrc</code>目录被作为一个<a href="https://docs.gradle.org/4.8/userguide/composite_builds.html#composite_build_intro">内含构建（included build）</a>。在发现目录后，Gradle自动编译和测试其代码并将其加入到构建脚本的classpath中。对于多工程的构建只能有一个<code>buildSrc</code>目录，并且位于根工程目录下。</p>
<blockquote>
<p>所谓内含构建是指包含在<a href="https://docs.gradle.org/current/userguide/composite_builds.html#composite_build_intro">复合构建</a>内的构建。内含构建与复合构建以及其它内含构建不共享任何配置。每个内含构建是独立配置并执行的。
内含构建与其它构建的交互通过<code>dependency substitution</code>完成，如果复合的任何构建中有一个依赖可以被内含构建满足，那么依赖就会被内含构建中的一个project依赖所代替。</p>
</blockquote>
<p><code>buildSrc</code>使用和Java、Groovy工程一样的源代码约定。它也提供了对Gradle API的直接访问。额外的依赖可以在<code>buildSrc</code>目录下专有的<code>build.gradle</code>中进行声明。</p>
<p>buildSrc/build.gradle</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-groovy" data-lang="groovy">repositories <span style="color:#f92672">{</span>
    mavenCentral<span style="color:#f92672">()</span>
<span style="color:#f92672">}</span>

dependencies <span style="color:#f92672">{</span>
    testCompile <span style="color:#e6db74">&#39;junit:junit:4.12&#39;</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>一个包含<code>buildSrc</code>目录的工程一般具有如下结构：</p>
<pre><code>.
├── build.gradle
├── buildSrc
│   ├── build.gradle
│   └── src
│       ├── main
│       │   └── java
│       │       └── com
│       │           └── enterprise
│       │               ├── Deploy.java
│       │               └── DeploymentPlugin.java
│       └── test
│           └── java
│               └── com
│                   └── enterprise
│                       └── DeploymentPluginTest.java
└── settings.gradle
</code></pre><h3 id="在gradleproperties文件中声明属性">在gradle.properties文件中声明属性</h3>
<p>在Gradle中，属性可以定义在构建脚本、<code>gradle.properties</code>文件或者命令行中。</p>
<p><code>gradle.properties</code>可有益于将属性和构建脚本分离开，这对于那些控制构建环境的属性十分有用。</p>
<p><code>gradle.properties</code>文件一般放在构建的根目录下，也可以在使用<code>GRADLE_USER_HOME</code>环境变量定义的目录下，那么它会成为一个系统全局的属性文件。</p>
<pre><code>.
├── build.gradle
├── gradle.properties
└── settings.gradle
</code></pre>
                </div>
                
            </article>
        </div>
    </div>

                </div>
                <footer>
    Powered by <a target="_blank" href="https://gohugo.io/">Hugo</a> And 
    <a target="_blank" href="https://pages.github.com/">Github Pages</a>
</footer>
                <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
                

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.3.5/jquery.fancybox.min.css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.3.5/jquery.fancybox.min.js"></script>

                <link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.12.0/styles/default.min.css">
                <script src="/js/highlight.pack.js"></script>
                <script src="https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js"></script>
                <script type="text/javascript" async src="https://cdn.bootcss.com/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [
                ['$', '$'],
                ['\\(', '\\)']
            ],
            displayMath: [
                ['$$', '$$']
            ],
            processEscapes: true,
            processEnvironments: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            TeX: {
                equationNumbers: {
                    autoNumber: "AMS"
                },
                extensions: ["AMSmath.js", "AMSsymbols.js"]
            }
        }
    });
    MathJax.Hub.Queue(function () {



        var all = MathJax.Hub.getAllJax(),
            i;
        for (i = 0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });

    MathJax.Hub.Config({

        TeX: {
            equationNumbers: {
                autoNumber: "AMS"
            }
        }
    });
</script>
                <script type="text/javascript" src="/js/main.js"></script>
        </div>
    </body>

</html>