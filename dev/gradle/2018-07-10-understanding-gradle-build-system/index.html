<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" >
        <meta lang="zh">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title>理解Gradle构建系统 | androidpi</title>
<meta name="description" content="近来看了若干关于Gradle的文章和书籍，发现这些文章很大程度上只是官方文档的堆砌，比如Groovy与DSL基础，Gradle有什么基础组件">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" type="text/css" media="screen" href="/css/main.css" />
        <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.0/css/solid.css" integrity="sha384-TbilV5Lbhlwdyc4RuIV/JhD8NR+BfMrvz4BL5QFa2we1hQu6wvREr3v6XSRfCTRp" crossorigin="anonymous">
        <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.0/css/brands.css" integrity="sha384-7xAnn7Zm3QC1jFjVc1A6v/toepoG3JXboQYzbM0jrPzou9OFXm/fY6Z/XiIebl/k" crossorigin="anonymous">
        <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.0/css/fontawesome.css" integrity="sha384-ozJwkrqb90Oa3ZNb+yKFW2lToAWYdTiF1vt8JiH5ptTGHTGcN7qdoR1F95e0kYyG" crossorigin="anonymous">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet">
        
    <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet">
    <link rel="stylesheet" type="text/css" media="screen" href="/css/article.css" />

    </head>

    <body>
        <div class="site-wrapper">
                <header>
    <nav>
        <a class="home" href="https://www.androidpi.com/">首页</a>
    </nav>
    
</header>
                <div class="site-main">
                    
    <div class="main">
        <div class="article">
            <aside>
                    <nav id="TableOfContents">
  <ul>
    <li><a href="#简介">简介</a></li>
    <li><a href="#构建生命周期">构建生命周期</a></li>
    <li><a href="#settings文件">Settings文件</a></li>
    <li><a href="#构建脚本概念">构建脚本概念</a></li>
    <li><a href="#构建脚本基础">构建脚本基础</a></li>
    <li><a href="#核心类">核心类</a>
      <ul>
        <li><a href="#project">Project</a></li>
        <li><a href="#script">Script</a></li>
        <li><a href="#task">Task</a></li>
      </ul>
    </li>
    <li><a href="#gradle插件">Gradle插件</a></li>
    <li><a href="#初始化一个工程">初始化一个工程</a></li>
  </ul>
</nav>
            </aside>
            <article>
                <div class="title">
                    <h1 id="title">理解Gradle构建系统</h1>
                </div>
                <div class="content">
                        <p>近来看了若干关于Gradle的文章和书籍，发现这些文章很大程度上只是官方文档的堆砌，比如Groovy与DSL基础，Gradle有什么基础组件以及如何使用，并没有将Gradle构建的原理讲解清楚。虽然本文也必然是参考Gradle文档而写出的，但试图从一个整体上理解Gradle是如何工作的，以及其组件之间的是如何协作的。</p>
<h2 id="简介">简介</h2>
<p>Gradle的核心在于它是为**基于依赖的编程（dependency based programming）**而生的语言，也就是说你可以定义任务(Task)以及任务间的依赖(dependencies)，Gradle保证任务按照其依赖顺序执行，并且每个任务仅执行一次。这些任务形成一个有向无环图，在执行任何一个任务前，Gradle都会生成完整的依赖图。</p>
<p><strong>构建脚本就是对这个依赖图进行配置，因此严格地说，这些脚本是构建配置脚本。</strong></p>
<h2 id="构建生命周期">构建生命周期</h2>
<p>Gradle构建的生命周期分为如下三个不同的步骤：</p>
<ol>
<li>
<p>初始化</p>
<p>Gradle支持单工程和多工程构建，在初始化阶段，Gradle确定哪些工程(project)会参与到构建中，并为每个工程创建一个Project的实例。</p>
</li>
<li>
<p>配置</p>
<p>在这个阶段，对初始化阶段的Project对象进行配置，并且参与到构建中的所有工程的构建脚本被执行。</p>
</li>
<li>
<p>执行</p>
<p>Gradle确定一个将被执行的在配置阶段创建和配置的一个任务子集，这个子集由传递给<code>gradle</code>命令的参数和当前目录确定。Gradle然后执行每个选中的任务。</p>
</li>
</ol>
<h2 id="settings文件">Settings文件</h2>
<p>除了构建脚本文件，Gradle还定义了一个设置（settings）文件，按照命名惯例，设置文件名为settings.gradle，它在初始化阶段被执行。一个多工程的项目必须有设置文件，因为需要设置文件来定义哪些工程参与到多工程项目的构建中，而单工程项目可以不需要设置文件。</p>
<h2 id="构建脚本概念">构建脚本概念</h2>
<p>Gradle构建脚本基于两个基本的概念：工程（projects）和任务（tasks）。</p>
<p>每个Gradle构建都是由一个或多个工程组成的。一个工程代表什么取决于你想干什么。例如，一个工程可能表示一个JAR库或者一个web应用，也可能代表一个使用ZIP将其它工程生成的JAR包压缩打包得到的发布包。一个工程并不一定代表一个需要去构建的物体。它可能代表一件需要做的事，例如将应用部署到预发布(staging)或生产环境。</p>
<p>每个工程有一个或多个任务组成。一个任务代表一个构建执行的一部分工作（atomic piece of work）。它可能是编译一些类、创建一个JAR、生成Javadoc或者将一存档文件（archives）发布到一个仓库。</p>
<h2 id="构建脚本基础">构建脚本基础</h2>
<p>开头说过<strong>Gradle脚本就是配置脚本</strong>，当脚本执行时，它会配置一个特定类型的对象。例如，对于一个构建脚本，它会配置一个<a href="https://docs.gradle.org/current/dsl/org.gradle.api.Project.html">Project</a>对象。这个对象称为委托（delegate）对象。下表给出了各种Gradle脚本的代理对象类型：</p>
<table>
<thead>
<tr>
<th>脚本类型</th>
<th>委托实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>Build script</td>
<td>Project</td>
</tr>
<tr>
<td>Init script</td>
<td>Gradle</td>
</tr>
<tr>
<td>Settings script</td>
<td>Settings</td>
</tr>
</tbody>
</table>
<p>各个不同脚本中可以使用相应委托对象中的属性和方法。</p>
<p>此外，每种Gradle脚本都实现了<a href="https://docs.gradle.org/current/dsl/org.gradle.api.Script.html"><code>Script</code></a>，这个接口定义了许多可以在脚本中使用的属性和方法。</p>
<p>对于具体的构建脚本结构，它由零个或多个语句（statements）和脚本块（script blocks）组成：</p>
<ul>
<li>语句：包含方法调用，属性赋值以及局部变量定义</li>
<li>脚本块：一个接收一个闭包作为参数的方法调用。该闭包在执行时被当做一个配置闭包来配置一些委托对象</li>
</ul>
<p>以下列出了顶级脚本块：</p>
<table>
<thead>
<tr>
<th>Block</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>allprojects { }</td>
<td>Configures this project and each of its sub-projects.</td>
</tr>
<tr>
<td>artifacts { }</td>
<td>Configures the published artifacts for this project.</td>
</tr>
<tr>
<td>buildscript { }</td>
<td>Configures the build script classpath for this project.</td>
</tr>
<tr>
<td>configurations { }</td>
<td>Configures the dependency configurations for this project.</td>
</tr>
<tr>
<td>dependencies { }</td>
<td>Configures the dependencies for this project.</td>
</tr>
<tr>
<td>repositories { }</td>
<td>Configures the repositories for this project.</td>
</tr>
<tr>
<td>sourceSets { }</td>
<td>Configures the source sets of this project.</td>
</tr>
<tr>
<td>subprojects { }</td>
<td>Configures the sub-projects of this project.</td>
</tr>
<tr>
<td>publishing { }</td>
<td>Configures the PublishingExtension added by the publishing plugin.</td>
</tr>
</tbody>
</table>
<h2 id="核心类">核心类</h2>
<h3 id="project">Project</h3>
<p>构建脚本定义了Gradle中的一个工程(project)，对于构建中的每个工程，Gradle都创建一个Project类型的对象并将该对象与构建脚本进行关联。在脚本执行的时候，会对该Project对象进行配置。</p>
<ul>
<li>构建脚本中对未定义方法的调用都会委托给<code>Project</code>对象</li>
<li>构建脚本中对未定义属性的访问都会委托给<code>Project</code>对象</li>
</ul>
<h3 id="script">Script</h3>
<p>在Gradle执行一个脚本的时候，它将脚本编译为一个实现了<code>Script</code>接口的类。这意味着<code>Script</code>接口中定义的所有属性和方法都可以在脚本中访问。</p>
<h3 id="task">Task</h3>
<p>一个任务代表构建中的单个工作，例如编译类或者生成javadoc，每个任务属于一个工程。</p>
<h2 id="gradle插件">Gradle插件</h2>
<p>直接利用上面的组件就可以进行构建脚本的编写了，并且可以完成任意的构建需求。但Gradle的强大之处在于它提供了丰富的插件，可以对构建脚本进行扩展。</p>
<p>Gradle的核心有意设计为对现实世界的自动化构建提供极少的支持。所有有用的特性都是通过插件添加的，例如编译Java代码。插件可以添加新的任务(例如<a href="https://docs.gradle.org/4.8/dsl/org.gradle.api.tasks.compile.JavaCompile.html"><code>JavaCompile</code></a>)、领域对象（例如<a href="https://docs.gradle.org/4.8/dsl/org.gradle.api.tasks.SourceSet.html"><code>SourceSet</code></a>）、约定配置（例如Java源代码位于<code>src/main/java</code>），以及扩展核心对象和其它插件的对象。</p>
<p>插件允许对project的能力进行扩展：</p>
<ul>
<li>扩展Gradle模型（例如添加可以配置的DSL元素）</li>
<li>根据约定配置工程（例如添加新任务或者配置有用的默认配置）</li>
<li>应用特定的配置（例如添加组织化的仓库或者强制标准）</li>
</ul>
<p>通过引用插件，而不是直接在构建脚本中添加，有如下好处：</p>
<ul>
<li>在跨越多工程的项目中，它可以促进对相同构建逻辑的复用，减小维护这一部分逻辑的维护成本</li>
<li>允许更高一级的模块化，强化了综合性和组织性</li>
<li>对命令式的逻辑进行封装并且允许脚本尽可能达到声明式的效果</li>
</ul>
<h2 id="初始化一个工程">初始化一个工程</h2>
<p>在工程的根目录下运行<code>Gradle</code>的<code>init</code>命令来生成一个工程：</p>
<pre><code>❯ gradle init 
Starting a Gradle Daemon (subsequent builds will be faster)

BUILD SUCCESSFUL in 3s
2 actionable tasks: 2 executed
</code></pre>
<p>如果想使用Kotlin DSL可以使用gradle init &ndash;dsl kotlin选项。具体查看<a href="https://docs.gradle.org/4.8/userguide/build_init_plugin.html#sec:what_to_set_up">此处</a>。</p>

                </div>
                
            </article>
        </div>
    </div>

                </div>
                <footer>
    Powered by <a target="_blank" href="https://gohugo.io/">Hugo</a> And 
    <a target="_blank" href="https://pages.github.com/">Github Pages</a>
</footer>
                <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
                

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.3.5/jquery.fancybox.min.css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.3.5/jquery.fancybox.min.js"></script>

                <link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.12.0/styles/default.min.css">
                <script src="/js/highlight.pack.js"></script>
                <script src="https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js"></script>
                <script type="text/javascript" async src="https://cdn.bootcss.com/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [
                ['$', '$'],
                ['\\(', '\\)']
            ],
            displayMath: [
                ['$$', '$$']
            ],
            processEscapes: true,
            processEnvironments: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            TeX: {
                equationNumbers: {
                    autoNumber: "AMS"
                },
                extensions: ["AMSmath.js", "AMSsymbols.js"]
            }
        }
    });
    MathJax.Hub.Queue(function () {



        var all = MathJax.Hub.getAllJax(),
            i;
        for (i = 0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });

    MathJax.Hub.Config({

        TeX: {
            equationNumbers: {
                autoNumber: "AMS"
            }
        }
    });
</script>
                <script type="text/javascript" src="/js/main.js"></script>
        </div>
    </body>

</html>