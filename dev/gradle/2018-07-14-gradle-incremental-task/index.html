<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta lang="zh"/>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title>
            
    Gradle构建：增量任务 &ndash; DevelopNote

        </title>
        <meta name="description" content="" />
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" type="text/css" media="screen" href="/css/main.css" />
        <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.0/css/solid.css" integrity="sha384-TbilV5Lbhlwdyc4RuIV/JhD8NR+BfMrvz4BL5QFa2we1hQu6wvREr3v6XSRfCTRp" crossorigin="anonymous">
        <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.0/css/brands.css" integrity="sha384-7xAnn7Zm3QC1jFjVc1A6v/toepoG3JXboQYzbM0jrPzou9OFXm/fY6Z/XiIebl/k" crossorigin="anonymous">
        <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.0/css/fontawesome.css" integrity="sha384-ozJwkrqb90Oa3ZNb+yKFW2lToAWYdTiF1vt8JiH5ptTGHTGcN7qdoR1F95e0kYyG" crossorigin="anonymous">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet">
        
    <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet">
    <link rel="stylesheet" type="text/css" media="screen" href="/css/article.css" />

    </head>

    <body>
        <div class="site-wrapper">
                <header>
    <nav>
        <a class="home" href="https://www.jastrelax.com/">首页</a>
    </nav>
    
</header>
                <div class="site-main">
                    
    <div class="main">
        <div class="article">
            <aside>
                    <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#任务输入和输出">任务输入和输出</a></li>
<li><a href="#自定义任务类型">自定义任务类型</a></li>
<li><a href="#运行时api">运行时API</a>
<ul>
<li><a href="#运用到临时任务">运用到临时任务</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
            </aside>
            <article>
                <div class="title">
                    <h1 id="title">Gradle构建：增量任务</h1>
                </div>
                <div class="content">
                        

<p>构建中的一项能力就是避免进行已经做过的工作。考虑编译的过程，一旦你的源代码已经编译过了，除非作出了影响输出的修改，那就没有必要重新编译。Gradle原生就支持增量构建，你可能已经见到过了：在运行构建时，每次一个任务名称旁出现<code>UP-TO-DATE</code>文字就表明进行了增量构建。</p>

<h2 id="任务输入和输出">任务输入和输出</h2>

<p>在最常见的情形中，一个任务接收一些输入然后生成一些输出。如下图所示：</p>

<p><img src="/assets/images/gradle/task-inputs-outputs.png" alt="任务输入与输出" /></p>

<p>作为增量构建的一部分，Gradle测试上一次构建中任务的的输入和输出是否有变化。如果没有，那么Gradle就认为任务是最新的（没有过时），因此会跳过执行其操作。注意，如果任务没有输出，那么增量构建不会起作用。</p>

<p>这意味着，你需要告诉Gradle那些任务属性是输入，那些是输出。如果一个任务属性影响到输出，那么一定要将其注册为输入，不然任务就会认为是最新的，但实际上可能不是。反之，如果属性不影响输出那就不要将其注册为输入。还需要注意的是，非确定性的任务对相同的输入可能产生不同的输出，这些不应当配置到增量构建中，因为up-to-date检查不会起作用。</p>

<h2 id="自定义任务类型">自定义任务类型</h2>

<p>如果你实现了一个自定义Task类型，那么需要以下两步就可以应用增量构建：</p>

<ol>
<li>为每个任务的输入和输出创建类型化属性（通过getter方法）</li>
<li>给每个这样的属性添加合适的注解</li>
</ol>

<blockquote>
<p>注意：注解必须放在Groovy属性的getter方法上。放在setter方法上的注解，或者一个Java域的注解（没有对应的注解getter方法）会被忽略。</p>
</blockquote>

<p>Gradle支持3种类型的输入和输出：</p>

<ul>
<li><p>简单值</p>

<p>例如字符串和数字。更一般地，一个简单值可以有任何实现<code>Serilizable</code>的类型。</p></li>

<li><p>文件系统类型</p>

<p>这包括标准的<code>File</code>类，以及Gradle的派生类型<code>FileCollection</code>和任何可以传递给<code>Project.file(java.lang.Object)</code>方法的类型，如单文件/目录属性，或者<code>Project.files(java.lang.Object[]), ProjectLayout.files(java.lang.Object[])</code>和<code>ProjectLayout.configurableFiles(java.lang.Object[])</code>方法。</p></li>

<li><p>嵌套值</p>

<p>与前两种类型不符的自定义类型，但拥有自己的输入和输出属性。实际上，该任务的输入或输出嵌套这些自定义类型内部。</p></li>
</ul>

<p>例如，想象你有一个处理各种类型模板的任务，如<code>FreeMarker</code>，<code>Velocity</code>，<code>Moustache</code>等。它接收模板源码文件并将其与一些模型数据结合起来，来生成模板文件的填充版。</p>

<p>该任务会有三个输入和一个输出：</p>

<ul>
<li>模板源代码文件</li>
<li>模型数据</li>
<li>模板引擎</li>
<li>输出文件输出位置</li>
</ul>

<p>在编写自定义任务类时，使用注解可以容易地将属性注册为输入和输出。为了说明这点，以下是一个任务实现框架，它有一些合适输入和输出，以及相应的注解：</p>

<p>buildSrc/src/main/java/org/example/ProcessTemplates.java</p>

<pre><code class="language-groovy">package org.example;

import java.io.File;
import java.util.HashMap;
import org.gradle.api.*;
import org.gradle.api.file.*;
import org.gradle.api.tasks.*;

public class ProcessTemplates extends DefaultTask {
    private TemplateEngineType templateEngine;
    private FileCollection sourceFiles;
    private TemplateData templateData;
    private File outputDir;

    @Input
    public TemplateEngineType getTemplateEngine() {
        return this.templateEngine;
    }

    @InputFiles
    public FileCollection getSourceFiles() {
        return this.sourceFiles;
    }

    @Nested
    public TemplateData getTemplateData() {
        return this.templateData;
    }

    @OutputDirectory
    public File getOutputDir() { return this.outputDir; }

    // + setter methods for the above - assume we’ve defined them

    @TaskAction
    public void processTemplates() {
        // ...
    }
}
</code></pre>

<p>buildSrc/src/main/java/org/example/TemplateData.java</p>

<pre><code class="language-groovy">package org.example;

import java.util.HashMap;
import java.util.Map;
import org.gradle.api.tasks.Input;

public class TemplateData {
    private String name;
    private Map&lt;String, String&gt; variables;

    public TemplateData(String name, Map&lt;String, String&gt; variables) {
        this.name = name;
        this.variables = new HashMap&lt;&gt;(variables);
    }

    @Input
    public String getName() { return this.name; }

    @Input
    public Map&lt;String, String&gt; getVariables() {
        return this.variables;
    }
}
</code></pre>

<pre><code>Output of gradle processTemplates

&gt; gradle processTemplates
&gt; Task :processTemplates


BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed
Output of gradle processTemplates

&gt; gradle processTemplates
&gt; Task :processTemplates UP-TO-DATE

BUILD SUCCESSFUL in 0s
1 actionable task: 1 up-to-date
</code></pre>

<p>对于这个例子，来依次理解下每个输入和输出：</p>

<ul>
<li><p><code>templateEngine</code></p>

<p>代表处理源码模板时使用哪个引擎，例如<code>FreeMarker</code>，<code>Velocity</code>，等。你可以将其实现为一个字符串，但这个例子中我们使用一个自定义枚举，因为它提供更强的类型信息和更高的安全性。由于枚举自动实现了<code>Serializable</code>，我们可以将其作为一个简单值，并使用<code>@Input</code>注解，正如可以在<code>String</code>类型上使用一样。</p></li>

<li><p><code>sourceFiles</code></p>

<p>表示任务要处理的源码模板。单个文件和文件集合需要对应的特殊注解。这里处理的是文件集合，因此使用的是<code>@InputFiles</code>注解。</p></li>

<li><p><code>templateData</code></p>

<p>这个例子中使用了一个自定义来代表模型数据。然而，它没有实现<code>Serializable</code>接口，因此我们不能使用<code>@Input</code>注解。这不是问题，因为<code>TemplateData</code>内部是一个字符串和具有可序列化类型参数的hash表，它们都是可序列化的，并且可以使用<code>@Input</code>注解。我们使用<code>@Nested</code>注解表明该值是嵌套的输入属性。</p></li>

<li><p><code>outputDir</code></p>

<p>代表生成文件的目录。对于输入文件，有若干注解用于输出文件和目录。一个代表单个目录的属性需要<code>@OutputDeirectory</code>。</p></li>
</ul>

<p>这些注解属性意味着，如果没有源文件、模板引擎、模型数据或者生成文件发生改变，那么Gradle会跳过任务的执行。</p>

<h2 id="运行时api">运行时API</h2>

<p>自定义任务类是增量构建的一种简便的方式，但你并不是总有这种选项。这就是为什么Gradle也提供了可选的API，可以应用到任意任务。</p>

<p>当你不能访问一个自定义任务类的源代码时，不能像前面一样添加注解。Gradle提供了运行时API用于这样的场景中。它也可以用于临时（ad-hoc）任务。</p>

<h3 id="运用到临时任务">运用到临时任务</h3>

<p>运行时API使用了一些合适命名的属性用于Gradle任务：</p>

<ul>
<li><code>Task.getInputs()</code>对应<code>TaskInputs</code></li>
<li><code>Task.getOutputs()</code>对应<code>TaskOutputs</code></li>
<li><code>Task.getDestroyables()</code>对应<code>TaskDestroyables</code></li>
</ul>

<p>这些对象的方法允许你指定为输入和输出作出贡献的文件、目录和值。实际上，运行时API提供了注解的绝大多数特性。唯一缺少的是声明实际的文件和目录。如果输出目录不存在那么它也不能创建，就是这样。</p>

<p>build.gradle</p>

<pre><code class="language-groovy">task processTemplatesAdHoc {
    inputs.property(&quot;engine&quot;, TemplateEngineType.FREEMARKER)
    inputs.files(fileTree(&quot;src/templates&quot;))
    inputs.property(&quot;templateData.name&quot;, &quot;docs&quot;)
    inputs.property(&quot;templateData.variables&quot;, [year: 2013])
    outputs.dir(&quot;$buildDir/genOutput2&quot;)

    doLast {
        // Process the templates here
    }
}
</code></pre>

<p>和前面一样，没有太多需要讲解的。首先，你应当有一个对应自定义的任务类，因为它有一些配置选项。这种情况下，没有任务属性来存储根源目录、输出目录的位置或其它设置。这是故意为之的，运行时API不需要任务有任何状态。从增量构建来讲，上面的临时任务的行为和自定义任务类是一样的。</p>

                </div>
                
            </article>
        </div>
    </div>

                </div>
                <footer>
    Powered by <a target="_blank" href="https://gohugo.io/">Hugo</a> And 
    <a target="_blank" href="https://pages.github.com/">Github Pages</a>
</footer>
                <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
                

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.3.5/jquery.fancybox.min.css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.3.5/jquery.fancybox.min.js"></script>

                <link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.12.0/styles/default.min.css">
                <script src="/js/highlight.pack.js"></script>
                <script src="https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js"></script>
                <script type="text/javascript" async src="https://cdn.bootcss.com/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [
                ['$', '$'],
                ['\\(', '\\)']
            ],
            displayMath: [
                ['$$', '$$']
            ],
            processEscapes: true,
            processEnvironments: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            TeX: {
                equationNumbers: {
                    autoNumber: "AMS"
                },
                extensions: ["AMSmath.js", "AMSsymbols.js"]
            }
        }
    });
    MathJax.Hub.Queue(function () {



        var all = MathJax.Hub.getAllJax(),
            i;
        for (i = 0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });

    MathJax.Hub.Config({

        TeX: {
            equationNumbers: {
                autoNumber: "AMS"
            }
        }
    });
</script>
                <script type="text/javascript" src="/js/main.js"></script>
        </div>
    </body>

</html>