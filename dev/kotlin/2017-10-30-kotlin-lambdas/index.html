<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

<title>
  
     Kotlin高阶函数与Lambdas | 
    风格与布局
  
</title><meta name="description" content="Android移动应用开发"><meta name="author" content="jastrelax">

<link rel="apple-touch-icon" href="/apple-touch-icon.png" sizes="180x180">
<link rel="icon" href="/favicon-32x32.png " sizes="32x32" type="image/png">
<link rel="icon" href="/favicon-16x16.png" sizes="16x16" type="image/png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#0c344b">
<link rel="icon" href="/favicon.ico">




    
        
            <link rel="stylesheet" href="/dist/main.37ab3f61b95417873748.min.css">
        
    




<link rel="canonical" href="https://www.androidpi.com/dev/kotlin/2017-10-30-kotlin-lambdas/"><meta property="og:title" content="Kotlin高阶函数与Lambdas" />
<meta property="og:description" content="参考： Lambdas 高阶函数 一个高阶函数接收函数作为其参数，或者返回一个函数。举个栗子，如下所示，lock()函数接收一个lock对象和一个函数，获取锁" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.androidpi.com/dev/kotlin/2017-10-30-kotlin-lambdas/" />
<meta property="article:published_time" content="2017-10-30T16:34:18+08:00" />
<meta property="article:modified_time" content="2017-10-30T16:34:18+08:00" />
<meta itemprop="name" content="Kotlin高阶函数与Lambdas">
<meta itemprop="description" content="参考： Lambdas 高阶函数 一个高阶函数接收函数作为其参数，或者返回一个函数。举个栗子，如下所示，lock()函数接收一个lock对象和一个函数，获取锁">
<meta itemprop="datePublished" content="2017-10-30T16:34:18&#43;08:00" />
<meta itemprop="dateModified" content="2017-10-30T16:34:18&#43;08:00" />
<meta itemprop="wordCount" content="2110">



<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Kotlin高阶函数与Lambdas"/>
<meta name="twitter:description" content="参考： Lambdas 高阶函数 一个高阶函数接收函数作为其参数，或者返回一个函数。举个栗子，如下所示，lock()函数接收一个lock对象和一个函数，获取锁"/>

</head>
<body>
    
<nav class="navbar navbar-expand-md navbar-light bg-light fixed-top shadow-sm" id="navbar-main-menu">
    <div class="container">
        <a class="navbar-brand font-weight-bold" href="https://www.androidpi.com/">风格与布局</a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#main-menu" aria-controls="main-menu" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="main-menu">
            <ul class="navbar-nav ml-auto">
                
                    <li class="nav-item"><a class="nav-link" href="/android/">Android</a></li>
                
                    <li class="nav-item"><a class="nav-link" href="/blockchain/">Blockchain</a></li>
                
                    <li class="nav-item"><a class="nav-link" href="/book/">Books</a></li>
                
                    <li class="nav-item"><a class="nav-link" href="/cs/">CS</a></li>
                
                    <li class="nav-item"><a class="nav-link" href="/ee/">EE</a></li>
                
                    <li class="nav-item"><a class="nav-link" href="/java/">Java</a></li>
                
                    <li class="nav-item"><a class="nav-link" href="/puzzles/">Puzzles</a></li>
                
                    <li class="nav-item"><a class="nav-link" href="/web/">Web</a></li>
                
                    <li class="nav-item"><a class="nav-link" href="/backend/">后端</a></li>
                
                    <li class="nav-item"><a class="nav-link" href="/engineering/">工程与架构</a></li>
                
                    <li class="nav-item"><a class="nav-link" href="/dev/">开发</a></li>
                
            
            </ul>
        </div>
    </div>
</nav>


    
<main class="content-page container pt-7 pb-5">
    <div class="row">
        <div class="col">
            <article>
                <div class="row justify-content-center">
                    <div class="col-lg-8">
                        <h2 class="mb-3">Kotlin高阶函数与Lambdas</h2>

                        <div class="content">
                            <p>参考：</p>
<ul>
<li><a href="https://kotlinlang.org/docs/reference/lambdas.html">Lambdas</a></li>
</ul>
<h2 id="高阶函数">高阶函数</h2>
<p>一个高阶函数接收函数作为其参数，或者返回一个函数。举个栗子，如下所示，lock()函数接收一个lock对象和一个函数，获取锁，运行函数，然后释放锁：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">    <span style="color:#66d9ef">fun</span> &lt;T&gt; <span style="color:#a6e22e">lock</span>(lock: Lock, body: () -&gt; T): T {
        lock.lock()
        <span style="color:#66d9ef">try</span> {
            <span style="color:#66d9ef">return</span> body()
        }
        <span style="color:#66d9ef">finally</span> {
            lock.unlock()
        }
    }
</code></pre></div><p>body有一个<a href="https://kotlinlang.org/docs/reference/lambdas.html#function-types">函数类型</a>：() -&gt; T，它是一个返回类型为T的值的方法。</p>
<p>如果我们想调用lock()，我们可以将另一个函数作为参数传递给它（参考：<a href="https://kotlinlang.org/docs/reference/reflection.html#function-references">方法引用</a>):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">    <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">toBeSynchronized</span>() = sharedResource.operation()

    <span style="color:#66d9ef">val</span> result = lock(lock, <span style="color:#f92672">::</span>toBeSynchronized)
</code></pre></div><p>此外，一个更加便捷的方式是传递一个<a href="https://kotlinlang.org/docs/reference/lambdas.html#lambda-expressions-and-anonymous-functions">lambda表达式</a>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">    <span style="color:#66d9ef">val</span> result = lock(lock, { sharedResource.operation() })
</code></pre></div><p>Lambda表达式先简要介绍下，后面小节会有详细描述：</p>
<ul>
<li>一个lambda表达式总是由花括弧包围</li>
<li>它的参数在记号<code>-&gt;</code>前声明，参数类型可以忽略</li>
<li>正文跟在<code>-&gt;</code>后</li>
</ul>
<p>在Kotlin中如果一个函数的最后一个参数是一个函数，并且使用lambda表达式传递对应的参数，有一个简便的方式来表示，即将lambda表达式放在函数参数列表括弧外：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">    lock (lock) {
        sharedResource.operation()
    }
</code></pre></div><p>另一个例子，如下map()函数所示：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">    <span style="color:#66d9ef">fun</span> &lt;T, R&gt; <span style="color:#a6e22e">List</span>&lt;T&gt;.map(transform: (T) -&gt; R): List&lt;R&gt; {
        <span style="color:#66d9ef">val</span> result = arrayListOf&lt;R&gt;()
        <span style="color:#66d9ef">for</span> (item <span style="color:#66d9ef">in</span> <span style="color:#66d9ef">this</span>)
            result.add(transform(item))
        <span style="color:#66d9ef">return</span> result
    }
</code></pre></div><p>该函数可以如下调用：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">    <span style="color:#66d9ef">val</span> doubled = ints.map { value -&gt; value * <span style="color:#ae81ff">2</span> }
</code></pre></div><p><em>语法糖</em></p>
<blockquote>
<p>如果lambda表达式是函数的唯一参数，那么参数括弧也可以省略。</p>
<p>另一个惯用法是，如果函数仅有一个参数，该参数的声明（以及后面的<code>-&gt;</code>）可以忽略，并使用<code>it</code>代表该参数：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">    ints.map { it * <span style="color:#ae81ff">2</span> }
</code></pre></div><p>它允许编写<a href="http://msdn.microsoft.com/en-us/library/bb308959.aspx">LINQ样式</a>的代码：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">    strings.filter { it.length == <span style="color:#ae81ff">5</span> }.sortedBy { it }.map { it.toUpperCase() }
</code></pre></div><p>如果lambda参数未使用，你可以使用一个下划线声明：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">    map.forEach { _, value -&gt; println(<span style="color:#e6db74">&#34;$value!&#34;</span>) }
</code></pre></div></blockquote>
<h2 id="lambda表达式与匿名函数">Lambda表达式与匿名函数</h2>
<p>一个lambda表达式或匿名函数是一个“函数字面量（function literal）”，也就是未声明的函数，作为表达式直接传递。考虑如下例子：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">    max(strings, { a, b -&gt; a.length &lt; b.length })
</code></pre></div><p>函数max是一个高阶函数，它接收一个函数值作为第二个参数，第二个参数是自身为函数的一个表达式，也就是函数字面量。作为一个函数，它等价于：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">    <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">compare</span>(a: String, b: String): Boolean = a.length &lt; b.length
</code></pre></div><h3 id="函数类型">函数类型</h3>
<p>为了让一个函数接收另一个函数作为参数，必须为接收的参数指定一个函数类型，上面的例子中，max的定义如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">    <span style="color:#66d9ef">fun</span> &lt;T&gt; <span style="color:#a6e22e">max</span>(collection: Collection&lt;T&gt;, less: (T, T) -&gt; Boolean): T? {
        <span style="color:#66d9ef">var</span> max: T? = <span style="color:#66d9ef">null</span>
        <span style="color:#66d9ef">for</span> (it <span style="color:#66d9ef">in</span> collection)
            <span style="color:#66d9ef">if</span> (max == <span style="color:#66d9ef">null</span> || less(max, it))
                max = it
        <span style="color:#66d9ef">return</span> max
    }
</code></pre></div><p>参数less的类型是<code>(T, T) -&gt; Boolean</code>，即一个接收两个类型为T的参数并返回一个Boolean值的函数，它的行为是如果第一个参数小于第二个参数就返回true。</p>
<p>函数类型中的参数可以命名：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">    <span style="color:#66d9ef">val</span> compare: (x: T, y: T) -&gt; Int = ...
</code></pre></div><p>如果声明了一个可以为空的函数类型变量，将函数类型用括弧包围并加一个问号：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">    <span style="color:#66d9ef">var</span> sum: ((Int, Int) -&gt; Int)? = <span style="color:#66d9ef">null</span>
</code></pre></div><h3 id="lambda表达式语法">Lambda表达式语法</h3>
<p>Lambda表达式的完整语法形式如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">    <span style="color:#66d9ef">val</span> sum = { x: Int, y: Int -&gt; x + y }
</code></pre></div><p>一个Lambda表达式总是使用花括弧包围，参数声明在花括号中，可以有可选的类型标识，正文跟在右箭头符号<code>-&gt;</code>后。如果推断出lambda返回类型不是Unit，那么最后一个表达式就是返回值。</p>
<p>如果将可选的标识移到外面，可以表示如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">    <span style="color:#66d9ef">val</span> sum: (Int, Int) -&gt; Int = { x, y -&gt; x + y }
</code></pre></div><p>我们可以使用<a href="https://kotlinlang.org/docs/reference/returns.html#return-at-labels">限定的return</a>语法从lambda中显式地返回一个值，否则会返回最后一个表达式的值，下面两种表示是等价的：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">    ints.filter {
        <span style="color:#66d9ef">val</span> shouldFilter = it &gt; <span style="color:#ae81ff">0</span> 
        shouldFilter
    }

    ints.filter {
        <span style="color:#66d9ef">val</span> shouldFilter = it &gt; <span style="color:#ae81ff">0</span> 
        <span style="color:#66d9ef">return</span>@filter shouldFilter
    }
</code></pre></div><h3 id="匿名函数">匿名函数</h3>
<p>上面的lambda表达式中不能指定函数的返回类型，大多数情况下，可以进行自动推断。然而，如果你想特别指定，可以使用匿名函数：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">    <span style="color:#66d9ef">fun</span>(x: Int, y: Int): Int = x + y

    <span style="color:#66d9ef">fun</span>(x: Int, y: Int): Int {
        <span style="color:#66d9ef">return</span> x + y
    }
</code></pre></div><p>参数和返回类型的指定和常规函数一样，除了一点以外，即匿名函数参数类型如果可以从上下文中推断出，那么可以将其忽略：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">    ints.filter(<span style="color:#66d9ef">fun</span>(item) = item &gt; <span style="color:#ae81ff">0</span>)
</code></pre></div><p>匿名函数和lambda表达式的不同之处在于它不能作为括弧外参数传递，此外，两者的<a href="https://kotlinlang.org/docs/reference/inline-functions.html#non-local-returns">非局部返回(non-local returns)</a>行为也不一样，一个无标签的return总是从fun声明的函数内返回，这表明lambda表达式中的return会从包围函数返回，而匿名函数会从自身返回。</p>
<h3 id="闭包closures">闭包（Closures）</h3>
<p>一个lambda表达式或者匿名函数（以及局部函数和对象表达式）可以访问其闭包，也就是在外部范围声明的变量。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">    <span style="color:#66d9ef">var</span> sum = <span style="color:#ae81ff">0</span>
    ints.filter { it &gt; <span style="color:#ae81ff">0</span> }.forEach {
        sum += it
    }
    print(sum)
</code></pre></div><h3 id="带接收器的函数字面量">带接收器的函数字面量</h3>
<p>Kotlin允许用一个指定的接收对象调用一个函数字面量。在函数字面量的正文中，你可以直接调用接收对象的方法。这有点类似扩展函数，它允许你在函数体重访问接收对象的成员。</p>
<p>这种类型的函数字面量是一个带接收器的函数类型：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">    sum : Int.(other: Int) -&gt; Int
</code></pre></div><p>函数字面量可以像接受对象的成员一样进行调用：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">    <span style="color:#ae81ff">1.</span>sum(<span style="color:#ae81ff">2</span>)
</code></pre></div><p>你们函数语法允许你直接指定一个函数字面量的接收器类型。如果你需要声明一个带接收器的函数类型变量，这就十分有用：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">    <span style="color:#66d9ef">val</span> sum = <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">Int</span>.(other: Int): Int = <span style="color:#66d9ef">this</span> + other
</code></pre></div><p>对于一个带接收器函数类型的非字面量值，在一个接收常规函数作为参数的地方并且该常规函数类型第一个参数与该值的接收器类型一样，那么该值可以作为参数传递，反之亦然。例如，类型<code>String.(Int) -&gt; Boolean</code>和<code>(String, Int) -&gt; Boolean</code>是兼容的：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">    <span style="color:#66d9ef">val</span> represents: String.(Int) -&gt; Boolean = { other -&gt; toIntOrNull() == other }
    println(<span style="color:#e6db74">&#34;123&#34;</span>.represents(<span style="color:#ae81ff">123</span>)) <span style="color:#75715e">// true
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">testOperation</span>(op: (String, Int) -&gt; Boolean, a: String, b: Int, c: Boolean) =
        assert(op(a, b) == c)
        
    testOperation(represents, <span style="color:#e6db74">&#34;100&#34;</span>, <span style="color:#ae81ff">100</span>, <span style="color:#66d9ef">true</span>) <span style="color:#75715e">// OK
</span></code></pre></div><p>当接收器类型可以从上下文中推断出时，Lambda表达式可以用作带接收器的函数字面量：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">HTML</span> {
        <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">body</span>() { ... }
    }

    <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">html</span>(init: HTML.() -&gt; Unit): HTML {
        <span style="color:#66d9ef">val</span> html = HTML()  <span style="color:#75715e">// create the receiver object
</span><span style="color:#75715e"></span>        html.init()        <span style="color:#75715e">// pass the receiver object to the lambda
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> html
    }


    html {       <span style="color:#75715e">// lambda with receiver begins here
</span><span style="color:#75715e"></span>        body()   <span style="color:#75715e">// calling a method on the receiver object
</span><span style="color:#75715e"></span>    }
</code></pre></div>
                        </div>
                    </div>
                </div>
            </article>
        </div>
    </div>
</main>


    <footer class="footer text-center bg-dark py-6">
    <div class="container">
        <div class="row">
            <div class="col">
                <ul class="list-inline">
                    
                </ul>

                <p class="text-muted">
                    
                        Copyright &copy; 风格与布局 2020
                    
                </p>

                <p class="text-muted">
                Powered by <a href="https://gohugo.io" target="_blank">Hugo</a> with <a href="https://github.com/puresyntax71/hugo-theme-chunky-poster" target="_blank">Chunky Poster</a>.
                </p>

                <p class="text-muted">
                    <a href="http://beian.miit.gov.cn" target="_blank">蜀ICP备18005659号-1</a>
                </p>
            
            </div>
        </div>
    </div>
</footer>

    
    
        
            <script src="/dist/main.d608eadfe5ac0688902e.min.js"></script>
        
    








    
</body>
</html>
