<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta lang="zh"/>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title>
            
    ViewModel与savedInstanceState &ndash; DevNote

        </title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" type="text/css" media="screen" href="/css/main.css" />
        
    <link rel="stylesheet" type="text/css" media="screen" href="/css/article.css" />

    </head>

    <body>
        <header>
    <a href="https://www.jastrelax.com/">DevNote</a>
</header>
        
    <div class="main">
        <div class="article">
            <article>
                <div class="title">
                    <h1 id="title">ViewModel与savedInstanceState</h1>
                </div>
                <div class="content">
                        

<h2 id="在activity或fragment的onsaveinstancestate方法中保存ui状态">在Activity或Fragment的onSaveInstanceState方法中保存UI状态</h2>

<p>如果一个Activity没有直接退出，而是通过按下Home键或跳转到其它Activity或者其它应用的Activity，使其处于后台不可见的状态，那么系统可能会销毁该Activity，或者由于配置改变导致Activity自动被销毁并重建了，那么在销毁前会调用<code>onSaveInstanceState</code>来保存视图状态，对于带有布局id的视图组件，会自动保存其状态。也可以自定义需要保存的数据，在重新回到该Activity时，即便Activity的实例被重建了，也可以恢复保存的UI状态和自定义的数据。</p>

<p>既然处于后台的Activity实例被销毁了，那么这部分可以被恢复的数据保存在哪里呢？通过阅读AMS（Activity Manager Service）的源码可以发现，AMS负责管理四大组件，并且Activity的状态是通过任务与回退栈进行管理的，即使后台Activity实例被销毁了，但其记录还没有从任务栈中弹出，保存的状态仍然位于任务栈中。通过在开发者模式下设置“不保留活动”，并使用adb查看任务栈，也可以看到这一点：
<img src="/assets/images/android/destroy-activity.png" alt="destroy activity when leave" /></p>

<pre><code class="language-bash">$ adb shell dumpsys activity activities
</code></pre>

<p>需要注意的是，状态保存在任务栈的记录中，它由AMS管理，在恢复状态时传入的状态数据是以Binder IPC的方式进行的，因此这种方式不适合保存大的数据，否则会抛出<code>TransactionTooLargeException</code>异常，其文档中描述为一个进程共享的Binder缓存大小为1Mb。</p>

<h2 id="在viewmodel中保存ui状态">在ViewModel中保存UI状态</h2>

<p>在<a href="https://developer.android.com/topic/libraries/architecture/viewmodel.html">Android架构组件ViewModel</a>的说明中的第一段概括是：<a href="https://developer.android.com/reference/android/arch/lifecycle/ViewModel.html">ViewModel</a>类的设计意图是以一种感知生命周期的方式来保存和管理UI相关的数据，它可以使数据存活于配置变化，例如屏幕旋转。</p>

<p>这个ViewModel不管从命名上还是作用上都是与MVVM架构中的VM相吻合的，当然也可以用于其它架构中，其主要目的是与UI控制器进行解耦，其中UI Controller直接操作视图，一般指包含操作视图逻辑的Activity和Fragment。其类文档中也明确说明：
&gt; ViewModel&rsquo;s only responsibility is to manage the data for the UI. It should never access your view hierarchy or hold a reference back to the Activity or the Fragment.</p>

<!-- more -->

<p>但其实现并不复杂，使用一个抽象工厂，在一个ViewModel需要将其生命周期绑定到一个Activity或者Fragment时，调用<code>ViewModelProviders.of(activity|fragment, viewModelFactory).get(viewModelClass)</code>即可，通过查看源码可以发现，它实例化了一个<code>ViewModelProvider</code>，在获取<code>ViewModel</code>时它首先从内部的<code>ViewModelStore</code>进行查询，如果有便直接返回已有的，如果没有便创建一个新的实例，并放入<code>ViewModelStore</code>中保存。</p>

<p>因此为了使ViewModel具有感知生命周期和存活于配置变化，这个<code>ViewModelStore</code>也必须具有同等的功能，通过<code>ViewModelStores.of(activity|fragment)</code>调用可以发现，它原来是由ViewModel需要绑定的Activity或Fragment的一个<code>HolderFragment</code>所持有的，并且这个<code>HolderFragment</code>在初始化时是设置为保留实例的，因此这个<code>HolderFragment</code>在配置改变时不会重新创建实例，它有一个固定的tag，在获取已有的一个<code>HolderFragment</code>实例时，由于最初将<code>HolderFragment</code>实例提交到需要绑定的Activity或Fragment的FragmentManager时提交事务并不是立即发生的，可能提交没有成功，那么使用这个tag从FragmentManager中取不到这个已有的实例，因此<code>HolderFragment</code>内还有一个静态的<code>HolderFragmentManager</code>将这个已有的实例添加到了一个Map中，当从FragmentManager中查询失败时就从这个静态变量中查询。</p>

<pre><code class="language-java">public class HolderFragment extends Fragment {
    // ...
    private static final HolderFragmentManager sHolderFragmentManager = new HolderFragmentManager();

    public static final String HOLDER_TAG =
            &quot;android.arch.lifecycle.state.StateProviderHolderFragment&quot;;

    private ViewModelStore mViewModelStore = new ViewModelStore();

    public HolderFragment() {
        setRetainInstance(true);
    }
    // ...
}
</code></pre>

<p>因此所谓ViewModel的生命周期，实际上就是Activity的创建-配置改变-销毁，以及Fragment的创建-销毁。</p>

<p><img src="/assets/images/android/viewmodel-lifecycle.png" alt="ViewModel生命周期" /></p>

<h2 id="问题-后台进程被销毁了-viewmodel也被回收-视图数据丢失了">问题：后台进程被销毁了，ViewModel也被回收，视图数据丢失了！</h2>

<p>采用官方建议的方式来使用<code>ViewModel</code>，<code>NewsViewModel</code>维护获取到的新闻列表，采用<code>LiveData</code>提供的观察者模式，<code>NewsFragment</code>根据<code>NewsViewModel</code>的数据更新界面，如果配置改变（旋转屏幕等）或者处于后台的进程被系统回收，此时返回应用使其回到前台，这里不希望重新请求数据，此时<code>ononViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState)</code>中的<code>savedInstanceState</code>非空，只有第一次进入界面时<code>savedInstanceState</code>为空，可以据此仅在第一次进入界面时加载第一页的新闻。</p>

<pre><code class="language-java">public class NewsFragment extends Fragment{

    @Inject
    NewsViewModel mNewsModel;

    @Inject
    ViewModelProvider.Factory mViewModelFactory;

    // ...
    // extra fields

    public void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        mNewsModel = ViewModelProviders.of(this, mViewModelFactory)
                .get(NewsViewModel.class);
    }

    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);
        mNewsModel.mNews.observe(this, new Observer(){
            public void onChanged(@Nullable List&lt;News&gt; newsList) {
                // update ui
                // ...
            }
        });
        // 判断是否保存过Fragment状态
        if (null == savedInstanceState) {
            loadFirstPage();
        }
    }

    public void loadFirstPage() {
        mNewsModel.loadFirstPage();
    }
}
</code></pre>

<p>采用这种方式，在配置改变时可以正常工作，不会重新加载数据，已有的数据会直接进行加载。但如果界面未退出并且处于后台时，一旦Activity被系统销毁，那么返回时，ViewModel被重新创建，数据丢失，此时判断<code>savedInstanceState</code>不为空，也不会重新请求并加载数据，结果是界面未正常展示数据。</p>

<p>这说明ViewModel保存的数据可以存活于配置改变，但不能存活于系统强制销毁。这里便需要搞清楚，配置改变下Activity被销毁与系统强制销毁有什么区别。</p>

<h2 id="fragmentmanager如何初始化以及如何保留fragment实例">FragmentManager如何初始化以及如何保留Fragment实例</h2>

<p>前面的分析可以知道，<code>ViewModel</code>通过绑定的Activity或Fragment所管理的<code>HolderFragment</code>来保存实例，并存活于配置改变的过程。因此需要分析为什么配置改变时这个Fragment实例可以保留，而系统销毁不可以，因为两种情况下所在Activity都被销毁过一次。</p>

<pre><code class="language-java">public final class ActivityThread {
    // ...
    private ActivityClientRecord performDestroyActivity(IBinder token, boolean finishing, int configChanges, boolean getNonConfigInstance) {
        // ...
        if (getNonConfigInstance) {
            try {
                r.lastNonConfigurationInstances
                        = r.activity.retainNonConfigurationInstances();
            } catch (Exception e) {
                if (!mInstrumentation.onException(r.activity, e)) {
                    throw new RuntimeException(
                            &quot;Unable to retain activity &quot;
                            + r.intent.getComponent().toShortString()
                            + &quot;: &quot; + e.toString(), e);
                }
            }
        }
        // ...
    }
    // ...
}
</code></pre>

<p>因此可以得知被保留实例的Fragment存在主线程的<code>ActivityClientRecord</code>记录中。</p>

<p>那么便可以解释两种情况的不同之处了，一种情况类似上述在开发者选项中开启不保留活动，那么进入后台的Activity及其Fragment都会被强制销毁，走完剩余的生命周期，<code>HolderFragment</code>实例不会被保留在主线程中。</p>

<p>另一种情况便是应用进程被系统销毁了，以便于回收内存等资源。一般根据<a href="https://developer.android.com/guide/components/processes-and-threads.html?hl=zh-cn">Android系统进程优先级</a>:</p>

<ol>
<li>前台进程</li>
<li>可见进程</li>
<li>服务进程</li>
<li>后台进程</li>
<li>空进程</li>
</ol>

<p>当应用处于不可见状态时，如果系统进行强制回收，那么通常情况下并不会仅仅回收某一部分资源，而是杀死整个进程，那么一旦进程退出，Activity的静态变量也被回收，这种情况下<code>HolderFragment</code>和其管理的<code>ViewModel</code>的实例便无从保留了。</p>

<h2 id="总结">总结</h2>

<p>关于Activity和Fragment视图状态的保存，官方文档建议使用<code>ViewModel</code>来保存UI相关状态，但这种方案建立在已有的在配置改变中保留实例的<code>HolderFragment</code>上，它并没有带来关于视图状态保存完美解决方案，一旦需要考虑应用在后台被销毁的情况，还是应该通过运行或绑定Service提升应用进程优先级，并且采用已有的<code>onSaveInstanceState()</code>方案解决。</p>

                </div>
                
            </article>
            <aside>
                <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#在activity或fragment的onsaveinstancestate方法中保存ui状态">在Activity或Fragment的onSaveInstanceState方法中保存UI状态</a></li>
<li><a href="#在viewmodel中保存ui状态">在ViewModel中保存UI状态</a></li>
<li><a href="#问题-后台进程被销毁了-viewmodel也被回收-视图数据丢失了">问题：后台进程被销毁了，ViewModel也被回收，视图数据丢失了！</a></li>
<li><a href="#fragmentmanager如何初始化以及如何保留fragment实例">FragmentManager如何初始化以及如何保留Fragment实例</a></li>
<li><a href="#总结">总结</a></li>
</ul></li>
</ul>
</nav>
            </aside>
        </div>
    </div>

        <footer>
    Powered by <a target="_blank" href="https://gohugo.io/">Hugo</a>
</footer>
        <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
        


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.3.5/jquery.fancybox.min.css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.3.5/jquery.fancybox.min.js"></script>

        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css">
        <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
        <script src="https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js"></script>
        <script type="text/javascript" async src="https://cdn.bootcss.com/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [
                ['$', '$'],
                ['\\(', '\\)']
            ],
            displayMath: [
                ['$$', '$$']
            ],
            processEscapes: true,
            processEnvironments: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            TeX: {
                equationNumbers: {
                    autoNumber: "AMS"
                },
                extensions: ["AMSmath.js", "AMSsymbols.js"]
            }
        }
    });
    MathJax.Hub.Queue(function () {



        var all = MathJax.Hub.getAllJax(),
            i;
        for (i = 0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });

    MathJax.Hub.Config({

        TeX: {
            equationNumbers: {
                autoNumber: "AMS"
            }
        }
    });
</script>
        <script type="text/javascript" src="/js/main.js"></script>
    </body>

</html>