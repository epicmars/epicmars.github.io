<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta lang="zh"/>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title>
            
    Android应用构建：流程与配置 &ndash; DevNote

        </title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" type="text/css" media="screen" href="/css/main.css" />
        <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.0/css/solid.css" integrity="sha384-TbilV5Lbhlwdyc4RuIV/JhD8NR+BfMrvz4BL5QFa2we1hQu6wvREr3v6XSRfCTRp" crossorigin="anonymous">
        <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.0/css/brands.css" integrity="sha384-7xAnn7Zm3QC1jFjVc1A6v/toepoG3JXboQYzbM0jrPzou9OFXm/fY6Z/XiIebl/k" crossorigin="anonymous">
        <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.0/css/fontawesome.css" integrity="sha384-ozJwkrqb90Oa3ZNb+yKFW2lToAWYdTiF1vt8JiH5ptTGHTGcN7qdoR1F95e0kYyG" crossorigin="anonymous">
        
    <link rel="stylesheet" type="text/css" media="screen" href="/css/article.css" />

    </head>

    <body>
        <header>
    <a href="https://www.jastrelax.com/">DevNote</a>
</header>
        
    <div class="main">
        <div class="article">
            <article>
                <div class="title">
                    <h1 id="title">Android应用构建：流程与配置</h1>
                </div>
                <div class="content">
                        

<h2 id="构建总体流程">构建总体流程</h2>

<p>Android 构建系统编译应用资源和源代码，然后将它们打包成可供您测试、部署、签署和分发的 APK。
如图 1 所示，典型 Android 应用模块的构建流程通常依循下列步骤：</p>

<ol>
<li><p>编译器将您的源代码转换成 DEX（Dalvik Executable) 文件（其中包括运行在 Android 设备上的字节码），将所有其他内容转换成已编译资源。</p></li>

<li><p>APK 打包器将 DEX 文件和已编译资源合并成单个 APK。不过，必须先签署 APK，才能将应用安装并部署到 Android 设备上。</p></li>

<li><p>APK 打包器使用调试或发布密钥库签署您的 APK：</p>

<p>a. 如果您构建的是调试版本的应用（即专用于测试和分析的应用），打包器会使用调试密钥库签署您的应用。Android Studio 自动使用调试密钥库配置新项目。</p>

<p>b. 如果您构建的是打算向外发布的发布版本应用，打包器会使用发布密钥库签署您的应用。要创建发布密钥库，请阅读在 Android Studio 中签署您的应用。</p></li>

<li><p>在生成最终 APK 之前，打包器会使用 zipalign 工具对应用进行优化，减少其在设备上运行时的内存占用。</p></li>
</ol>

<p><img src="/assets/images/android/build/build-process.png" alt="构建流程" /></p>

<blockquote>
<p>图 1 构建流程</p>
</blockquote>

<h2 id="构建配置">构建配置</h2>

<p>Android中主要使用构建类型、产品风味、构建变体对构建进行配置：</p>

<ul>
<li><p>构建类型</p>

<p>构建类型定义 Gradle 在构建和打包您的应用时使用的某些属性，通常针对开发生命周期的不同阶段进行配置。例如，调试构建类型支持调试选项，使用调试密钥签署 APK；而发布构建类型则可压缩、混淆 APK 以及使用发布密钥签署 APK 进行分发。您必须至少定义一个构建类型才能构建应用 - Android Studio 默认情况下会创建调试和发布构建类型。要开始为应用自定义打包设置，请学习如何配置构建类型。</p></li>

<li><p>产品风味</p>

<p>产品风味代表您可以发布给用户的不同应用版本，例如免费和付费的应用版本。您可以将产品风味自定义为使用不同的代码和资源，同时对所有应用版本共有的部分加以共享和重复利用。产品风味是可选项，并且您必须手动创建。要开始创建不同的应用版本，请学习如何配置产品风味。</p>

<p>不同产品风味可以根据纬度进行组织，维度之间是相互独立的，因此在最终生成的构建变体中，不同维度的产品风味相互组合，其中每个构建变体中都包含不同维度的一种产品风味。</p></li>

<li><p>构建变体</p>

<p>构建变体是构建类型与产品风味的交叉产物，是 Gradle 在构建应用时使用的配置。您可以利用构建变体在开发时构建产品风味的调试版本，或者构建已签署的产品风味发布版本进行分发。您并不直接配置构建变体，而是配置组成变体的构建类型和产品风味。创建附加构建类型或产品风味也会创建附加构建变体。要了解如何创建和管理构建变体，请阅读配置构建变体概览。</p></li>
</ul>

<p>其中构建变体并不是一种新的配置，而是按照特定规则集合并构建类型和产品风味配置中的设置、代码、资源的结果。具体的规则参考下面的原集构建规则。</p>

<h3 id="源集">源集</h3>

<p>Android Studio 按逻辑关系将每个模块的源代码和资源分组为源集。模块的 main/ 源集包括其所有构建变体共用的代码和资源。其他源集目录为可选项，在您配置新的构建变体时，Android Studio 不会自动为您创建这些目录。不过，创建类似于 main/ 的源集有助于让 Gradle 只应在构建特定应用版本时使用的文件和资源井然有序：</p>

<p><code>src/main/</code></p>

<p>此源集包括所有构建变体共用的代码和资源。</p>

<p><code>src/&lt;buildType&gt;/</code></p>

<p>创建此源集可加入特定构建类型专用的代码和资源。</p>

<p><code>src/&lt;productFlavor&gt;/</code></p>

<p>创建此源集可加入特定产品风味专用的代码和资源。</p>

<p><code>src/&lt;productFlavorBuildType&gt;/</code></p>

<p>创建此源集可加入特定构建变体专用的代码和资源。</p>

<p>例如，要生成应用的“完整调试”版本，构建系统需要合并来自以下源集的代码、设置和资源：</p>

<p><code>src/fullDebug/</code>（构建变体源集）</p>

<p><code>src/debug/</code>（构建类型源集）</p>

<p><code>src/full/</code>（产品风味源集）</p>

<p><code>src/main/</code>（主源集）</p>

<p>如果不同源集包含同一文件的不同版本，Gradle 将按以下优先顺序决定使用哪一个文件（左侧源集替换右侧源集的文件和设置）：</p>

<blockquote>
<p>构建变体 &gt; 构建类型 &gt; 产品风味 &gt; 主源集 &gt; 库依赖项</p>
</blockquote>

<h3 id="使用源集构建">使用源集构建</h3>

<p>您可以使用源集目录包含您希望仅针对某些配置打包的代码和资源。例如，如果您要构建“演示调试”构建变体（它是“演示”产品风味和“调试”构建类型的合体），Gradle 会查看这些目录并赋予以下优先级顺序：</p>

<p>src/demoDebug/（构建变体源集）</p>

<p>src/debug/（构建类型源集）</p>

<p>src/demo/（产品风味源集）</p>

<p>src/main/（主源集）</p>

<blockquote>
<p>注：如果您组合多个产品风味，产品风味之间的优先级将由它们所属的风味维度决定。在列示具有 android.flavorDimensions 属性的风味维度时，所列示的第一个风味维度中的产品风味比第二个维度中的产品风味拥有更高的优先级，以此类推。此外，与属于各个产品风味的源集相比，您为产品风味组合创建的源集拥有更高的优先级。</p>
</blockquote>

<p>上面列出的顺序决定了在 Gradle 合并代码和资源时哪个源集具有较高的优先级。由于 demoDebug/ 源集目录很可能包含特定于该构建变体的文件，如果 demoDebug/ 包含在 debug/ 中也有定义的文件，Gradle 将使用 demoDebug/ 源集中的文件。同样，Gradle 会为构建类型和产品风味源集中的文件赋予比 main/ 中相同文件更高的优先级。Gradle 在应用以下构建规则时会考虑此优先级顺序：</p>

<ul>
<li>一起编译 java/ 目录中的所有源代码以生成单一的输出。</li>
</ul>

<blockquote>
<p>注：对于给定的构建变体，如果找到两个或两个以上定义同一 Java 类的源集目录，Gradle 就会引发一个构建错误。例如，在构建调试 APK 时，您不能同时定义 src/debug/Utility.java 和 src/main/Utility.java。这是因为 Gradle 会在构建过程中检查这两个目录并引发“duplicate class”错误。如果针对不同的构建类型需要不同版本的 Utility.java，您可以让每个构建类型定义其自己的文件版本，而不将其包含在 main/ 源集中。</p>
</blockquote>

<ul>
<li><p>所有清单合并为单个清单。将按照上述列表中的相同顺序指定优先级。也就是说，某个构建类型的清单设置会替换某个产品风味的清单设置，依此类推。如需了解更多信息，请阅读合并清单。</p></li>

<li><p>同样，values/ 目录中的文件也会合并在一起。如果两个文件同名，例如存在两个 strings.xml 文件，将按照上述列表中的相同顺序指定优先级。也就是说，在构建类型源集中的文件中定义的值将会替换产品风味中同一文件中定义的值，依此类推。</p></li>

<li><p>res/ 和 asset/ 目录中的资源将打包到一起。如果两个或两个以上的源集中定义有同名资源，将按照上述列表中的相同顺序指定优先级。</p></li>

<li><p>最后，在构建 APK 时，Gradle 会为随库模块依赖项包含的资源和清单分配最低的优先级</p></li>
</ul>

<h2 id="构建工具与流程详解">构建工具与流程详解</h2>

<h3 id="android-sdk-build-tools">Android SDK Build-Tools</h3>

<p>Android SDK构建工具是Android SDK提供的一个用于构建Android应用的组件。从SDK目录下<code>&lt;sdk&gt;/build-tools/</code> 可以查看其包含的工具集：</p>

<p><img src="/assets/images/android/build/build-tools.png" alt="构建工具" /></p>

<p>构建流程的详细情况如下所示：</p>

<p><img src="/assets/images/android/build/build-with-command.png" alt="构建流程详情" /></p>

<h3 id="资源打包与合并工具aapt-android-asset-packaging-tool">资源打包与合并工具aapt(Android Asset Packaging Tool)</h3>

<p>编译应用时，aapt 会生成 R 类，其中包含您的 res/ 目录中所有资源的资源 ID。 每个资源类型都有对应的 R 子类（例如，R.drawable 对应于所有可绘制对象资源），而该类型的每个资源都有对应的静态整型数（例如，R.drawable.icon）。这个整型数就是可用来检索资源的资源 ID。</p>

<ul>
<li>资源合并（Resource merging）</li>
</ul>

<p>最终的APK文件中的资源有3种来源：</p>

<blockquote>
<ol>
<li>主要来源集（一般位于<code>src/main/res/</code>）</li>
<li>构建变体源集</li>
<li>Android库（AAR）</li>
</ol>
</blockquote>

<p>当所有从这3个来源的资源都是唯一的时，它们全部被添加到最终APK中。一个资源具有唯一性的条件是其文件名在<a href="https://developer.android.com/guide/topics/resources/available-resources.html" target="_blank">资源类型(resource type)</a>目录和<a href="https://developer.android.com/guide/topics/resources/providing-resources.html#AlternativeResources" target="_blank">资源限定符(resource qualifier)</a>的限定下具有唯一性。</p>

<p>如果匹配到同一资源的多个版本，那么只有一个会包含到最终的APK中。构建工具根据以下从左到右优先级递减的顺序进行选择：</p>

<blockquote>
<p>构建变体  &gt;  构建类型    &gt;   产品风味    &gt;  主源集     &gt;   库引用</p>
</blockquote>

<p>例如，如果主源集包含：</p>

<pre><code>    res/layout/foo.xml
    res/layout-land/foo.xml
</code></pre>

<p>构建类型包含：</p>

<pre><code>    res/layout/foo.xml
</code></pre>

<p>那么最终APK会包含debug构建类型中的<code>res/layout/foo.xml</code>以及主源集中的<code>res/layout-land/foo.xml</code>。</p>

<h3 id="源代码编译javac-desuger-dx">源代码编译javac/desuger/dx</h3>

<p>在去年Android官方发布公告<a href="https://android-developers.googleblog.com/2017/03/future-of-java-8-language-feature.html" target="_blank">Future of Java8 Language Feature Support on Android</a>表示，为了支持Java8，考虑到对注解处理器、字节码分析器和代码重构器的影响，迁移到Jack对社区的成本过高，Android 6.0–8.1的默认编译工具链Jack将被弃用。</p>

<p>目前对Java8的支持采用默认工具链，即在原来<strong>javac/dx</strong>工具链基础上加入了<strong>desugar</strong>，默认工具链对 javac 编译器的输出执行字节码转换（称为 desugar），从而实现新语言功能。如下图所示：</p>

<p><img src="/assets/images/android/build/desugar.png" alt="采用 desugar 字节码转换的 Java 8 语言功能支持" /></p>

<p>要开始使用受支持的 Java 8 语言功能，请更新 Android 插件到 3.0.0（或更高版本）。 然后，针对使用（包括在源代码中或通过依赖项使用）Java 8 语言功能的每个模块，在其 build.gradle 文件中添加以下代码：</p>

<pre><code class="language-java">    android {
        ...
        // Configure only for each module that uses Java 8
        // language features (either in its source code or
        // through dependencies).
        compileOptions {
            sourceCompatibility JavaVersion.VERSION_1_8
            targetCompatibility JavaVersion.VERSION_1_8
        }
    }
</code></pre>

<h2 id="jarsigner">jarsigner</h2>

<h2 id="aapt与aapt2">aapt与aapt2</h2>

<h2 id="zipalign">zipalign</h2>

<h2 id="apksigner">apksigner</h2>

<ol>
<li><p>打开命令行，然后导航至项目的根目录 - 在 Android Studio 中，选择 View &gt; Tool Windows &gt; Terminal。然后调用 assembleRelease 任务：</p>

<pre><code>gradlew assembleRelease
</code></pre>

<p>这将在 <code>project_name/module_name/build/outputs/apk/</code> 中创建一个名为 <code>module_name-unsigned.apk</code> 的 APK。此 APK 此时处于未签署且未对齐的状态，使用您的私钥签署后才能安装。</p></li>

<li><p>使用 zipalign 对齐未签署的 APK：</p>

<pre><code>zipalign -v -p 4 my-app-unsigned.apk my-app-unsigned-aligned.apk
</code></pre>

<p>zipalign 可以确保所有未压缩的数据的开头均相对于文件开头部分执行特定的字节对齐，这样可减少应用消耗的 RAM 量。</p></li>

<li><p>通过 apksigner 使用您的私钥签署 APK：</p>

<pre><code>apksigner sign --ks my-release-key.jks --out my-app-release.apk my-app-unsigned-aligned.apk
</code></pre>

<p>在本例中，在使用单密钥库文件 my-release-key.jks 中存储的私钥和证书签署 APK 后，将以 my-app-release.apk 的形式输出签署的 APK。</p>

<p>apksigner 工具支持其他签署选项，包括使用单独的私钥和证书文件签署 APK 文件和使用多个签署人签署 APK。有关更多详情，请参阅 apksigner 参考。</p>

<blockquote>
<p>注：要使用 apksigner 工具，您必须已安装 Android SDK Build Tool 的修订版 24.0.3 或更高版本。您可以使用 SDK 管理器更新此软件包。</p>
</blockquote></li>

<li><p>验证您的 APK 是否已签署：</p>

<pre><code>apksigner verify my-app-release.apk
</code></pre></li>
</ol>

<h2 id="参考">参考</h2>

<ul>
<li><a href="https://docs.oracle.com/javase/tutorial/deployment/jar/signing.html" target="_blank">jarsigner</a></li>
<li><a href="https://developer.android.com/studio/command-line/zipalign?hl=zh-cn" target="_blank">zipalign</a></li>
<li><a href="https://developer.android.com/studio/command-line/apksigner?hl=zh-cn" target="_blank">apksigner</a></li>
<li><a href="https://developer.android.com/studio/releases/gradle-plugin" target="_blank">Android Plugin for Gradle</a></li>
<li><a href="https://developer.android.com/studio/build/?hl=zh-cn" target="_blank">配置构建</a></li>
<li><a href="https://developer.android.com/studio/build/build-variants" target="_blank">配置构建变体</a></li>
<li><a href="https://developer.android.com/studio/command-line/" target="_blank">命令行工具</a></li>
<li><a href="https://developer.android.com/studio/publish/app-signing" target="_blank">签署您的应用</a></li>
<li><a href="https://developer.android.com/studio/write/java8-support" target="_blank">使用 Java 8 语言功能</a></li>
<li><a href="https://developer.android.com/studio/releases/build-tools" target="_blank">SDK Build Tools release notes</a></li>
<li><a href="https://github.com/dogriffiths/HeadFirstAndroid/wiki/How-Android-Apps-are-Built-and-Run" target="_blank">How Android Apps are Built and Run</a></li>
<li><a href="https://source.android.com/devices/tech/dalvik/" target="_blank">ART 和 Dalvik</a></li>
<li><a href="http://ct2wj.com/2015/12/31/dex-source-analysis-in-android-compile-tasks/" target="_blank">android compile tasks中dex过程源码情景分析</a></li>
<li><a href="https://tech.meituan.com/mt-android-auto-split-dex.html" target="_blank">美团Android DEX自动拆包及动态加载简介</a></li>
<li><a href="https://developer.android.com/studio/write/add-resources#resource_merging" target="_blank">Add app resources</a></li>
<li><a href="https://developer.android.com/studio/projects/android-library" target="_blank">创建 Android 库</a></li>
</ul>

                </div>
                
            </article>
            <aside>
                <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#构建总体流程">构建总体流程</a></li>
<li><a href="#构建配置">构建配置</a>
<ul>
<li><a href="#源集">源集</a></li>
<li><a href="#使用源集构建">使用源集构建</a></li>
</ul></li>
<li><a href="#构建工具与流程详解">构建工具与流程详解</a>
<ul>
<li><a href="#android-sdk-build-tools">Android SDK Build-Tools</a></li>
<li><a href="#资源打包与合并工具aapt-android-asset-packaging-tool">资源打包与合并工具aapt(Android Asset Packaging Tool)</a></li>
<li><a href="#源代码编译javac-desuger-dx">源代码编译javac/desuger/dx</a></li>
</ul></li>
<li><a href="#jarsigner">jarsigner</a></li>
<li><a href="#aapt与aapt2">aapt与aapt2</a></li>
<li><a href="#zipalign">zipalign</a></li>
<li><a href="#apksigner">apksigner</a></li>
<li><a href="#参考">参考</a></li>
</ul></li>
</ul>
</nav>
            </aside>
        </div>
    </div>

        <footer>
    Powered by <a target="_blank" href="https://gohugo.io/">Hugo</a>
</footer>
        <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
        


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.3.5/jquery.fancybox.min.css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.3.5/jquery.fancybox.min.js"></script>

        <link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.12.0/styles/vs2015.min.css">
        <script src="//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
        <script src="https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js"></script>
        <script type="text/javascript" async src="https://cdn.bootcss.com/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [
                ['$', '$'],
                ['\\(', '\\)']
            ],
            displayMath: [
                ['$$', '$$']
            ],
            processEscapes: true,
            processEnvironments: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            TeX: {
                equationNumbers: {
                    autoNumber: "AMS"
                },
                extensions: ["AMSmath.js", "AMSsymbols.js"]
            }
        }
    });
    MathJax.Hub.Queue(function () {



        var all = MathJax.Hub.getAllJax(),
            i;
        for (i = 0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });

    MathJax.Hub.Config({

        TeX: {
            equationNumbers: {
                autoNumber: "AMS"
            }
        }
    });
</script>
        <script type="text/javascript" src="/js/main.js"></script>
    </body>

</html>