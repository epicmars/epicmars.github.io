<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" >
        <meta lang="zh">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title>Android面试 | 风格与布局</title>
<meta name="description" content="Android 四大组件 对Context的理解 关于一个应用环境的全局接口。用于访问特定应用的资源和类，以及各种应用级别的操作，如启动Activities与">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" type="text/css" media="screen" href="/css/main.css" />
        <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.0/css/solid.css" integrity="sha384-TbilV5Lbhlwdyc4RuIV/JhD8NR+BfMrvz4BL5QFa2we1hQu6wvREr3v6XSRfCTRp" crossorigin="anonymous">
        <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.0/css/brands.css" integrity="sha384-7xAnn7Zm3QC1jFjVc1A6v/toepoG3JXboQYzbM0jrPzou9OFXm/fY6Z/XiIebl/k" crossorigin="anonymous">
        <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.0/css/fontawesome.css" integrity="sha384-ozJwkrqb90Oa3ZNb+yKFW2lToAWYdTiF1vt8JiH5ptTGHTGcN7qdoR1F95e0kYyG" crossorigin="anonymous">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet">
        
    <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet">
    <link rel="stylesheet" type="text/css" media="screen" href="/css/article.css" />

    </head>

    <body>
        <div class="site-wrapper">
                <header>
    <nav>
        <a class="home" href="https://www.androidpi.com/">首页</a>
    </nav>
    
</header>
                <div class="site-main">
                    
    <div class="main">
        <div class="article">
            <aside>
                    <nav id="TableOfContents">
  <ul>
    <li><a href="#android">Android</a>
      <ul>
        <li><a href="#四大组件">四大组件</a></li>
        <li><a href="#view">View</a></li>
        <li><a href="#handler机制与messagequeue">Handler机制与MessageQueue</a></li>
        <li><a href="#其它">其它</a></li>
        <li><a href="#组件化">组件化</a></li>
        <li><a href="#serializable和parcelable的区别">Serializable和Parcelable的区别</a></li>
      </ul>
    </li>
    <li><a href="#java">Java</a>
      <ul>
        <li><a href="#aop">AOP</a></li>
        <li><a href="#java语言与面向对象编程">Java语言与面向对象编程</a></li>
        <li><a href="#泛型">泛型</a></li>
        <li><a href="#集合">集合</a></li>
        <li><a href="#多线程">多线程</a></li>
        <li><a href="#jvm">JVM</a></li>
        <li><a href="#其它-1">其它</a></li>
      </ul>
    </li>
    <li><a href="#软件工程理论与实践">软件工程理论与实践</a>
      <ul>
        <li><a href="#面向对象编程">面向对象编程</a></li>
        <li><a href="#设计模式与app架构">设计模式与APP架构</a></li>
      </ul>
    </li>
    <li><a href="#网络与协议">网络与协议</a>
      <ul>
        <li><a href="#http">HTTP</a></li>
        <li><a href="#https">HTTPS</a></li>
        <li><a href="#osi七层模型">OSI七层模型</a></li>
        <li><a href="#tcpip五层模型">TCP/IP五层模型</a></li>
        <li><a href="#tcpip">TCP/IP</a></li>
      </ul>
    </li>
    <li><a href="#算法与数据结构">算法与数据结构</a>
      <ul>
        <li><a href="#算法">算法</a></li>
        <li><a href="#数据结构">数据结构</a></li>
      </ul>
    </li>
    <li><a href="#操作系统">操作系统</a></li>
    <li><a href="#数据库">数据库</a>
      <ul>
        <li><a href="#关系型数据库">关系型数据库</a></li>
        <li><a href="#非关系型数据库">非关系型数据库</a></li>
      </ul>
    </li>
    <li><a href="#密码学">密码学</a></li>
  </ul>
</nav>
            </aside>
            <article>
                <div class="title">
                    <h1 id="title">Android面试</h1>
                </div>
                <div class="content">
                        <h2 id="android">Android</h2>
<h3 id="四大组件">四大组件</h3>
<ul>
<li>
<p>对Context的理解
关于一个应用环境的全局接口。用于访问特定应用的资源和类，以及各种应用级别的操作，如启动Activities与Service，发送广播与注册广播接收器，接收Intents。获取系统服务等等。</p>
</li>
<li>
<p>Fragment生命周期</p>
<ul>
<li>onAttach与onDetach，首先将Fragment与Activity进行关联</li>
<li>onCreate与onDestory，创建实例，如果设置了setRetainInstance(true)那么不会调用到此处</li>
<li>onCreateView与onDestoryView，创建视图</li>
<li>onActivityCreated，对用户界面最后调整的地方</li>
<li>onStart与onStop</li>
<li>onResume与onPause
注意： 调用show()和hide()时，Fragment的生命周期方法不会被执行。调用replace()和add()会执行onAttach()到onResume()的生命周期</li>
</ul>
</li>
<li>
<p>Activity启动模式
启动模式允许您定义 Activity 的新实例如何与当前任务关联。 您可以通过两种方法定义不同的启动模式：</p>
<ul>
<li>
<p>&ldquo;standard&rdquo;（默认模式）</p>
<p>默认。系统在启动 Activity 的任务中创建 Activity 的新实例并向其传送 Intent。Activity 可以多次实例化，而每个实例均可属于不同的任务，并且一个任务可以拥有多个实例。</p>
</li>
<li>
<p>&ldquo;singleTop&rdquo;</p>
<p>如果当前任务的顶部已存在 Activity 的一个实例，则系统会通过调用该实例的 onNewIntent() 方法向其传送 Intent，而不是创建 Activity 的新实例。Activity 可以多次实例化，而每个实例均可属于不同的任务，并且一个任务可以拥有多个实例（但前提是位于返回栈顶部的 Activity 并不是 Activity 的现有实例）。</p>
<p>例如，假设任务的返回栈包含根 Activity A 以及 Activity B、C 和位于顶部的 D（堆栈是 A-B-C-D；D 位于顶部）。收到针对 D 类 Activity 的 Intent。如果 D 具有默认的 &ldquo;standard&rdquo; 启动模式，则会启动该类的新实例，且堆栈会变成 A-B-C-D-D。但是，如果 D 的启动模式是 &ldquo;singleTop&rdquo;，则 D 的现有实例会通过 onNewIntent() 接收 Intent，因为它位于堆栈的顶部；而堆栈仍为 A-B-C-D。但是，如果收到针对 B 类 Activity 的 Intent，则会向堆栈添加 B 的新实例，即便其启动模式为 &ldquo;singleTop&rdquo; 也是如此。</p>
<p>注：为某个 Activity 创建新实例时，用户可以按“返回”按钮返回到前一个 Activity。 但是，当 Activity 的现有实例处理新 Intent 时，则在新 Intent 到达 onNewIntent() 之前，用户无法按“返回”按钮返回到 Activity 的状态。</p>
</li>
<li>
<p>&ldquo;singleTask&rdquo;</p>
<p>系统创建新任务并实例化位于新任务底部的 Activity。但是，如果该 Activity 的一个实例已存在于一个单独的任务中，则系统会通过调用现有实例的 onNewIntent() 方法向其传送 Intent，而不是创建新实例。一次只能存在 Activity 的一个实例。</p>
<p>注：尽管 Activity 在新任务中启动，但是用户按“返回”按钮仍会返回到前一个 Activity。</p>
</li>
<li>
<p>&ldquo;singleInstance&rdquo;</p>
<p>与 &ldquo;singleTask&rdquo; 相同，只是系统不会将任何其他 Activity 启动到包含实例的任务中。该 Activity 始终是其任务唯一仅有的成员；由此 Activity 启动的任何 Activity 均在单独的任务中打开。</p>
</li>
</ul>
</li>
<li>
<p>简述Activity启动流程</p>
<p>使用AMS的Binder通信代理ActivityManagerProxy通知AMS启动activity，如果要启动的activity的应用还未启动，则从Zygote进程分叉一个新的应用进程，并启动主线程即ActivityThread，当主线程启动完毕后通过AMP来通知AMS协调activity任务栈与activity的生命周期状态。然后AMS通过ApplicationThreadProxy与应用进程主线程进行通信，根据需要实例化Application和Activity，然后调用activity的生命周期方法回调。</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Binder IPC机制</p>
<ol>
<li>采用客户端/服务器模型进行进程间通信</li>
<li>远程代理来访问服务，Stub是本地Binder对象，Proxy是Binder代理，都实现了IBinder接口。</li>
</ol>
<ul>
<li>与系统服务交互，如ActivityManagerService，Client进程，Server进程，ServiceManager进程之间都通过Binder驱动进行交互</li>
<li>Client和Server在交互中，通过各自所提供的Binder代理</li>
<li>在绑定远程Service过程中，Binder服务代理对象通过AMS进行传递。</li>
</ul>
<p>Android系统启动后，启动了
Android系统中存在大量系统服务，构成Android框架的基础，是Android系统的核心组成部分。</p>
<ol>
<li>性能</li>
<li>稳定性</li>
<li>安全</li>
</ol>
</li>
<li>
<p>启动Service两种方式</p>
<ul>
<li>启动
当应用组件（如 Activity）通过调用 startService() 启动服务时，服务即处于“启动”状态。一旦启动，服务即可在后台无限期运行，即使启动服务的组件已被销毁也不受影响。 已启动的服务通常是执行单一操作，而且不会将结果返回给调用方。例如，它可能通过网络下载或上传文件。 操作完成后，服务会自行停止运行。</li>
<li>绑定
当应用组件通过调用 bindService() 绑定到服务时，服务即处于“绑定”状态。绑定服务提供了一个客户端-服务器接口，允许组件与服务进行交互、发送请求、获取结果，甚至是利用进程间通信 (IPC) 跨进程执行这些操作。 仅当与另一个应用组件绑定时，绑定服务才会运行。 多个组件可以同时绑定到该服务，但全部取消绑定后，该服务即会被销毁。</li>
</ul>
</li>
<li>
<p>Service类型</p>
<p>根据运行状态：</p>
<ul>
<li>前台服务：必须显示一个状态栏图标</li>
<li>后台服务</li>
</ul>
<p>根据启动类型分为：</p>
<ul>
<li>启动服务</li>
<li>绑定服务</li>
</ul>
</li>
<li>
<p>静态广播接收器与动态广播接收器
两者生命周期不一样
动态广播优先级更高</p>
</li>
<li>
<p>广播的分类</p>
<ul>
<li>普通广播：完全是异步的。所有接收器以一种未知的顺序处理广播，通常是同时处理。</li>
<li>有序广播：一次传递给一个接收器。每个接收器轮流执行，它可以将一个结果传给下一个接收器，或者它可以完全终止广播使得广播不会被传递给其它接收器。可以使用匹配过滤器的android:priority属性来控制接收器运行的顺序，具有相同优先级的接收器的顺序是任意的。</li>
<li>粘性广播：需要“android.permission.BROADCAST_STICKY”权限。粘性广播的数据由系统所持有，使得客户端可以不用等待下次发送广播时再进行接收。Context.sendStickyBroadcast()在API21中认为是不安全的(任何人都可以访问)，没有任何保护(任何人都可以修改)，已被弃用。</li>
</ul>
</li>
<li>
<p>性能优化</p>
<ul>
<li>速度优化
使用CPU剖析工具查看线程运行和方法执行时间</li>
</ul>
<ul>
<li>
<p>内存优化</p>
<ul>
<li>了解GC</li>
<li>内存泄露</li>
<li>使用Android Studio的内存剖析工具，进行各种操作并查看内存抖动，使用内存分配追踪器追踪对象来源，使用堆快照分析堆中对象分配</li>
<li>使用Proguard压缩代码，使用shrinkResources选项压缩资源</li>
</ul>
</li>
<li>
<p>电量使用优化
分析电量使用情况，一般持续打开屏幕，使用网络和GPS等功能会带来较大的的电量消耗</p>
<ul>
<li>在不唤醒屏幕的情况下进行后台操作，或者使用带超时操作的唤醒屏幕，或者将唤醒屏幕的操作尽可能批量处理。</li>
<li>尽可能将定期执行的网络请求批量处理</li>
<li>使用Job Scheduler处理后台任务</li>
</ul>
</li>
<li>
<p>渲染优化
CPU负责Measure，Layout，Record，Execute的计算操作，GPU负责Rasterization(栅格化)操作。</p>
</li>
</ul>
<p>Resterization栅格化是绘制那些Button，Shape，Path，String，Bitmap等组件最基础的操作。它把那些组件拆分到不同的像素上进行显示。这是一个很费时的操作，GPU的引入就是为了加快栅格化的操作。</p>
<p>CPU负责把UI组件计算成Polygons，Texture纹理，然后交给GPU进行栅格化渲染。
- 过度绘制：移除布局中非必要的Background</p>
<ul>
<li>其它优化技巧
<ul>
<li>使用内存优化的集合，如SparseArray等</li>
<li>注意Bitmap的内存占用和内存泄露的问题</li>
</ul>
</li>
</ul>
<ul>
<li>布局优化
<ul>
<li>布局复用，使用include</li>
<li>减少布局嵌套层级，如使用merge</li>
<li>在需要时才加载布局，使用ViewStub</li>
</ul>
</li>
</ul>
</li>
<li>
<p>屏幕适配</p>
<ul>
<li>
<p>术语</p>
<ul>
<li>
<p>屏幕尺寸
按屏幕对角测量的实际物理尺寸。
为简便起见，Android 将所有实际屏幕尺寸分组为四种通用尺寸：小、 正常、大和超大。</p>
</li>
<li>
<p>屏幕密度
屏幕物理区域中的像素量；通常称为 dpi（每英寸 点数）。例如， 与“正常”或“高”密度屏幕相比，“低”密度屏幕在给定物理区域的像素较少。
为简便起见，Android 将所有屏幕密度分组为六种通用密度： 低、中、高、超高、超超高和超超超高。</p>
</li>
<li>
<p>方向
从用户视角看屏幕的方向，即横屏还是 竖屏，分别表示屏幕的纵横比是宽还是高。请注意， 不仅不同的设备默认以不同的方向操作，而且 方向在运行时可随着用户旋转设备而改变。</p>
</li>
<li>
<p>分辨率
屏幕上物理像素的总数。添加对多种屏幕的支持时， 应用不会直接使用分辨率；而只应关注通用尺寸和密度组指定的屏幕 尺寸及密度。</p>
</li>
<li>
<p>密度无关像素 (dp)
在定义 UI 布局时应使用的虚拟像素单位，用于以密度无关方式表示布局维度 或位置。
密度无关像素等于 160 dpi 屏幕上的一个物理像素，这是 系统为“中”密度屏幕假设的基线密度。在运行时，系统 根据使用中屏幕的实际密度按需要以透明方式处理 dp 单位的任何缩放 。dp 单位转换为屏幕像素很简单： px = dp * (dpi / 160)。 例如，在 240 dpi 屏幕上，1 dp 等于 1.5 物理像素。在定义应用的 UI 时应始终使用 dp 单位 ，以确保在不同密度的屏幕上正常显示 UI。</p>
</li>
</ul>
</li>
<li>
<p>适配不同像素密度</p>
<ul>
<li>使用密度无关像素dp与sp</li>
<li>使用资源文件夹的密度限定符来提供备用位图</li>
</ul>
</li>
<li>
<p>支持不同屏幕尺寸</p>
<ul>
<li>为确保您的布局能够灵活地适应不同的屏幕尺寸，您应该为某些视图组件的宽度和高度使用 &ldquo;wrap_content&rdquo; 和 &ldquo;match_parent&rdquo;。</li>
<li>使用RelativeLayout和约束布局</li>
<li>使用资源文件夹的尺寸限定符来针对不同屏幕尺寸提供不同的布局，最小宽度限定符</li>
<li>使用布局别名</li>
<li>使用屏幕方向限定符</li>
<li>自适应位图，即.9格式或九宫格位图</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="view">View</h3>
<ul>
<li>
<p>事件分发机制
将一个动作(鼠标、手写笔、触摸、轨迹球)事件MotionEvent进行分发过程，目的是将产生的动作事件分发给特定的对象进行消费。分发的层级由上至下从Activity到Window再到View。</p>
<ul>
<li>Activity事件分发，如果Window未分发事件则直接由Activity的onTouchEvent()消费</li>
<li>Window事件分发，Window的实现类为PhoneWindow，PhoneWindow将事件直接传递给顶级DecorView进行分发。</li>
<li>View事件分发
<ul>
<li>ViewGroup事件分发
<ul>
<li>不拦截事件，事件将沿着View层次嵌套结构继续向下分发，直到事件被消费。如果向下分发过程中事件未被消费，则事件将沿着原来的传递路径向上传递，直到事件被消费。</li>
<li>事件被拦截，将由拦截事件的ViewGroup来消费事件，如果未消费将事件向上传递，直到被消费。</li>
<li>拦截检查逻辑
<ol>
<li>每次接收到ACTION_DOWN事件，mFirstTouchTarget会置为空，FLAG_DISALLOW_INTERCEPT标志位被重置，ViewGroup总是调用onInterceptTouchEvent()来判断是否进行拦截。因此如果ACTION_DOWN被拦截，那么后续其它事件不会向下分发，mFirstTouchTarget为null，那么后续非ACTION_DOWN事件都会被拦截，由它自身来处理。</li>
<li>如果ACTION_DOWN未被拦截，那么mFirstTouchTarget不为空，对于后续其它事件，子View通过调用ViewParent的requestDisallowInterceptTouchEvent()方法来控制对onInterceptTouchEvent()的调用。如果后续某个事件被拦截，子View会接收到ACTION_CANCEL事件，该事件后续事件将由拦截该事件的ViewGroup来消费。如果未拦截，则按照正常分发流程处理。</li>
</ol>
</li>
</ul>
</li>
<li>常规View事件分发与消费
如果OnTouchListener不为空并且enabled为true，事件由OnTouchListener消费，否则由onTouchEvent消费。如果OnTouchListener的onTouch方法返回false，事件将也由onTouchEvent消费。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>View滑动冲突以及如何解决</p>
<ul>
<li>滑动冲突场景
<ul>
<li>外部滑动方向与内部滑动方向不一致</li>
<li>外部滑动方向与内部滑动方向一致</li>
<li>上述两种情况的嵌套</li>
</ul>
</li>
<li>解决方式
<ul>
<li>外部拦截法，重写父布局的onInterceptTouchEvent方法</li>
<li>内部拦截法，重写子View的dispatchTouchEvent方法</li>
</ul>
</li>
</ul>
</li>
<li>
<p>View绘制流程
ViewRootImpl调用performTraversal来进入绘制流程。</p>
<ul>
<li>
<p>测量</p>
<p>从顶层DecorView开始进行测量，父布局需要先测量出子视图的大小，根据视图层次递归地进行这一过程，其中父布局通过传入自己的测量规格和子View自身的布局参数来计算自身测量规格（DecorView的测量规格是根据其所在Window的布局参数和其自身布局参数计算得到的），然后将这一测量规格沿着布局层次向下传递，知道所有子视图完成对自身的测量，然后父布局计算并设置自身的测量结果。</p>
</li>
<li>
<p>布局</p>
<p>测量结束后，父布局根据子视图的大小及布局参数将View放到布局中合适的位置</p>
</li>
<li>
<p>绘制</p>
<ol>
<li>绘制背景</li>
<li>绘制View内容</li>
<li>分发绘制事件，以绘制子视图</li>
<li>绘制其它内容，渐变效果，绘制装饰</li>
</ol>
</li>
</ul>
</li>
<li>
<p>Activity中何时可以获取view的长宽，为什么</p>
</li>
<li>
<p>MeasureSpec的理解</p>
<p>用于从上往下将测量需求从父级推给子级。<code>MeasureSpec</code>可以有如下三种模式：</p>
<ul>
<li><code>UNSPECIFIED</code>：一个父视图可以用他来确定一个子<code>View</code>所期望的尺寸。例如，一个<code>LinearLayout</code>可以在其子视图上调用<code>measure()</code>，其中将高度设置为<code>UNSPECIFIED</code>并且宽度设置为<code>EXACTLY</code> <code>240</code>来找出给定一个<code>240</code>像素的宽度时，子视图期望有多高。</li>
<li><code>EXACTLY</code>：用于父视图给子视图施加一个确定的尺寸。子视图必须使用该尺寸，并且保证它所有的后代视图都是符合该尺寸限制的。</li>
<li><code>AT_MOST</code>：用于父视图给子视图施加一个最大的尺寸。子视图必须保证它以及其所有的后代都符合该尺寸的限制。</li>
</ul>
</li>
<li>
<p>View渲染机制</p>
</li>
<li>
<p>在View外部获取View宽高的三种方式</p>
<ul>
<li>onWindowFocusChanged(在onResume之后调用，已经完成View的绘制)</li>
<li>view.post(Runnable)</li>
<li>ViewTreeObserver</li>
</ul>
</li>
<li>
<p>为什么使用SurfaceView，与View的区别
SurfaceView可以独立于普通View进行更新，也就是不使用主线程进行更新，方便进行快速的视图刷新。</p>
</li>
</ul>
<h3 id="handler机制与messagequeue">Handler机制与MessageQueue</h3>
<ul>
<li>为什么UI不采用多线程模型，多线程模型中存在一个死锁和竞态条件的趋势。UI的输入事件可能来自上层的应用层，也可能来自下层的系统层，各个层中分别使用了不同的锁，那么就极易出现死锁和资源的竞争，造成ANR或者界面响应卡顿。</li>
<li>UI的单线程模型，是一种事件驱动的单线程模型，更适用于UI的运行</li>
<li>Handler通过在UI线程内建立一个消息循环队列，接收来自各个层面的输入事件，通过消息队列为事件建立优先级顺序，可以避免多线程模型中的同步问题，并且提供了一种更简单清晰的UI模型。</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">LooperThread</span> <span style="color:#66d9ef">extends</span> Thread <span style="color:#f92672">{</span>
      <span style="color:#66d9ef">public</span> Handler mHandler<span style="color:#f92672">;</span>

      <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
          Looper<span style="color:#f92672">.</span><span style="color:#a6e22e">prepare</span><span style="color:#f92672">();</span>

          mHandler <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Handler<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
              <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">handleMessage</span><span style="color:#f92672">(</span>Message msg<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                  <span style="color:#75715e">// process incoming messages here
</span><span style="color:#75715e"></span>              <span style="color:#f92672">}</span>
          <span style="color:#f92672">};</span>

          Looper<span style="color:#f92672">.</span><span style="color:#a6e22e">loop</span><span style="color:#f92672">();</span>
      <span style="color:#f92672">}</span>
  <span style="color:#f92672">}</span>
</code></pre></div><p>消息队列的建立使用<code>Looper</code>来完成，它持有一个<code>ThreadLocal</code>的<code>Looper</code>，而<code>Handler</code>构造函数正是利用了这一特性，这样只要是在UI线程创建的<code>Handler</code>，其<code>Looper</code>默认持有的是UI线程的<code>MessageQueue</code>。<code>MessageQueue</code>中<code>Message</code>是根据时间戳进行排序的。</p>
<h3 id="其它">其它</h3>
<ul>
<li>
<p>Android中内存管理机制
在内存不足的情况下，Android系统会根据进程优先级，终止优先级较低的进程来回收部分内存。系统会根据进程中正在运行的组件以及这些组件的状态，将每个进程放入“重要性层次结构”中。 必要时，系统会首先消除重要性最低的进程，然后是重要性略逊的进程，依此类推，以回收系统资源。</p>
<p>重要性层次结构一共有 5 级。以下列表按照重要程度列出了各类进程（第一个进程最重要，将是最后一个被终止的进程）：</p>
<ol>
<li>
<p>前台进程</p>
<p>用户当前操作所必需的进程。如果一个进程满足以下任一条件，即视为前台进程：</p>
<ul>
<li>托管用户正在交互的 Activity（已调用 Activity 的 onResume() 方法）</li>
<li>托管某个 Service，后者绑定到用户正在交互的 Activity</li>
<li>托管正在“前台”运行的 Service（服务已调用 startForeground()）</li>
<li>托管正执行一个生命周期回调的 Service（onCreate()、onStart() 或 onDestroy()）</li>
<li>托管正执行其 onReceive() 方法的 BroadcastReceiver
通常，在任意给定时间前台进程都为数不多。只有在内存不足以支持它们同时继续运行这一万不得已的情况下，系统才会终止它们。 此时，设备往往已达到内存分页状态，因此需要终止一些前台进程来确保用户界面正常响应。</li>
</ul>
</li>
<li>
<p>可见进程</p>
<p>没有任何前台组件、但仍会影响用户在屏幕上所见内容的进程。 如果一个进程满足以下任一条件，即视为可见进程：</p>
<p>托管不在前台、但仍对用户可见的 Activity（已调用其 onPause() 方法）。例如，如果前台 Activity 启动了一个对话框，允许在其后显示上一 Activity，则有可能会发生这种情况。
托管绑定到可见（或前台）Activity 的 Service。
可见进程被视为是极其重要的进程，除非为了维持所有前台进程同时运行而必须终止，否则系统不会终止这些进程。</p>
</li>
<li>
<p>服务进程</p>
<p>正在运行已使用 startService() 方法启动的服务且不属于上述两个更高类别进程的进程。尽管服务进程与用户所见内容没有直接关联，但是它们通常在执行一些用户关心的操作（例如，在后台播放音乐或从网络下载数据）。因此，除非内存不足以维持所有前台进程和可见进程同时运行，否则系统会让服务进程保持运行状态。</p>
</li>
<li>
<p>后台进程</p>
<p>包含目前对用户不可见的 Activity 的进程（已调用 Activity 的 onStop() 方法）。这些进程对用户体验没有直接影响，系统可能随时终止它们，以回收内存供前台进程、可见进程或服务进程使用。 通常会有很多后台进程在运行，因此它们会保存在 LRU （最近最少使用）列表中，以确保包含用户最近查看的 Activity 的进程最后一个被终止。如果某个 Activity 正确实现了生命周期方法，并保存了其当前状态，则终止其进程不会对用户体验产生明显影响，因为当用户导航回该 Activity 时，Activity 会恢复其所有可见状态。 有关保存和恢复状态的信息，请参阅 Activity文档。</p>
</li>
<li>
<p>空进程</p>
<p>不含任何活动应用组件的进程。保留这种进程的的唯一目的是用作缓存，以缩短下次在其中运行组件所需的启动时间。 为使总体系统资源在进程缓存和底层内核缓存之间保持平衡，系统往往会终止这些进程。</p>
</li>
</ol>
</li>
<li>
<p>Android如何查找最佳匹配资源</p>
<p><a href="https://developer.android.com/guide/topics/resources/providing-resources.html?hl=zh-cn#BestMatch">https://developer.android.com/guide/topics/resources/providing-resources.html?hl=zh-cn#BestMatch</a></p>
</li>
<li>
<p>兼容问题</p>
<ul>
<li>compileSdkVersion编译使用的SDK版本，建议总是使用最新的SDK进行编译。</li>
<li>minSdkVersion指定与App兼容的最低API等级。</li>
<li>targetSdkVersion指定App的目标API等级，表明App已在该API等级下进行了测试。
<ul>
<li>如果设备API等级高于targetSdkVersion那么就会采用兼容模式来运行应用</li>
<li>如果设备API等级低于targetSdkVersion，需要进行版本兼容性处理，如判断运行时版本</li>
</ul>
</li>
</ul>
</li>
<li>
<p>ANR具体产生的类型有哪些，具体说下其产生的最大超时时间</p>
<ul>
<li>InputDispatching Timeout: 输入事件分发超时5s，包括按键和触摸事件</li>
<li>Service Timeout:比如前台服务在20s内未执行完成</li>
<li>BroadcastQueue Timeout：比如前台广播在10s内未执行完成</li>
<li>ContentProvider Timeout：内容提供者,在publish过超时10s
在这些事件流，会在主线程发送一个延迟的超时消息，延迟时间就是超时时间。如果在超时时间内完成了执行流程，会将超时消息从主线程的消息队列中移除。否则，接收到超时消息触发ANR弹框。</li>
</ul>
</li>
<li>
<p>常见内存泄漏情景及避免内存泄漏的措施</p>
<ol>
<li>场景
<ul>
<li>非静态内部类对象持有外部内对象的引用</li>
<li>静态变量引起的内存泄露</li>
</ul>
</li>
<li>解决方式
<ul>
<li>弱引用</li>
</ul>
</li>
</ol>
</li>
<li>
<p>怎么让自己的进程不被第三方应用杀掉，系统杀掉之后怎么能启动起来</p>
<ul>
<li>提高进程优先级，降低被杀死的概率</li>
<li>被杀死后，可以被系统重新唤起
<ul>
<li>使用启动Service，并在onStartCommand中返回START_STICKY</li>
<li>注册系统广播接收器</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Activty和Fragment之间怎么通信，Fragment和Fragment怎么通信</p>
<ul>
<li>Google文档中推荐的方式，在Fragment中定义监听器接口，Activity实现该监听器，在onAttach()中将activity注册到Fragment中。</li>
<li>使用其它方式，如EventBus、或者使用Activity实例化的ViewModel及其持有的LiveData。</li>
</ul>
</li>
<li>
<p>Service与Activity间的通信</p>
<ul>
<li>对于启动Service
<ul>
<li>Activity向Service发送消息
<ol>
<li>使用startService发送Intent</li>
<li>使用广播</li>
</ol>
</li>
<li>Service向Activity发送消息
<ol>
<li>使用广播</li>
</ol>
</li>
</ul>
</li>
<li>对于绑定Service，可以使用启动Service的所有通信方式，还可以使用:
<ol>
<li>Binder进行通信，包括跨进程通信</li>
<li>Messenger</li>
</ol>
</li>
</ul>
</li>
<li>
<p>SparseArray
作用：将整形映射到对象。
与HashMap的优势：
内存：避免整形的自动装箱，并且其数据结构不依赖与一个额外的entry对象来进行每个对象
性能：移除键值时，它将待移除键值标记为删除，而不是立即压缩数组。然后该入口可以重用于同一个键值，或者在单个垃圾回收步骤中对所有移除的入口进行回收并压缩数组。
劣势：将映射保存到一个数组中，使用一个二叉搜索来寻找键值。其实现不适用于包含大量条目的数据结构。对于一个持有数百个条目的的容器来说，其性能差别不大，不超过50%。</p>
</li>
<li>
<p>apk打包流程</p>
<ul>
<li>资源合并，生成R.java文件</li>
<li>AIDL文件转Java接口</li>
<li>源码编译</li>
<li>.class文件转.dex文件</li>
<li>已编译资源、其它资源、dex文件打包为apk文件</li>
<li>apk文件对齐与签名</li>
</ul>
</li>
<li>
<p>位图处理</p>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">calculateInSampleSize</span><span style="color:#f92672">(</span>BitmapFactory<span style="color:#f92672">.</span><span style="color:#a6e22e">Options</span> options<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> reqWidth<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> reqHeight<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">int</span> width <span style="color:#f92672">=</span> options<span style="color:#f92672">.</span><span style="color:#a6e22e">outWidth</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">int</span> height <span style="color:#f92672">=</span> options<span style="color:#f92672">.</span><span style="color:#a6e22e">outHeight</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">int</span> inSampleSize <span style="color:#f92672">=</span> 1<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>width <span style="color:#f92672">*</span> height <span style="color:#f92672">&gt;</span> reqWidth <span style="color:#f92672">*</span> reqHeight<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">int</span> halfWidth <span style="color:#f92672">=</span> width <span style="color:#f92672">/</span> 2<span style="color:#f92672">;</span>
            <span style="color:#66d9ef">int</span> halfHeight <span style="color:#f92672">=</span> height <span style="color:#f92672">/</span> 2<span style="color:#f92672">;</span>
            <span style="color:#66d9ef">while</span> <span style="color:#f92672">((</span>halfWidth <span style="color:#f92672">/</span> inSampleSize<span style="color:#f92672">)</span> <span style="color:#f92672">&gt;</span> reqWidth <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">(</span>halfHeight <span style="color:#f92672">/</span> inSampleSize<span style="color:#f92672">)</span> <span style="color:#f92672">&gt;</span> reqHeight<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                inSampleSize <span style="color:#f92672">*=</span> 2<span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
        Log<span style="color:#f92672">.</span><span style="color:#a6e22e">v</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;bitmap_sample_size&#34;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;W0:&#34;</span> <span style="color:#f92672">+</span> reqWidth <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;H0:&#34;</span> <span style="color:#f92672">+</span> reqHeight <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;, W1:&#34;</span> <span style="color:#f92672">+</span> width <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;H1:&#34;</span> <span style="color:#f92672">+</span> height <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;,SIZE:&#34;</span> <span style="color:#f92672">+</span> inSampleSize<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">return</span> inSampleSize<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><ul>
<li>减小APK体积</li>
</ul>
<p><a href="https://www.cnblogs.com/soaringEveryday/p/5254520.html">https://www.cnblogs.com/soaringEveryday/p/5254520.html</a></p>
<h3 id="组件化">组件化</h3>
<p>组件化架构分层结构：
client
业务组件  用户账号 
基础组件  多媒体播放器 网络 推送 数据库</p>
<ol>
<li>基础组件，基础公共组件搭建，SDK化</li>
<li>组件拆分，将业务拆分为独立组件，将其功能以服务形式暴露给外部使用</li>
<li>组件通信，路由与服务</li>
<li>组件管理，组件依赖</li>
</ol>
<h3 id="serializable和parcelable的区别">Serializable和Parcelable的区别</h3>
<p>Serializable序列化过程将对象通通过包围ByteArrayOutputStream的ObjectOutputStream，然后Parcel将这个对象已字节数组的形式写入到Parcel中。反序列化时则将字节数组通过包围ByteArrayInputStream的ObjectInputStream读出该对象。
Parcelable根据定义的接口直接将需要写入的字段按顺序写入，反序列化时直接根据接口实现按顺序读出。</p>
<h2 id="java">Java</h2>
<h3 id="aop">AOP</h3>
<p>注意栈帧中操作数栈和局部变量大小。</p>
<h3 id="java语言与面向对象编程">Java语言与面向对象编程</h3>
<ul>
<li>
<p>hashCode equals</p>
<p>实例的同一性使用相等符号“==”进行判断，实例的相等性判断需要重写<code>Object</code>的<code>equals</code>方法。但根据Java集合框架的约定还必须重写<code>hashCode</code>方法，它是Hash表等Hash集合计算hash值，以及判断其是否已包含某元素的依据，并且在判断是否已包含某元素时同时使用了同一性判断和相等性判断，因此二者缺一不可,不然会导致判断的不一致。例如，两个不同的实例<code>obj1</code>和<code>obj2</code>：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Sample</span> <span style="color:#f92672">{</span>
    String name<span style="color:#f92672">;</span>

    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">Sample</span><span style="color:#f92672">(</span>String name<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> name<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>Object o<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">this</span> <span style="color:#f92672">==</span> o<span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>o <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> getClass<span style="color:#f92672">()</span> <span style="color:#f92672">!=</span> o<span style="color:#f92672">.</span><span style="color:#a6e22e">getClass</span><span style="color:#f92672">())</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>

        Sample sample <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>Sample<span style="color:#f92672">)</span> o<span style="color:#f92672">;</span>

        <span style="color:#66d9ef">return</span> name <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">?</span> name<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>sample<span style="color:#f92672">.</span><span style="color:#a6e22e">name</span><span style="color:#f92672">)</span> <span style="color:#f92672">:</span> sample<span style="color:#f92672">.</span><span style="color:#a6e22e">name</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">hashCode</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> name <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">?</span> name<span style="color:#f92672">.</span><span style="color:#a6e22e">hashCode</span><span style="color:#f92672">()</span> <span style="color:#f92672">:</span> 0<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>


    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>

        Sample obj1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Sample<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;same message&#34;</span><span style="color:#f92672">);</span>
        Sample obj2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Sample<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;same message&#34;</span><span style="color:#f92672">);</span>
        HashSet<span style="color:#f92672">&lt;</span>Sample<span style="color:#f92672">&gt;</span> hashSet <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> HashSet<span style="color:#f92672">&lt;&gt;();</span>
        <span style="color:#66d9ef">assert</span> obj1 <span style="color:#f92672">!=</span> obj2<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">assert</span> obj1<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>obj2<span style="color:#f92672">);</span>

        hashSet<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>obj1<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">assert</span> hashSet<span style="color:#f92672">.</span><span style="color:#a6e22e">contains</span><span style="color:#f92672">(</span>obj1<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">assert</span> hashSet<span style="color:#f92672">.</span><span style="color:#a6e22e">contains</span><span style="color:#f92672">(</span>obj2<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div></li>
<li>
<p>四种引用类型</p>
<ul>
<li>强引用：只要强引用存在，并且该对象从GC根是可达的，那么它就不会被垃圾收集器回收</li>
<li>软引用：在内存溢出前回收</li>
<li>弱引用：在下一次GC时进行回收</li>
<li>虚引用：不对其生存时间产生影响，唯一目的是在对象被收集器回收时收到一个系统通知</li>
</ul>
</li>
<li>
<p>abstract class与interface的区别</p>
<p>相同点：</p>
<ul>
<li>不能直接实例化</li>
</ul>
<p>区别：</p>
<ul>
<li>抽象类
<ul>
<li>抽象类是类，除了声明没有实现的抽象方法，它可以有非常量域</li>
<li>子类仅可以继承一个抽象类</li>
<li>抽象方法的访问修饰符必须是<code>public</code>或<code>protected</code>的</li>
</ul>
</li>
<li>接口
<ul>
<li>接口是一个协议或者合约。使用接口，所有的域都是public,static,final的。所有声明的方法都是public的。</li>
<li>可以实现任意数量的接口</li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="https://javarevisited.blogspot.com/2016/01/9-difference-between-array-vs-arraylist-in-java.html">数组与ArrayList的区别</a></p>
<ul>
<li>数组大小是固定的</li>
<li>ArrayList是集合框架中的一个容器类，其内部是使用数组实现的，但其大小可以动态改变</li>
<li>从实现、性能、类型安全、灵活性、基本类型、泛型、迭代、维度</li>
</ul>
</li>
<li>
<p>反射的作用</p>
<p>反射支持动态获取类的信息，并利用类的信息进行相关操作。反射常用于需要对JVM中运行的应用的的运行时行为进行检测和修改的程序中。这是一个相对高级的特性，需要开发者对Java语言基础具有相当好的掌握。将这一警示牢记于心，那么reflection将会是一个相当有力的工具可以让应用完成原本无法完成的操作。</p>
<ul>
<li>
<p>扩展性特性（Extensibility Features）：一个应用可以用全称来创建扩展性对象的实例，以利用外部的、用户定义的类。</p>
</li>
<li>
<p>类浏览和可视化开发环境：一个类浏览器需要枚举类的所有成员。可视化开发环境有利于使用反射中可用的类型信息来帮助开发者编写正确的代码。</p>
</li>
<li>
<p>调试和测试工具：调试者需要能够对类的私有成员进行检测。测试人员利用反射系统地调用一个类中定义的可发现的API集，以确保测试组覆盖高级别的代码覆盖。</p>
</li>
</ul>
<p>反射的缺陷</p>
<p>反射是强大的，但不应当随意使用，如果可以不使用反射完成一项操作，那么最好就避免使用它。当使用反射来访问代码时应当将以下几点牢记：</p>
<ul>
<li>
<p>性能开销：由于反射包含了对类型的动态解析，因此某些JVM优化不会进行，这导致反射操作比其非反射的副本具有更低的性能，因此在性能敏感的引用频繁调用的代码应当避免使用反射。</p>
</li>
<li>
<p>安全限制：当运行于一个安全管理下时反射需要一个运行时许可，而该许可可能不存在。这对于运行于受约束的安全上下文的代码是一个重要的考虑。</p>
</li>
<li>
<p>内部暴露：由于反射允许代码进行非反射代码中的非法操作，例如访问私有域和方法，因此对反射的使用会导致无法预期的副作用，这会使得代码功能紊乱并且会破坏便携性。反射代码会破坏抽象性，因此随平台升级可能会改变行为。</p>
</li>
</ul>
</li>
</ul>
<h3 id="泛型">泛型</h3>
<ul>
<li>作用
<ul>
<li>编译时的强类型检查（ Stronger type checks at compile time.）</li>
<li>消除类型转换（ Elimination of casts.）</li>
<li>使得开发者能够实现泛型算法（ Enabling programmers to implement generic algorithms.）</li>
</ul>
</li>
</ul>
<h3 id="集合">集合</h3>
<ul>
<li>
<p>hashtable和hashmap的区别</p>
</li>
<li>
<p>HashMap实现原理</p>
</li>
<li>
<p>ConcurrentHashMap的原理</p>
</li>
</ul>
<h3 id="多线程">多线程</h3>
<ul>
<li>
<p>线程状态</p>
</li>
<li>
<p>sleep()与object.wait()的区别</p>
</li>
<li>
<p>synchronized与锁</p>
<ul>
<li>保证被同步块的可见性、原子性、有序性</li>
</ul>
</li>
<li>
<p>volatile：</p>
<ul>
<li>保证变量读写的可见性并禁止指令重排</li>
<li>保证对变量简单读写操作的可见性、原子性、有序性</li>
<li>对变量复合操作仅保证可见性</li>
</ul>
</li>
<li>
<p>synchronized和ReentranLock</p>
</li>
<li>
<p>什么是线程安全，如何保证线程安全</p>
</li>
<li>
<p>如何保证多线程读写文件的安全</p>
</li>
<li>
<p>线程池原理</p>
</li>
<li>
<p>多线程中的安全队列一般通过什么实现
CAS
<a href="http://zl198751.iteye.com/blog/1848575">http://zl198751.iteye.com/blog/1848575</a></p>
</li>
<li>
<p>java的锁有几种</p>
</li>
</ul>
<h4 id="死锁的4个必要条件">死锁的4个必要条件</h4>
<ul>
<li>互斥条件：一个资源同一时间只能被一个线程使用</li>
<li>请求与保持：线程持有一个资源的同时请求另一个资源</li>
<li>不可剥夺：持有的资源不能被其它线程剥夺</li>
<li>循环等待：在上述条件的基础上多个线程对资源的请求形成一个循环等待资源的关系</li>
</ul>
<h4 id="copyonwritearraylist">CopyOnWriteArrayList</h4>
<p>在add和set等修改时加锁，并且拷贝一份列表再修改，遍历时无需加锁，并且是线程安全的，因此遍历的性能更好。适用与无需频繁更改列表的场景。</p>
<h4 id="reentrantlock">ReentrantLock</h4>
<ul>
<li>可重入</li>
<li>公平性，如果设置为公平锁，在多个线程竞争该锁时，优先保障等待时间最长的线程获取到锁，缺点是整体性能更慢，但不会产生饥饿</li>
</ul>
<h4 id="单例的实现与线程安全">单例的实现与线程安全</h4>
<ul>
<li>
<p>静态内部类：类和接口（用T表示）的初始化时机，在以下几种情况首次发生前T会立即被初始化</p>
<ul>
<li>创建了T的实例</li>
<li>调用T定义的static方法</li>
<li>给T中定义的static字段赋值</li>
<li>使用T中定义的非常量static字段</li>
<li>T是一个顶级class，并且T中嵌套的一个assert语句被执行
类初始化过程中会有一个初始化锁保证实例初始化的线程安全</li>
</ul>
</li>
<li>
<p>双检锁，实例字段定义使用volatile修饰</p>
<ul>
<li>实例创建包含三个步骤：分配内存空间，对象初始化，返回对象的引用</li>
<li>这三个步骤可能会被指令重排，如果首先返回了对象引用，但实例还未初始化完成，空判断会返回false，那么会取得一个未初始化完成的对象引用</li>
<li>volatile可以禁止这种指令重排</li>
</ul>
</li>
</ul>
<h3 id="jvm">JVM</h3>
<h4 id="加载链接初始化">加载、链接、初始化</h4>
<p>JVM动态地加载，链接，初始化类和接口。</p>
<ul>
<li>
<p>加载是根据一个特定名称寻找一个类或接口的二进制表示，并且从二进制表示创建类或接口的过程。</p>
</li>
<li>
<p>链接是获取一个类或接口，将其整合到JVM的运行时状态中以使其可以被执行。</p>
<ul>
<li>验证</li>
<li>准备</li>
<li>解析</li>
</ul>
</li>
<li>
<p>初始化类或接口包含了执行类或接口的初始化方法    <code>&lt;clini&gt;</code>。</p>
</li>
</ul>
<h4 id="类加载过程httpsdocsoraclecomjavasetutorialextbasicsloadhtml"><a href="https://docs.oracle.com/javase/tutorial/ext/basics/load.html">类加载过程</a></h4>
<p>Java平台使用一个代理模型来加载类，基本思想是每个类加载器都有一个“父”类加载器。当加载一个类时，一个类加载器在尝试自行搜索一个类之前会首先将类的搜索“代理”给其父加载器。</p>
<ul>
<li>
<p>java.lang.ClassLoader及其子类的构造器可以指定一个父加载器，如果没有指定，虚拟机系统类加载器回被指定为默认父加载器。</p>
</li>
<li>
<p>ClassLoader的loadClass方法会按顺序执行如下任务来加载一个类</p>
<ol>
<li>如果一个类已经被加载过了会直接返回这个类</li>
<li>否则，会将这个新的类的搜索代理给其父加载器</li>
<li>如果父加载器没有找到类，那么loadClass会调用findClass来寻找并加载类。</li>
</ol>
</li>
<li>
<p>ClassLoader的findClass方法会在父加载器未找到指定类时在当前加载器对该类进行搜索</p>
</li>
<li>
<p>为什么要设计双亲委派模型？违反双亲模型的例子以及如何实现的（JDBC）？</p>
</li>
<li>
<p>JIT(Just in time)
JVM中有一个即时编译器（just-in-time compiler），可以在运行时对已经编译过的class文件进行进一步的编译，并将字节码转换为高度优化的机器码，这些优化过的代码运行极其快速，堪比甚至在某些情况下超过编译过的C/C++代码。</p>
</li>
<li>
<p>运行时数据区</p>
<ul>
<li>
<p>每个线程自有</p>
<ul>
<li>
<p><code>pc</code>寄存器（The pc Register）</p>
<p>如果方法不是native的，它包含线程正在执行的JVM指令的地址，否则是undefined</p>
</li>
<li>
<p>JVM栈（Java Virtual Machine Stacks）</p>
<p>JVM栈用于存储帧。</p>
</li>
</ul>
<ul>
<li>
<p>原生方法栈（Native Method Stacks）</p>
<p>为了支持<code>native</code>方法（非Java语言写的方法），JVM的实现可以使用传统的栈，通俗地讲就是<code>C stacks</code>。原生方法栈可以被一个解释器实现所利用，该解释器可以用于在例如C这样的语言中使用JVM指令集。不能加载<code>native</code>方法并且它们自身也不依赖与传统的栈的JVM实现不需要提供原生方法栈。</p>
</li>
</ul>
</li>
<li>
<p>所有线程共享</p>
<ul>
<li>
<p>堆（Heap）</p>
<p>为所有类的实例和数组进行内存分配的数据区。</p>
</li>
<li>
<p>方法区（Method Area）</p>
<p>和操作系统进程的&quot;text&quot;段类似，它存储每个类的结构，如运行时常量池、域和方法数据、方法和构造器的代码，包括用于类、实例、接口初始化的特殊方法。逻辑上而言它是属于堆的一部分。</p>
<ul>
<li>
<p>运行时常量池（Run-Time Constant Pool）</p>
<p>运行时常量池是每个类或接口的class文件中<code>constant_pool</code>表的运行时表示。它包含若干中类型的常量，从编译时可知的数值字面量到必须在运行时进行解析的域引用。和传统编程语言的符号表类似，它服务于一个函数，尽管它包含比一般符号表更加广泛的数据。</p>
<p>每个运行时常量池是从JVM方法区进行分配的，一个类或接口的运行时常量池在类或接口被JVM创建时进行构造。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>GC机制</p>
<ol>
<li>对象引用分析算法</li>
</ol>
<ul>
<li>引用计数</li>
<li>可达性分析：通过一系列称为GC根的对象作为起点，从这些结点开始向下搜索，搜索所走的路径称为引用链，当一个对象到GC根没有任何引用链相连时，则证明此对象不可达。
可作为GC根的对象包括下面几种：
<ul>
<li>虚拟机栈中引用的对象</li>
<li>方法区中的静态属性引用的对象</li>
<li>方法区中的常量引用的对象</li>
<li>原生方法栈中JNI引用的对象</li>
</ul>
</li>
</ul>
<ol start="2">
<li>垃圾回收算法
<ul>
<li>标记清除算法(Mark-Sweep)：根据引用分析算法标记需要回收的对象，在标记完成后统一回收所有被标记的对象。
<ul>
<li>标记和清除的效率不高</li>
<li>标记清除后会产生大量不连续的内存碎片</li>
</ul>
</li>
<li>复制算法(Copying)：将可用内存按容量划分为大小相等的两块，每次只使用其中一块，当这一块使用完了，就将仍存活的对象复制到另一块，然后再把已使用的这一块内存空间一次性清理掉。
<ul>
<li>效率较标记清除要高，但内存空间利用率不高</li>
<li>现在商业虚拟机都采用这种收集算法来回收新生代。</li>
</ul>
</li>
<li>标记整理(Mark-Compact)：与标记清除算法一样，但后续不是直接对可回收对象进行清理，而是所有存活对象都向一端移动，然后直接清理掉存活对象边界意外的内存。</li>
<li>分代收集(Generational Collection)：根据对象存活周期将内存划分为几块，一般是把Java堆分为新生代和老年代，根据各个年代的特点采用最适当的收集算法。</li>
</ul>
</li>
</ol>
</li>
<li>
<p><a href="https://www.javaworld.com/article/2076614/core-java/object-initialization-in-java.html">Java对象的初始化</a></p>
</li>
</ul>
<p>大致说了Java对象初始化机制有三种：实例初始化器（初始化块）、实例变量初始化器、构造器。初始化块和实例变量初始化器可以认为是实例初始化器的两种不同形式，实例变量初始化器只不过定义了实例变量并使用表达式而非块进行了初始化。在对象初始化时，由于存在继承层次结构，每一层级类都需要进行初始化，一个对象从自身开始向上到父类，到父类的父类等等，直到Object类，完成整个类层次的初始化。所以该对象的构造器必须直接或间接地调用父类构造器，这也说明了为什么构造器不属于Java类成员，它不会被子类继承，不然会造成初始化的死循环。构造器是初始化的入口，但不是初始化的全部，并且为了保证初始化过程的顺序，编译器会为每个构造器生成一个<code>&lt;init&gt;</code>方法，包含以下代码：</p>
<blockquote>
<ol>
<li>对另一个构造函数的调用（为了直接或间接调用父类构造器）</li>
<li>初始化器（包括变量初始器器和块初始化器，为了保证初始化器仅运行一次，如果第1步调用是本地另一个构造函数,那么便不需要初始化器的代码）</li>
<li>构造函数正文</li>
</ol>
</blockquote>
<h3 id="其它-1">其它</h3>
<ul>
<li>LRU缓存
LRU（Least Recently Used）最近最少使用的，即是在缓存容量超过上限后需要移除的项。一般使用LinkedHashMap作为容器，其访问顺序受get,put,putAll操作的影响（不受容器视图的相应操作的影响），三个操作后被访问的元素移动到容器尾部，即容器内顺序从LRU到MRU（Most Recently Used）排列。因此当缓存容量超过上限后可以移除容器头部的LRU项，使容器持有的对象所占空间在所设定的最大值缓存值以内。</li>
</ul>
<h2 id="软件工程理论与实践">软件工程理论与实践</h2>
<h3 id="面向对象编程">面向对象编程</h3>
<ul>
<li>
<p>封装、继承、多态</p>
<ul>
<li>封装：封装内部状态，提供外部接口，隐藏内部实现细节</li>
<li>继承：子类继承父类的数据和行为，构成一个类层次结构，并且子类可以对父类的数据和行为进行扩展</li>
<li>多态：通过继承和接口实现，并重写方法，一个类型的方法可以提供不同的具体实现</li>
</ul>
</li>
<li>
<p>面向对象编程原则SOLID</p>
<ul>
<li>单一职责原则(Single Responsibility Principle)：一个类应当只有一个引起它改变的原因</li>
<li>开闭原则(Open Close Principle）：类，模块，函数对扩展开放，对修改关闭。</li>
<li>里氏替换原则(Liskov Substitution Principle)：所有使用基类的地方都能够透明地使用子类</li>
<li>接口隔离原则(Interface Segregation Principle)：客户端不应当依赖它不需要的接口</li>
<li>依赖倒置原则(Dependency Inversion Principle)：依赖抽象而不要依赖具体实现</li>
<li>迪米特原则(Law of Demeter)：一个对象对其它对象应该有最少的了解</li>
</ul>
</li>
<li>
<p>高内聚与低耦合</p>
<p>它们都是降低软件复杂度的方法论</p>
<ul>
<li>高内聚指类、方法、域的职责应该尽可能单一</li>
<li>低耦合指类、模块之间的相互依赖应尽可能低</li>
</ul>
</li>
</ul>
<h3 id="设计模式与app架构">设计模式与APP架构</h3>
<ul>
<li>设计模式
<ul>
<li>创建型模式
<ul>
<li>单例：保证一个类仅有一个实例，提供一个访问它的全局访问点。</li>
<li>工厂方法：提供一个创建对象的接口，通过类继承让子类决定将哪一个类实例化。
<ol>
<li>适用性：
<ul>
<li>一个类不能参与到它必须创建的类的对象</li>
<li>一个类希望其子类来指定要创建的对象</li>
<li>类将职责委托给若干helper子类，并且你希望将选择哪个子类的知识局部化</li>
</ul>
</li>
</ol>
</li>
<li>抽象工厂：提供一个创建一系列相关或相互依赖的对象的接口（一个产品系列），而无需指定它们具体的类。抽象工厂与具体工厂使用了工厂方法模式。</li>
<li>生成器（Builder）：将一个<strong>复杂</strong>对象的创建和其表示进行分离，是的相同的构造过程可以创建出不同的表示。</li>
</ul>
</li>
<li>结构型模式
<ul>
<li>
<p>适配器：将一个类的接口转换为客户希望的另一个接口。该模式使得原本由于接口不兼容而不能一起工作的类可以一起工作。</p>
<ol>
<li>动机：有时为复用而设计的工具箱类不能被复用的原因仅仅是因为它的接口与专业领域所需要的接口不匹配。</li>
<li>适用性：
<ul>
<li>你想使用一个已经存在的类，而它的接口不符合你的需求</li>
<li>你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类）协同工作</li>
<li>（仅适用于对象Adapter）你想使用一些已存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。</li>
</ul>
</li>
</ol>
</li>
<li>
<p>桥接：将抽象部分与它的实现部分分离，使它们都可以独立地变化。</p>
<ol>
<li>
<p>动机：当一个抽象可能有多个实现时，通常用继承来协调它们。抽象类定义对该抽象的接口，而具体的子类则用不同的方式加以实现。但是此方法有时不够灵活。继承机制将抽象部分与它的实现部分固定在一起，使得难以对抽象部分和实现部分独立地进行修改、扩展和重用。桥接模式使用组合而非继承的方式，它将具体实现的细节从一个层级推到另一个层级的对象上。</p>
</li>
<li>
<p>适用性</p>
<ul>
<li>你想避免在一个抽象和其具体实现间引入永久性的绑定。例如，实现必须在运行时进行选择或切换。</li>
<li>抽象和其实现都可以通过子类化进行扩展。这样，可以对不同的抽象和实现进行组合，并且可以对它们进行独立的扩展。</li>
<li>对一个抽象的实现的改变不会影响客户端，也就是，代码不必重新编译。</li>
<li>类型的扩散。这中类型层次说明需要将对象分为两个部分。</li>
<li>你想在多个对象间共享一个实现。</li>
</ul>
</li>
<li>
<p>实例</p>
<p>考虑你想要不同倍镜的98K，你是想买分别带4倍镜和8倍镜的两把98K，而且倍镜不可拆卸。还是仅买一把98K，再各买一个4倍镜和8倍镜，然后根据需要进行组装，并且你还可以再买更高级的倍镜，而不是再买一把新的98K。</p>
</li>
</ol>
</li>
<li>
<p>代理：为其它对象提供一种代理以控制对这个对象的访问。</p>
<ol>
<li>动机：对一个对象进行访问控制的一个原因是为了只有在我们确实需要这个对象时才对它进行创建和初始化。</li>
<li>适用性：相对于一个简单的指针或引用，有时我们需要对一个对象有更精细或复杂的引用。这是可以考虑使用代理。
<ul>
<li>远程代理，为一个不同地址空间的对象提供一个本地代理</li>
<li>虚代理，按需创建开销大的对象</li>
<li>保护代理，对原始对象进行访问控制</li>
<li>智能指针</li>
</ul>
</li>
<li>一般用例
<ul>
<li>对另一个对象进行访问控制</li>
<li>懒初始化</li>
<li>实现日志</li>
<li>利用网络连接</li>
<li>对一个对象引用进行计数</li>
</ul>
</li>
</ol>
</li>
<li>
<p>装饰：动态地为一个对象添加额外的职责。相对使用继承来进行功能扩展的方式，装饰器提供了另一种可选的灵活方式。</p>
</li>
<li>
<p>组合：将对象组合成树结构以表示<strong>部分-整体</strong>层次结构。组合可以让客户端将独立对象和对象的组合一致对待。</p>
</li>
<li>
<p>外观：为一个子系统中的一系列接口提供一个统一的接口。它定义了一个更高层级的接口，使得子系统更加易于使用。</p>
</li>
</ul>
</li>
<li>行为模式。
<ul>
<li>命令：将一个请求封装为一个对象，从而可以让你使用不同的请求对客户端进行参数化、对请求加入队列或者进行记录，以及支持撤销操作。
<ul>
<li>常见用例
<ul>
<li>保留请求历史记录</li>
<li>实现回调函数</li>
<li>实现撤销函数</li>
</ul>
</li>
</ul>
</li>
<li>策略：定义一个算法家族，对每种算法进行封装并使得它们可以进行互换。策略模式可以让算法独立于客户端进行变化。</li>
<li>观察者：定义对象间的一个一对多依赖，使得一个对象的状态改变时，所有依赖对象都会被通知并进行自动更新。</li>
<li>模板方法：定义一个操作中的一个算法的骨架，将算法的某些步骤延迟到子类。模板方法可以让子类重新定义一个算法的某些特定步骤，并且不会改变算法的结构。</li>
<li>责任链</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="网络与协议">网络与协议</h2>
<h3 id="http">HTTP</h3>
<ul>
<li>
<p><a href="http://www.rfcreader.com/#rfc2616">RFC2616</a></p>
</li>
<li>
<p>GET，POST，PUT的区别
从以下几个方面进行说明：
semantics, linking, caching, repeatability,etc.</p>
<p>GET，PUT是幂等的，即对同一请求进行多次的效果和进行单次请求的效果是一样的，没有副作用。
POST是非幂等的。</p>
<ul>
<li>
<p>GET</p>
<p>获取URI所指定的信息。规范中没有定义GET请求中实体正文的语义，那么服务器在处理GET请求时应该将实体忽略。</p>
</li>
<li>
<p>POST</p>
<p>接收请求中的实体，将实体作为请求URI所标识的资源的一个新的下属（subordinate），类似一个文件时一个目录的下属，一篇新闻文章是一个新闻组的下属，或者一条记录时一个数据库的下属。它设计为采用一种统一的方法来覆盖如下功能：</p>
<ul>
<li>对已存在的资源进行注解</li>
<li>将一个消息发布到一个公告板、新闻组、邮件列表或类似文章组。</li>
<li>为一个数据处理过程提供一块数据，例如提交一个表单</li>
<li>通过append操作对一个数据库进行扩展</li>
</ul>
<p>具体的功能是由服务器确定的，并且依赖于请求RUI。</p>
</li>
<li>
<p>PUT</p>
<p>它要求将请求实体存储在提供的请求URI处。如果请求URI指向的资源已经存在，那么请求中的实体可以认为是对已存在资源的修改版本。</p>
<p>它与POST请求的根本区别在于请求URI的意义是不同的。POST请求中的URI用于标识处理请求实体的资源，该资源可能是一个数据处理过程，一个到达另一个协议的网关，或者接收注解的一个分开的实体。而PUT请求中的URI标识请求包裹的实体——用户代理知道URI是用来干嘛的并且服务器不能尝试将请求应用到其它资源。</p>
</li>
</ul>
</li>
</ul>
<h3 id="https">HTTPS</h3>
<ul>
<li>4次握手</li>
<li>非对称加密</li>
</ul>
<h3 id="osi七层模型">OSI七层模型</h3>
<h3 id="tcpip五层模型">TCP/IP五层模型</h3>
<h3 id="tcpip">TCP/IP</h3>
<ul>
<li>
<p><a href="https://tools.ietf.org/html/rfc793">RFC793</a></p>
</li>
<li>
<p>TCP位于OSI模型第四层的传输层</p>
</li>
<li>
<p>TCP与UDP的区别？</p>
<ul>
<li>TCP（Transmission Control Protocol 传输控制协议）面向连接的可靠的字节流的传输层协议</li>
<li>UDP（User Datagram Protocol用户数据报协议）</li>
</ul>
<ol>
<li>TCP面向连接（如打电话要先拨号建立连接）; UDP是无连接的，即发送数据之前不需要建立连接</li>
<li>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达; UDP尽最大努力交付，即不保证可靠交付</li>
<li>TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流; UDP是面向报文的UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）</li>
<li>每一条TCP连接只能是点到点的; UDP支持一对一，一对多，多对一和多对多的交互通信</li>
<li>TCP首部开销20字节; UDP的首部开销小，只有8个字节</li>
<li>TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道</li>
</ol>
</li>
<li>
<p>TCP建立连接三次握手的过程，为什么不是两次，为什么不是四次？</p>
<pre><code>      TCP A                                                TCP B

  1.  CLOSED                                               LISTEN

  2.  SYN-SENT    --&gt; &lt;SEQ=100&gt;&lt;CTL=SYN&gt;               --&gt; SYN-RECEIVED

  3.  ESTABLISHED &lt;-- &lt;SEQ=300&gt;&lt;ACK=101&gt;&lt;CTL=SYN,ACK&gt;  &lt;-- SYN-RECEIVED

  4.  ESTABLISHED --&gt; &lt;SEQ=101&gt;&lt;ACK=301&gt;&lt;CTL=ACK&gt;       --&gt; ESTABLISHED

  5.  ESTABLISHED --&gt; &lt;SEQ=101&gt;&lt;ACK=301&gt;&lt;CTL=ACK&gt;&lt;DATA&gt; --&gt; ESTABLISHED

          Basic 3-Way Handshake for Connection Synchronization
</code></pre>
</li>
<li>
<p>TCP断开连接四次挥手过程？</p>
<pre><code>      TCP A                                                TCP B

  1.  ESTABLISHED                                          ESTABLISHED

  2.  (Close)
      FIN-WAIT-1  --&gt; &lt;SEQ=100&gt;&lt;ACK=300&gt;&lt;CTL=FIN,ACK&gt;  --&gt; CLOSE-WAIT

  3.  FIN-WAIT-2  &lt;-- &lt;SEQ=300&gt;&lt;ACK=101&gt;&lt;CTL=ACK&gt;      &lt;-- CLOSE-WAIT

  4.                                                       (Close)
      TIME-WAIT   &lt;-- &lt;SEQ=300&gt;&lt;ACK=101&gt;&lt;CTL=FIN,ACK&gt;  &lt;-- LAST-ACK

  5.  TIME-WAIT   --&gt; &lt;SEQ=101&gt;&lt;ACK=301&gt;&lt;CTL=ACK&gt;      --&gt; CLOSED

  6.  (2 MSL)
      CLOSED

                          Normal Close Sequence
</code></pre>
</li>
<li>
<p>TCP连接和断开时客户端和服务器的状态分别是怎样的？</p>
</li>
<li>
<p>为何不直接在第一次握手就带上报文段消息，非要第三次才可以？</p>
</li>
<li>
<p>为何不只握手两次？</p>
</li>
<li>
<p>为何不是三次挥手？</p>
</li>
<li>
<p>为什么客户端在收到服务端发来的FIN包后要等2个最长报文段传输时间？</p>
</li>
<li>
<p>如何设计在UDP上层保证UDP的可靠性传输？</p>
</li>
</ul>
<p>UDP上层即应用层可以实现可靠性传输，参考TCP可靠性传输，包括确认机制、重传机制、窗口确认机制。</p>
<h2 id="算法与数据结构">算法与数据结构</h2>
<h3 id="算法">算法</h3>
<ul>
<li>查找
<ul>
<li>二分查找</li>
</ul>
</li>
<li>排序</li>
<li>递归</li>
</ul>
<h3 id="数据结构">数据结构</h3>
<ul>
<li>Hash表</li>
<li>栈</li>
<li>队列</li>
<li>链表</li>
<li>数组</li>
<li>树</li>
<li>图
<ul>
<li>广度优先搜索(BFS)：使用队列存储访问结点，访问顺序为FIFO</li>
<li>深度优先搜索(DFS)：使用递归或栈数据结构来访问结点，访问顺序LIFO</li>
</ul>
</li>
</ul>
<h2 id="操作系统">操作系统</h2>
<ul>
<li>什么是进程？什么是线程它们有什么区别？</li>
</ul>
<p>一个进程有一个自有的执行环境，通常有一个完整的，私有的基本运行时资源集，特别是每个进程有其各自的内存空间。</p>
<p>进程常常被看做程序或应用的同义词，然而，用户看到的一个应用事实上可能由一个相互协作的进程集合组成。为了利用进程间通信，大多数操作系统支持内部进程通信（IPC，Inter Process Communication）资源，例如管道（pipes）和套子节（sockets），IPC不仅仅用于同一系统下的进程间，也可以用于不同系统的进程间。</p>
<p>线程有时被称为轻量级进程（lightweight processes）。进程和线程都提供了一个执行环境，但相比进程，创建一个线程需要更少的资源。</p>
<p>线程存在与一个进程中，每个进程至少有一个线程。线程共享进程的资源，包括内存和打开的文件，这有利于高效的通信，但也有潜在的问题。</p>
<h2 id="数据库">数据库</h2>
<h3 id="关系型数据库">关系型数据库</h3>
<h4 id="模式">模式</h4>
<ul>
<li>一对一</li>
<li>一对多/多对一</li>
<li>多对多，一般采用中间表将多对多转化为两个一对多关系</li>
</ul>
<h4 id="连接运算">连接运算</h4>
<ul>
<li>内连接         只连接匹配的行</li>
<li>左外连接        包含左边表的全部行（不管右边的表中是否存在与它们匹配的行），以及右边表中全部匹配的行</li>
<li>右外连接        包含右边表的全部行（不管左边的表中是否存在与它们匹配的行），以及左边表中全部匹配的行</li>
<li>全外连接        包含左、右两个表的全部行，不管另外一边的表中是否存在与它们匹配的行。</li>
</ul>
<h3 id="非关系型数据库">非关系型数据库</h3>
<h2 id="密码学">密码学</h2>
<ul>
<li>
<p>非对称加密</p>
</li>
<li>
<p>对称加密</p>
</li>
<li>
<p>CA证书</p>
</li>
</ul>

                </div>
                
            </article>
        </div>
    </div>

                </div>
                <footer>
    Powered by <a target="_blank" href="https://gohugo.io/">Hugo</a> And 
    <a target="_blank" href="https://pages.github.com/">Github Pages</a>
</footer>
                <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
                

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.3.5/jquery.fancybox.min.css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.3.5/jquery.fancybox.min.js"></script>

                <link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.12.0/styles/default.min.css">
                <script src="/js/highlight.pack.js"></script>
                <script src="https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js"></script>
                <script type="text/javascript" async src="https://cdn.bootcss.com/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [
                ['$', '$'],
                ['\\(', '\\)']
            ],
            displayMath: [
                ['$$', '$$']
            ],
            processEscapes: true,
            processEnvironments: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            TeX: {
                equationNumbers: {
                    autoNumber: "AMS"
                },
                extensions: ["AMSmath.js", "AMSsymbols.js"]
            }
        }
    });
    MathJax.Hub.Queue(function () {



        var all = MathJax.Hub.getAllJax(),
            i;
        for (i = 0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });

    MathJax.Hub.Config({

        TeX: {
            equationNumbers: {
                autoNumber: "AMS"
            }
        }
    });
</script>
                <script type="text/javascript" src="/js/main.js"></script>
        </div>
    </body>

</html>