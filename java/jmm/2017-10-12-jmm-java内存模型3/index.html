<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

<title>
  
    
    风格与布局
  
</title><meta name="description" content="Android移动应用开发"><meta name="author" content="jastrelax">

<link rel="apple-touch-icon" href="/apple-touch-icon.png" sizes="180x180">
<link rel="icon" href="/favicon-32x32.png " sizes="32x32" type="image/png">
<link rel="icon" href="/favicon-16x16.png" sizes="16x16" type="image/png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#0c344b">
<link rel="icon" href="/favicon.ico">




    
        
            <link rel="stylesheet" href="/dist/main.37ab3f61b95417873748.min.css">
        
    




<link rel="canonical" href="https://www.androidpi.com/java/jmm/2017-10-12-jmm-java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B3/"><meta property="og:title" content="" />
<meta property="og:description" content="Java内存模型3: 若干动机 上一章概括了所有并发程序的一些非正式属性，以及对这些属性的一些误用导致的错误代码。本章概括了一些内存模型的非正式" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.androidpi.com/java/jmm/2017-10-12-jmm-java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B3/" />

<meta itemprop="name" content="">
<meta itemprop="description" content="Java内存模型3: 若干动机 上一章概括了所有并发程序的一些非正式属性，以及对这些属性的一些误用导致的错误代码。本章概括了一些内存模型的非正式">

<meta itemprop="wordCount" content="7533">



<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content=""/>
<meta name="twitter:description" content="Java内存模型3: 若干动机 上一章概括了所有并发程序的一些非正式属性，以及对这些属性的一些误用导致的错误代码。本章概括了一些内存模型的非正式"/>

</head>
<body>
    
<nav class="navbar navbar-expand-md navbar-light bg-light fixed-top shadow-sm" id="navbar-main-menu">
    <div class="container">
        <a class="navbar-brand font-weight-bold" href="https://www.androidpi.com/">风格与布局</a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#main-menu" aria-controls="main-menu" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="main-menu">
            <ul class="navbar-nav ml-auto">
                
                    <li class="nav-item"><a class="nav-link" href="/android/">Android</a></li>
                
                    <li class="nav-item"><a class="nav-link" href="/blockchain/">Blockchain</a></li>
                
                    <li class="nav-item"><a class="nav-link" href="/book/">Books</a></li>
                
                    <li class="nav-item"><a class="nav-link" href="/cs/">CS</a></li>
                
                    <li class="nav-item"><a class="nav-link" href="/ee/">EE</a></li>
                
                    <li class="nav-item"><a class="nav-link" href="/java/">Java</a></li>
                
                    <li class="nav-item"><a class="nav-link" href="/puzzles/">Puzzles</a></li>
                
                    <li class="nav-item"><a class="nav-link" href="/web/">Web</a></li>
                
                    <li class="nav-item"><a class="nav-link" href="/backend/">后端</a></li>
                
                    <li class="nav-item"><a class="nav-link" href="/engineering/">工程与架构</a></li>
                
                    <li class="nav-item"><a class="nav-link" href="/dev/">开发</a></li>
                
            
            </ul>
        </div>
    </div>
</nav>


    
<main class="content-page container pt-7 pb-5">
    <div class="row">
        <div class="col">
            <article>
                <div class="row justify-content-center">
                    <div class="col-lg-8">
                        <h2 class="mb-3"></h2>

                        <div class="content">
                            <h1 id="java内存模型3-若干动机">Java内存模型3: 若干动机</h1>
<p>上一章概括了所有并发程序的一些非正式属性，以及对这些属性的一些误用导致的错误代码。本章概括了一些内存模型的非正式必要条件（requirement），换句话说，就是一些用于驯服这些错误代码的方法。</p>
<p>这里需要细心地把握一个平衡。一方面，模型有必要允许程序员能够仔细并正确地对多线程代码进行论述。另一方面，模型有必要允许编译器作者，虚拟机设计者和硬件架构师简单粗暴地进行代码优化，这会导致预测多线程代码的结果不那么直接。</p>
<p>最后，对于一个编程语言内存模型的非正式必要条件是什么，我们达成了一个共识。当必要条件浮出水面，一个内存模型也开始成型了。这些必要条件中的大多数都有一个相对简单易于理解的动机，显然保证应该达成，优化应当被允许等待。其它必要条件，这些与因果性相关的更加复杂，这些和内存模型一起将在下一张中进行完整的描述。</p>
<h2 id="31-正确同步程序的保障">3.1 正确同步程序的保障</h2>
<p>让程序员去推论编译器进行了哪些转换是十分困难的，Java内存模型的目的之一是为程序员提供一种机制以避免这种推理的需要。</p>
<p>例如，在图3.2的代码中，程序员只能看到重排序的结果，因为代码没有适当地进行同步。我们的第一个目的就是确保这是程序员看到重排序结果的唯一原因。</p>
<p>之前的工作证明所能提供的最好的保证就是重排序只应当在未正确同步的代码中可见。这是一个强保证，程序员假设多线程代码的行为总是包含顺序一致性（见2.1节）。因此，我们对程序员的第一个保证（称为DRF）适用于正确同步的程序。</p>
<pre><code>    初始 x == y == 0
    Thread1        | Thread2
    ---------------|-------------
    r1 = x;        |  r2 = y;
    ---------------|-------------
    if (r1 != 0)   |  if (r2 != 0)
         y = 42;   |      x = 42;
    正确同步的，因此r1 == r2 == 0是唯一合法的行为

    图3.1：正确同步的程序


    初始 x == y == 0
    Thread1        | Thread2
    ---------------|-------------
    1: r2 = x;     |  3: r1 = y
    ---------------|-------------
    2: y = 1;      |  4: x = 2
    可能返回 r2 == 2, r1 == 1

    图3.2：出人意料的行为
</code></pre>
<p><strong>DRF</strong>: 正确同步的程序具有顺序一致性语义，给定这一必要条件，如果代码中含有数据竞争，程序员就不用担心代码转换会影响程序的结果。</p>
<p>这一必要条件导致一些有趣的临界情况，例如，图3.1总的代码是正确同步的。这可能有点意外，因为它并没有进行任何同步操作。记住，如果一个程序是正确同步的，当它以顺序一致的方式执行时不存在数据竞争。如果该代码以顺序一致性方式执行，每个操作会以程序顺序执行，因此对x或y的写操作都不会发生。没有写操作发生，那么就不存在数据竞争：该程序是正确同步的。</p>
<p>这样就不允许进行一些诡异的程序转换，例如，一个激进的写投机（an aggressive write speculation）会预测将42写入y将会发生，允许这个写操作对线程2中对y的读是可见的。那么这会导致将42写入到x，允许对x的读见到42.这会导致对y的写操作发生，这样便证明了投机的正确性。这种转换不是合法的，作为一个正确同步的程序，只允许出现顺序一致性的结果出现。</p>
<h2 id="32-简单重排序">3.2 简单重排序</h2>
<p>上一章中，我们简述了重排程序操作对编译器的重要性，它是驱动大多数优化的引擎。因此，我们的第一个必要条件就是，我们总是允许不受控制的或者相互间没有数据依赖的语句重新排序。</p>
<p><strong>重排序1（Reorder1）</strong> 独立的相邻的语句可以被重排序。</p>
<p>注意Reorder1实际上允许不相邻的语句进行重排序，只需要简单地重复进行重排序知道语句出现在期望的位置。</p>
<p>在多线程环境中，这样做会导致违反直觉的结果，如图2.1（也就是图3.2）中看到的。记住，改图的的关键就在于每个线程中的操作重排序了。这种情况一旦发生，计时一个以顺序一致性执行的代码的机器也会出现这样的行为。当然，还是要再次注意的是，改代码没有适当地同步，即没有通过同步对使冲突访问以一定的顺序执行。</p>
<pre><code>    编译器转换前：

    初始 a = 0, b = 1
    Thread 1          | Thread 2
    ------------------|------------------
    1: r1 = a;        | 5: r3 = b;
    2: r2 = a;        | 6: a = r3;
    3: if (r1 == r2)  | 
    4:       b = 2;   |

    是有有可能 r1 == r2 == r3 == 2?

    编译器转换后：

    初始 a = 0, b = 1
    Thread 1          | Thread 2
    ------------------|------------------
    4: b = 2;         | 5: r3 = b;
    1: r1 = a;        | 6: a = r3;
    2: r2 = r1;       | 
    3: if (true);     |

    r1 == r2 == r3 == 2是顺序一致的

    图3.3 冗余读消除的效果
</code></pre>
<p>Reorder1确保独立的操作可以被重排序，且不关心它们在程序中的顺序。它不能保证两个独立操作总是会被重新排序。例如锁定区域外的操作不会被重排序。</p>
<p>图3.2并不影响我们对于因果性的概念，没有理由去认为这些线程中的第一个操作会影响第二个操作，因果性仍然有效。</p>
<h2 id="33-与依赖相关的转换">3.3 与依赖相关的转换</h2>
<p>3.2节中，我们给出Reorder1，它保证独立的操作可以被重排序。Reorder1是一个强保证，但还不足够强。有时，编译器进行的转换可以消除依赖的影响。</p>
<p>例如，图3.3中的行为是允许发生的。这一行为看上去是一个环路，因为对y的写依赖于对x的读，对x的写依赖于对y的读，而对y的读必须看到对前述对y的写。然而编译器应当允许进行如下操作：</p>
<ul>
<li>消除对a的冗余度，将r2 = a替换为r2 = r1</li>
<li>确定表达式r1 == r2总是true，消除分支3</li>
<li>移动写操作4：b = 2到前面的位置</li>
</ul>
<p>在编译器移除冗余的读操作后，赋值操作4：b = 2会保证一定发生；第二个对a的读总会返回和第一个读相同的值。没有这种信息，赋值操作看上去导致它自己发生了。有了这一信息，读写之间便没有依赖了。因此，破坏依赖的优化会导致明显的环路执行（cyclic execution）。</p>
<p>注意，线程内部语义保证了如果r1 != r2，那么线程1不会写b并且r3 == 1。这种情况下，要么r1 == 0并且r2 == 1，或者r1 == 1并且r2 == 0。</p>
<p>图3.4展示了另一种意外的行为。为了得到r1 == r2 == r3 == 1，看上去线程1需要在读x前需要将1写入y，也似乎直到读x后线程1不知道r2会是什么值。</p>
<pre><code>    初始 x == y == 0
    Thread 1     | Thread 2
    -------------|------------
    r1 = x;      | r3 = y;
    r2 = r1 | 1; | x = r3;
    y = r2;      |
    r1 == r2 == r3 == 1 是合法行为

    图3.4 一个更复杂的分析
</code></pre>
<p>实际上，编译器可以进行线程内分析，发现只有0和1会写入到x。知道了这点，编译器可以确位操作or总会返回1，使得线程1总是将1写到y。因此，线程1可能在读x前将1写到y。对y的写不依赖于对x的观察。这种类型的分析表明线程1中没有真实的依赖。</p>
<pre><code>    初始 x == y == 0
    Thread1       | Thread2
    --------------|--------------
    r1 = x;       | r3 = y;
    if(r1 == 1)   | if(r2 == 1)
        y = 1;    |     x = 1;
                  | if(r2 == 0)
                  |     x = 1;
    r1 == r2 == 1是合法行为

    图3.5 一些依赖并不明显
</code></pre>
<p>一个类似明显依赖的例子如图3.5所示。和图3.4一样，一个编译器可以确定只有0和1被写入到x。因此，编译器可以移除线程2中的依赖，将x的写移到线程的开始处。如果最终代码以顺序一致的方式执行，那么会导致环路行为。</p>
<pre><code>    初始 x = 0
    Thread1      | Thread2
    -------------|---------------
    r1 = x;      | r2 = x;
    x = 1;       | x = 2;
    r1 == 2 和 r2 == 1是合法行为

    图3.6 一个意外的重排序
</code></pre>
<p>显然，编译器可以进行许多消除依赖的重排序。因此我们可以做出另一个保证：</p>
<p><strong>重排序2（Reorder2）</strong> 如果一个编译器能检测到一个操作总是会发生（同一个值写到同一个变量），它可以忽略明显的依赖而进行重排序。</p>
<p>和Reorder1一样，这种保证不允许对同步操作周围的操作随意地进行重排序。如前所述，操作不能移到锁定区域外。</p>
<p>即使Reorder1和Reorder2对编译器是强保证，他们不是所允许的重排序的完整集合。它们仅仅是总是保证被允许的行为。更多的变换也是可能的，只要保证结果合乎内存模型。</p>
<h3 id="331-对当前线程不可见的重排序">3.3.1 对当前线程不可见的重排序</h3>
<p>图3.6展示了一个小但是有趣的例子。行为r1 == 2和r2 == 1是合法行为，尽管看上去它很难发生。一个编译器不会对每个线程语句进行重排序；这一代码永远也不可能得到r1 == 1或者r2 == 2。然而，r1 == 2和r2 == 1的行为允许编译器较早进行写操作，但是不允许程序顺序之前的本地读对其可见。这种行为，尽管十分意外，却被若干内存结构所允许，因此也应该被一个编程语言的内存模型说允许。</p>
<h2 id="34-同步">3.4 同步</h2>
<pre><code>    初始，x == 0，ready == false。ready是一个volatile变量
    Thread1         | Thread2
    ----------------|--------------
    x = 1;          | if(ready)
    ready = true;   |    r1 = x;
    如果语句r1 = x; 执行了，它会读到1.

    图3.7 Volatile变量的使用
</code></pre>
<p>我们还没有讨论程序员如何使用显式的同步（以我们给出的任何形式）来保证代码的正确同步。通常，我们使用同步来强制前置发生关系。典型的方式是使用锁，另一种方式是使用volatile变量。</p>
<p>volatile变量的属性来自于提供一种线程间通信的方式，同时免于保证互斥的开销。一个简单的例子如图3.7所示。如果ready不是volatile的，线程1对它的写与对x的写可以重排序，导致最终r1值为0。将其定义为volatile的，那么重排序不会发生，如果线程2读到ready为true，那么它也一定读到x为1。这种线程间通信对于非阻塞算法非常有用。</p>
<p>锁和解锁工作方式和volatile类似：在一个解锁操作前的操作，必须在同一监控器的随后任意的锁操作之前。这中特性反应了同步用于线程间通信的方式，也就是前置发生（happens-before）特性。</p>
<p><strong>HB</strong> 对同一变量，volatile写在随后的volatile读之前。对同一监控器，解锁在随后的锁之前。</p>
<p>__随后__的定义在第二章中，同步操作包括锁，解锁，对volatile变量的读写。一个程序执行中所有的同步操作有一个总顺序，称为同步顺序。</p>
<p>第二章中描述的操作间的前置发生关系强制规定了这些操作间的顺序。例如，在一个单一线程的程序顺序中，一个操作发生在另一个操作之前，那么第一个操作前置发生于第二个操作。</p>
<p>同步操作在线程间建立了前置发生关系，我们称其为同步关系。</p>
<ul>
<li>在同步顺序中，一个特定监控器上的的解锁动作发生在同一监控器的锁操作之前。</li>
<li>在同步顺序中，对一个volatile变量的写操作前置发生于对同一变量的读操作。</li>
<li>启动一个线程的调用前置发生于线程的实际启动。</li>
<li>线程的终止前置发生于在该线程上的join操作。</li>
<li>前置发生是可传递的，那就是，如果a前置发生于b，b前置发生于c，那么a前置发生于c。</li>
</ul>
<h2 id="35-附加的同步问题">3.5 附加的同步问题</h2>
<h3 id="351-基于前置发生的优化">3.5.1 基于前置发生的优化</h3>
<p>注意锁和解锁操作仅与同一个监控器上的其它锁与解锁有前置发生关系。类似地，对一个volatile变量的访问仅与对同一volatile变量的其它访问建立前置发生关系。</p>
<p>一个前置发生关系可以认为是两个点之间的顺序边界，称起始点为release，结束点为acquire。解锁和volatile写是release操作，锁和volatile读是acquire操作。</p>
<p><strong>同步消除</strong>
有一些优化提议尝试移除过多的或者冗余的同步。Java内存模型的一个必要条件便是冗余的同步可以被移除（例如仅可在一个单一线程中访问的锁）。</p>
<p>一种可能的内存模型要求所有同步操作于其他同步操作建立前置发生关系。如果我们不关心线程访问的是什么变量或监控器，然后强制所有同步操作于其他同步有前置发生关系，那么它们都不会是多余的，它们都与其它线程中的同步操作交互，Java并不支持这一点，因为它没有充分地简化编程模型来为额外的同步开销进行辩护。</p>
<p>因此得到另一个保证：</p>
<p><strong>RS</strong> 仅引入多余前置发生边界的同步操作可以认为他们没有引入任何前置发生边界。</p>
<p>这一点反映在前置发生的定义中，例如，一个仅在一个线程中访问的锁只会引入已经被程序顺序边界捕获的前置发生关系。</p>
<p><strong>锁粗化（Lock Coarsening）</strong>
一种在提高并发上常常十分高效的转换是计算锁粗化。如果一个计算常常获取和释放同一个锁，那么计算锁粗化可以将这些锁区域合并为单个区域。这需要将一个锁区域外的访问移动到区域内部。如图3.8所示。</p>
<pre><code>    粗化前                      | 粗化后
    ---------------------------|---------------
    x = 1;                     |  synchronized(someLock) {
    synchronized(someLock) {   |    x = 1;
        // lock contents       |    // lock contents
    }                          |    
                               |    y = 2;
    y = 2;                     |  }

    图3.8 锁粗化示例
</code></pre>
<p>一个获取保证了与前一个释放的顺序。考虑一个操作发生在一个获取前，它可能或者可能没有观察到前一个释放前发生的操作，这依赖于线程是如何调度的。如果我们将访问移到获取后，我们可以简单地说访问一定是在前一个释放后调度的。因此这是一个合法的变换。</p>
<p>对x的写可以发生在对someLock最后的解锁之前或之后，通过将其移动到synchronized块内，编译器仅仅需要保证它在解锁后调用。</p>
<pre><code>    初始 v1 == v2 == 0
    Thread 1   | Thread 2    | Thread 3    | Thread 4
    -----------|-------------|-------------|----------
    v1 = 1;    | v2 = 2;     | r1 = v1;    | r3 = v2;
               |             | r2 = v2;    | r4 = v1;
    r1 == 1, r3 == 2, r2 == r4 == 0是否是合法行为？
    图3.9 volatile必须以一个总体顺序执行
</code></pre>
<p>类似地，释放保证了与随后的获取的一个顺序。开了一个操作发生在一个释放之后。它可能或者可能没有被随后的获取观察到。如果我们将访问移动到释放前，我们简单地说访问一定在下一个获取之前，因此这也是一个合法的转换。可以从图3.8看出，将y的写移动到synchronized块内。</p>
<p>所有这些都仅仅是一种迂回方式，表明对普通变量的访问可以和随后的volatile读或者监控器进入，或者之前的volatile写或监控器退出操作进行重排序。这暗示了普通访问可以移动到锁区域，而不是移出，我们有时称这种特性为roach motel semantics。</p>
<p>对编译器而言保证这种属性相当简单，事实上，大多数都已经做到了。处理器，也会对指令重排序，常常需要给定内存屏障指令用于在代码中的这些点进行执行，以保证它们不进行重排序。处理器常常提供了多样的这种屏障指令。</p>
<p>图3.9给出了另一种保证中的有趣的一瞥。Thread3和Thread4观察到的对v1和v2的读顺序应当相同，如果不是，那么就可能观察到r1 == 1, r3 == 2, r2 == r4 == 0。特别地，Thread3观察到对v1的写，但没有观察到对v2的写，Thread4者观察到对v2的写，而未观察到对v1的写。</p>
<p>内存模型不允许这样的行为发生：它不允许不同线程观察到的对volatile变量的写顺序不一样。事实上，这是一个强保证：</p>
<p><strong>Volatile原子性（VolatileAtomicity）</strong> 所有对volatile变量的访问以一个总体顺序进行。</p>
<h3 id="352-对volatile的额外保证">3.5.2 对volatile的额外保证</h3>
<p>与volatile相关的另一个问题成为强弱易失性，根据前置发生顺序，对volatile有两种可能的解读：</p>
<ul>
<li>
<p><strong>强解读</strong> 对一个volatile的写和随后的读之间有一个前置发生关系。</p>
</li>
<li>
<p><strong>弱解读</strong> 对一个volatile的写和随后的观察到这一写操作的读操作有一个前置发生关系。这一解释反映了内存模型在同步变量上的顺序约束，称为弱顺序。</p>
<pre><code>  初始 x == y == v == 0, v是volatile变量
  Thread 1   | Thread 2
  -----------|------------
  r1 = x;    | r3 = y;
  v = 0;     | v = 0;
  r2 = v;    | r4 = v;
  y = 1;     | x = 1;
  r1 == r3 == 1是否有可能发生？

  图3.10 强或者弱volatile
</code></pre>
</li>
</ul>
<p>在图3.10总，在弱解释下，每个线程对v的读观察到对自身volatile变量的写。如果是这种情况，那么前置发生关系就是多余的，可以被移除。其代码行为和图3.2总的简单顺序非常像。</p>
<p>为了避免多个读线程与写线程间使用一个单一volatile变量通信的困惑，Java支持强解释。</p>
<p><strong>强Volatile</strong> 对一个volatile的写和随后的读之间__一定__有一个前置发生关系。</p>
<h3 id="353-优化器必须谨慎">3.5.3 优化器必须谨慎</h3>
<p>相比锁，对于volatile的访问，优化器必须同样谨慎。在图2.11总，我们有一个正确同步的程序。当以一个顺序一致的方式执行时，Thread2会循环直到Thread1写v或b。由于读取a所能观察到的值是0，r1会有该值。作为结果，值1会写到v而不是b。因此，Thread1中对a的读与Thread2中对a的写有一个前置发生关系。</p>
<pre><code>    初始 a == b == v == 0, v是volatile的。
    Thread 1        | Thread 2
    ----------------|----------------------------------
    r1 = a;         | do {
    if (r1 == 0)    |    r2 = b;
        v = 1;      |    r3 = v;
    else            | } while (r2 + r3 &lt; 1);
        b = 1;      | a = 1;
    正确同步，因此r1 == 1是合法的。

    图 3.11 另一个意外正确同步的程序。
</code></pre>
<p>即使我们知道对a的写总会发生，我们不能将它与循环进行重排序。如果进行了重排序，Thread1会看到a的值为1，并对b进行写。线程2会观察到对b的写并终止循环。由于b不是一个volatile变量，线程1对b的写和线程2对b的读没有顺序可言。因此a和
b都会存在数据竞争。</p>
<p>这样的结果并不是一个顺序一致的方式，它违反了DRF，因此我们不允许它发生。这种避免这种类型的重排序会在建立一个可工作的内存模型上引入许多困难。</p>
<p>编译器作者应当在重排序的代码通过所有同步点时非常谨慎，而非仅仅涉及到加锁和解锁的时候。</p>
<h2 id="36-无限执行公平和可观察的行为">3.6 无限执行，公平和可观察的行为</h2>
<p>Java规范不保证抢占式的多线程和任何形式的公平。没有硬性的保证说任何线程会放弃CPU并允许其他线程调度。这种保证的缺失部分是由于线程优先级和实时线程引起的问题会使得这类保证非常复杂。大多数Java实现会提供一些类型的公平保证，但细节是与特定实现相关的，并且被当做一种服务质量问题，而非一个硬性的必要条件。</p>
<pre><code>    Thread 1                  | Thread 2
    --------------------------|-------------------------
    while(true)               | synchronized(o) {
        synchronized(o) {     |     done = true;
            if(done) break;   | }
            think             |
        }                     |
    图 3.12 缺少公平允许Thread1从不交出CPU
</code></pre>
<p>大多情况下，这看上去不是一个内存模型问题。然而，这些问题是紧密相关的。例如，其相互关系可以从图3.12中看出。由于缺乏公平，Thread1从不放弃CPU给Thread2是合法的，异常程序可能永远不会终止。由于这一行为是合法的，编译器将synchronized块包围在while循环外也是合法的，它具有同样的效果。</p>
<p>这是一个合法的编译器转换，但不是期望的一个。如3.5.1节提到的，编译器允许进行锁加粗（例如，如果编译器看到在同一个对象上的两个连续的同步方法调用，在连个调用中间它不必释放锁）。这里的妥协十分微妙，提高的性能会被更长的线程获取锁所带来的延迟说平衡掉。</p>
<pre><code>    初始 v是volatile并且v = false
    Thread 1                   | Thread 2
    ---------------------------|---------------------
    while(!v);                 | v = true;
    print(&quot;Thread 1 done&quot;);    | print(&quot;Thread 2 done&quot;);

    图 3.13 如果观察到打印消息，Thread1一定观察到对v的写和终止
</code></pre>
<p>然而，编译器在减少公平性的转换中有一些限制。例如图3.13所示，如果观察到线程2的打印消息，并且只有这两个线程在运行。那么线程1必须观察到对v的写，打印消息并退出。这阻止了编译器将对v的读提到循环外。这引起了另一个必要条件。</p>
<p><strong>可观察的（Observable）</strong> 一个为外界所观察到的操作（例如，一个文件读/写，程序终止）可能不会被外界观察到的唯一原因是如果有一个操作的无限序列在它之前或者在同步顺序中位于它之前。</p>
<pre><code>    初始 x == y == 0

    Thread 1             | Thread 2
    ---------------------|-----------------------
    do {                 | do {
        r1 = x;          |    r2 = y;
    } while(r1 == 0);    | } while(r2 == 0);
    y = 42;              | x = 42;
    正确同步，因此不终止是唯一合法的行为

    图 3.14 正确同步的程序
</code></pre>
<h3 id="361-控制依赖">3.6.1 控制依赖</h3>
<p>作为这些必要条件的结果，对于实现者对Java编程所必须作出的推论，新的Java内存模型作出了微妙但更深入的改变。例如，控制依赖的标志定义假设执行总是会退出。这在多线程程序中是不能随意假设的。</p>
<p>考虑3.14中的程序， 在传统控制依赖中，两个线程中的写都控制依赖于循环守卫。这可能导致编译器决定将写移动到循环的前面。然而在Java中这是非法的。该程序是正确同步的：在所有顺序一致的执行中，两个线程都没有写共享变量，并且没有数据竞争。一个编译器必须创建一个条件使循环终止。</p>
<p>控制依赖的概念正确包含了这点，在程序验证上下文中称为弱控制依赖。在程序分析与转换的上下文中这种属性也被当做循环控制依赖。</p>

                        </div>
                    </div>
                </div>
            </article>
        </div>
    </div>
</main>


    <footer class="footer text-center bg-dark py-6">
    <div class="container">
        <div class="row">
            <div class="col">
                <ul class="list-inline">
                    
                </ul>

                <p class="text-muted">
                    
                        Copyright &copy; 风格与布局 2020
                    
                </p>

                <p class="text-muted">
                Powered by <a href="https://gohugo.io" target="_blank">Hugo</a> with <a href="https://github.com/puresyntax71/hugo-theme-chunky-poster" target="_blank">Chunky Poster</a>.
                </p>

                <p class="text-muted">
                    <a href="http://beian.miit.gov.cn" target="_blank">蜀ICP备18005659号-1</a>
                </p>
            
            </div>
        </div>
    </div>
</footer>

    
    
        
            <script src="/dist/main.d608eadfe5ac0688902e.min.js"></script>
        
    








    
</body>
</html>
