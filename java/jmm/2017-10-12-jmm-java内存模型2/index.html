<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" >
        <meta lang="zh">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title> | androidpi</title>
<meta name="description" content="第二章 构建模块 为了对一个编程语言中的原因与结果进行推论，我们需要做两件事情： 为并发编程提供一个清晰的模型以编写正确的代码。 为平台架构提供一个">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" type="text/css" media="screen" href="/css/main.css" />
        <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.0/css/solid.css" integrity="sha384-TbilV5Lbhlwdyc4RuIV/JhD8NR+BfMrvz4BL5QFa2we1hQu6wvREr3v6XSRfCTRp" crossorigin="anonymous">
        <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.0/css/brands.css" integrity="sha384-7xAnn7Zm3QC1jFjVc1A6v/toepoG3JXboQYzbM0jrPzou9OFXm/fY6Z/XiIebl/k" crossorigin="anonymous">
        <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.0/css/fontawesome.css" integrity="sha384-ozJwkrqb90Oa3ZNb+yKFW2lToAWYdTiF1vt8JiH5ptTGHTGcN7qdoR1F95e0kYyG" crossorigin="anonymous">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet">
        
    <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet">
    <link rel="stylesheet" type="text/css" media="screen" href="/css/article.css" />

    </head>

    <body>
        <div class="site-wrapper">
                <header>
    <nav>
        <a class="home" href="https://www.androidpi.com/">首页</a>
    </nav>
    
</header>
                <div class="site-main">
                    
    <div class="main">
        <div class="article">
            <aside>
                    <nav id="TableOfContents">
  <ul>
    <li><a href="#21-代码被重排序了">2.1 代码被重排序了</a></li>
    <li><a href="#22-同步与前置发生">2.2 同步与前置发生</a></li>
    <li><a href="#23-原子性">2.3 原子性</a></li>
    <li><a href="#24-可见性visibility">2.4 可见性（Visibility）</a></li>
    <li><a href="#25-次序ordering">2.5 次序（Ordering）</a></li>
    <li><a href="#26-讨论">2.6 讨论</a></li>
  </ul>
</nav>
            </aside>
            <article>
                <div class="title">
                    <h1 id="title"></h1>
                </div>
                <div class="content">
                        <h1 id="第二章-构建模块">第二章 构建模块</h1>
<p>为了对一个编程语言中的原因与结果进行推论，我们需要做两件事情：</p>
<ol>
<li>为并发编程提供一个清晰的模型以编写正确的代码。</li>
<li>为平台架构提供一个清晰的模型以优化代码。
已经有许多工作从概念上定义了线程如何与内存交互，为了得到满足需要的内存模型，首先回复一些概念和术语。</li>
</ol>
<h2 id="21-代码被重排序了">2.1 代码被重排序了</h2>
<p>最常见的假设（assumed）内存模型是顺序一致性模型，即内存操作以一个单一的总体顺序一次执行一个；在任何优化之前，一个指定线程的内存操作必须以这一总体顺序执行，这一顺序和它们在程序中出现的顺序一样。这种模型基本反映了每个线程的内存操作之间的交错；在内存一致性下，一个读必须返回总体顺序中对该位置的最近一次写入的值。</p>
<p>这是对单一线程模型的直觉性扩展，但对于一个线程中的内存操作重排序却没有多少空间，即使两个语句之间没有数据或控制依赖。</p>
<p>一个程序上可以进行很多重要的优化，它们都涉及程序语句重排序。例如超标量架构重排指令以保证执行单元尽可能全部被利用。即使像一些无处不在的优化，如子表达式和冗余读消除都可以视作重排序：每个公共表达式从概念上讲是移动到了它们第一次出现的地方。</p>
<p>系统的许多不同的方面也会影响重排序，例如，JIT编译器和处理器会进行重排序，一个虚拟机运行的内存层次结构会使得看上去代码被重排序了。源代码到字节码的的转换也会进行重排序和转换。为了简化的目的，我们简单地认为任何导致代码重排序的是一个编译器。</p>
<p>但是在优化多线程代码时，保持顺序一致性语义就更加困难了，考虑图2.1：</p>
<pre><code>    初始 x == 7 == 0
    Thread1     | Thread2
    ------------|-------------
    1: r2 = x   |  3: r1 = y
    ------------|-------------
    2: y = 1    |  4: x = 2
    可能返回 r2 == 2, r1 == 1

            图2.1



    初始 x == 7 == 0
    Thread1     | Thread2
    ------------|-------------
    2: y = 1    |  4: x = 2
    ------------|-------------
    1: r2 = x   |  3: r1 = y
    可能返回 r2 == 2, r1 == 1

            图2.2
</code></pre>
<p>考虑图2.1，看上去返回r2 == 2, r1 == 1是不可能的，直觉上，如果r2是2，那么指令4在指令1之前，指令1又在指令2之前，指令2在指令3之前，指令3又在指令4之前，这样形成了一个环状执行。</p>
<p>另一方面，我们必须考虑到一个编译器可能对每个线程的指令进行从排序，如图2.2所示，那么返回上述结果就说的通了。</p>
<h2 id="22-同步与前置发生">2.2 同步与前置发生</h2>
<p>Java语言提供了多种机制来同步线程，最常见的方式是锁（locking），它是使用监视器（monitors）来实现的。Java中的每个对象都关联到一个监视器，线程可以用于加锁和解锁。同一事件只有一个线程能够持有一个监控器的锁，其它尝试对该监控器加锁的线程会阻塞知道它们获取到该监控器的锁。一个线程可以对一个特定的监控器锁定多次，每个解锁都解除一个锁定操作的效果。</p>
<p>对所有的同步操作有一个总体顺序，称为同步顺序。在同步顺序中（synchronization order），我们称一个在监控器m上的锁定操作与所有之后在m上的锁定操作同步（synchronizes-with）。</p>
<p>在下述三种情况下，我们称一个动作前置发生（happens-before）于另一个:</p>
<ul>
<li>如果在程序顺序中，第一个动作在第二个动作之前</li>
<li>如果第一个动作与第二个动作同步（synchronizes-with）</li>
<li>如果你可以遵循前置发生的边界从第一个动作到达第二个（前置发生关系转移了）</li>
</ul>
<p>注意，所有这些意味着前置发生是一个局部顺序：它是反射的，可传递的，和反对称的（it is re- flexive, transitive and anti-symmetric）。现在我们可以理解为什么图2.1是合法的。以下是我们可以观察到的：</p>
<ul>
<li>一个线程中有一个写</li>
<li>另一个线程对同一变量进行了读操作</li>
<li>读和写不是按前置发生关系排列的</li>
</ul>
<p>通常，对同一共享域或数组元素，当有两个访问（读或者写）操作并且其中至少有一个是读时，我们称之为冲突（conflict， 不考虑是否存在数据竞争）。当两个冲突访问没有按照前置发生关系进行排序时我们称之为处于数据竞争中（date race）。当代码包含数据竞争时，结果常常出人意料。</p>
<p>对一个程序来说正确地进行同步意味着什么，我们使用数据竞争来进行说明。当且仅当一个程序在所有顺序一致执行中免于数据竞争，我们就说它是正确同步的（orrectly synchronized）。</p>
<p>当一个程序没有正确地同步，错误常常以三种形式出现。原子性（Atomicity）用于处理操作和操作集合所具有的不可见效果，可见性（Visibility）决定了什么时候一个线程的效果对另一个线程是可见的。排序（Ordering）决定了一个线程中的动作什么时候对另一线程而言是次序混乱的。</p>
<h2 id="23-原子性">2.3 原子性</h2>
<p>如果一个动作（或者一个动作集合）是原子的，那么其结果是一次性发生的，或者是不可分割地发生的。原子性是并发编程中常见的bug来源。实施它意味着使用锁来保证互斥。</p>
<p>Java编程语言在单一操作的原子性方面有一些小的问题。需要特别说明的是，对64位值（long和double）的写允许发生在两个分开的32位原子块。如果一个线程在两个分开的写之间调度，那么它只会看到64位值的第一半而不是第二半。在其它情况下，我们假设，所有单一读写动作都是原子的。这并不是线程模型的一部分，在此不再深究。</p>
<p>原子性也可以用于一个动作序列。没有这种类型的原子性，程序也可以免于数据竞争。然而，保证这种原子性常常和保证程序免于数据竞争一样重要。考虑图2.3所示代码，由于所有对共享变量balance的访问都是同步的，代码因此免于数据竞争。</p>
<p>图2.3
{% highlight java %}
class BrokenBankAccount {
private int balance;
synchronized int getBalance() {
return balance;
}
synchronized void setBalance(int x)
throws IllegalStateException {
balance = x;
if (balance &lt; 0) {
throw new IllegalStateException(&ldquo;Negative Balance&rdquo;);
}
}
void deposit(int x) {
int b = getBalance();
setBalance(b + x);
}
void withdraw(int x) {
int b = getBalance();
setBalance(b - x);
} 
}
{% endhighlight%}</p>
<p>假设一个线程调用了deposit(5)并且另一个线程调用了withdraw(5)，其中balance初始值为10。理想情况下，这两个调用结束后balance的值为10。然而，考虑如下情况会发生什么：</p>
<ul>
<li>deposit()方法观察到balance为10，然后</li>
<li>withdraw()方法观察到balance为10，并且取出5，得到balance为5，最后</li>
<li>deposit使用最初观察到的10来计算得到新的balance为15</li>
</ul>
<p>由于缺乏原子性，得到结果为15而非10，这种效果称为更改丢失（lost update）。一个多线程代码必须小心使用同步来避免类似错误。在Java中，如果deposit()和withdraw()声明为<strong>synchronized</strong>的就可以保证执行期间持有锁：那么这些方法就可以认为是原子的。</p>
<p>注意，同步所保证的原子性是相对的，通过在一个对象上进行同步，其它在同一对象上进行同步的线程可以观察到一个动作序列是原子的，但是不在该对象上进行的同步的线程便看不到这种原子性。</p>
<p>原子性是使用同步时研究最深入的问题，认为这个唯一的问题是一个常见的误区。事实上，多线程中还有两个重要的问题需要讨论。</p>
<h2 id="24-可见性visibility">2.4 可见性（Visibility）</h2>
<p>如果一个线程的操作对另一个线程是可见的（visible），那么该操作的结果就可以被第二个线程观察到。为了保证一个操作的结果可以被第二个操作观察到，那么第一个必须发生在第二个之前。</p>
<p>图2.4 可见性示例。
{% highlight java linenos%}
class LoopMayNeverEnd {
boolean done = false;
void work() {
while (!done) {
// do work 
}
}
void stopWork() {
done = true;
} 
}
{% endhighlight %}</p>
<p>考虑图2.4中的代码，想象现在创建了两个线程，一个线程调用work，同时，另一个线程调用了同一对象的stopWork方法。由于这两个线程之间没有前置发生关系，线程中的循环可能永远不会观察到另一个线程对done的更新。实际上，如果编译器检测到第一个线程中没有对done的写操作，编译器可能将done从循环中取出，将其转换成一个无限循环。</p>
<p>为了保证这不会发生，两个线程间必须有一个前置发生关系。这可以通过将done定义为volatile。结果是，volatile变量上的所有操作以一个单一总顺序执行，并且每个写发生在该顺序中随后的任意读之前。</p>
<p>此处还有一个附带问题，有些架构和虚拟机在执行这个程序时，可能不能保证执行work的线程放弃对cpu的占用并允许其他线程开始执行，那么这是由于调度的原因导致循环无法总结。</p>
<h2 id="25-次序ordering">2.5 次序（Ordering）</h2>
<p>次序约束管理多个操作被观察到的执行顺序。观察次序约束的能力仅仅存在于共享一个前置发生关系的操作间。图2.1已经看到过一个违反次序的例子了，以下是另外一个。</p>
<p>图2.5</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">BadlyOrdered</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">boolean</span> a <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">boolean</span> b <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">threadOne</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        a <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
        b <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">threadTwo</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">boolean</span> r1 <span style="color:#f92672">=</span> b<span style="color:#f92672">;</span> <span style="color:#75715e">// sees true
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">boolean</span> r2 <span style="color:#f92672">=</span> a<span style="color:#f92672">;</span> <span style="color:#75715e">// sees false
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">boolean</span> r3 <span style="color:#f92672">=</span> a<span style="color:#f92672">;</span> <span style="color:#75715e">// sees true
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">(</span>r1 <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>r2<span style="color:#f92672">)</span> <span style="color:#f92672">&amp;&amp;</span> r3<span style="color:#f92672">;</span> <span style="color:#75715e">// returns true
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>考虑如果threadOne()在一个线程中被调用，同一个对象的threadTwo()在另一个线程中被调用，那么threadTwo()会返回true么，这表示该线程观察到了threadOne()的更新，但是观察到对b的更新先于对a的更新（r2读到更新前的a，r3读到更新后的a）。</p>
<p>Java内存模型允许这种结果，展示了用户可以预见的一种违反次序的结果。这个代码片段没有正确同步（冲突访问没有建立一个前置发生关系）。</p>
<p>如果次序得不到保证，那么threadOne()对a和b的赋值可以不按次序执行。编译器本质上对未同步代码有重排序的自由。例如，编译器可以自由地对threadOne中的写或threadTwo中的读进行重排序。</p>
<p>为了避免这种行为，程序员必须保证代码正确地进行同步。</p>
<h2 id="26-讨论">2.6 讨论</h2>
<p>本章围绕一些基本的内存语义，我们给出了问题的一些形式：我们指出了内存模型的基本思想，即同步和前置发生关系，并且我们也看到了多线程工作的误区可能导致的原子性，可见性和次序的问题。然而，这只是主要问题的表象：我们如何以一种方式定义多线程语义，使得程序员可以避免这些问题，并且仍然允许编译器设计者和计算机架构师来优化运行时间？</p>
<p>为了解决这些问题，我们仍然需要收集更多需求。我们需要什么样的编译器优化？什么样的保证才能满足正确同步的代码？什么样保证才能满足没有正确同步的代码？</p>

                </div>
                
            </article>
        </div>
    </div>

                </div>
                <footer>
    Powered by <a target="_blank" href="https://gohugo.io/">Hugo</a> And 
    <a target="_blank" href="https://pages.github.com/">Github Pages</a>
</footer>
                <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
                

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.3.5/jquery.fancybox.min.css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.3.5/jquery.fancybox.min.js"></script>

                <link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.12.0/styles/default.min.css">
                <script src="/js/highlight.pack.js"></script>
                <script src="https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js"></script>
                <script type="text/javascript" async src="https://cdn.bootcss.com/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [
                ['$', '$'],
                ['\\(', '\\)']
            ],
            displayMath: [
                ['$$', '$$']
            ],
            processEscapes: true,
            processEnvironments: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            TeX: {
                equationNumbers: {
                    autoNumber: "AMS"
                },
                extensions: ["AMSmath.js", "AMSsymbols.js"]
            }
        }
    });
    MathJax.Hub.Queue(function () {



        var all = MathJax.Hub.getAllJax(),
            i;
        for (i = 0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });

    MathJax.Hub.Config({

        TeX: {
            equationNumbers: {
                autoNumber: "AMS"
            }
        }
    });
</script>
                <script type="text/javascript" src="/js/main.js"></script>
        </div>
    </body>

</html>