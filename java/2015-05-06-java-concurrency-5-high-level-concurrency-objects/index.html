<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta lang="zh"/>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title>
            
    Java Concurrency 5、高级并发对象 &ndash; DevNote

        </title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" type="text/css" media="screen" href="/css/main.css" />
        <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.0/css/solid.css" integrity="sha384-TbilV5Lbhlwdyc4RuIV/JhD8NR+BfMrvz4BL5QFa2we1hQu6wvREr3v6XSRfCTRp" crossorigin="anonymous">
        <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.0/css/brands.css" integrity="sha384-7xAnn7Zm3QC1jFjVc1A6v/toepoG3JXboQYzbM0jrPzou9OFXm/fY6Z/XiIebl/k" crossorigin="anonymous">
        <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.0/css/fontawesome.css" integrity="sha384-ozJwkrqb90Oa3ZNb+yKFW2lToAWYdTiF1vt8JiH5ptTGHTGcN7qdoR1F95e0kYyG" crossorigin="anonymous">
        
    <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet">
    <link rel="stylesheet" type="text/css" media="screen" href="/css/article.css" />

    </head>

    <body>
        <div class="site-wrapper">
                <header>
    <a href="https://www.jastrelax.com/">DevNote</a>
</header>
                
    <div class="main">
        <div class="article">
            <aside>
                    <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#高级并发对象-high-level-concurrency-objects">高级并发对象（High Level Concurrency Objects）</a></li>
<li><a href="#锁对象-lock-objects">锁对象（Lock Objects）</a></li>
<li><a href="#执行器-executors">执行器（Executors）</a>
<ul>
<li><a href="#执行器接口-executor-interfaces">执行器接口（Executor Interfaces）</a>
<ul>
<li><a href="#executor接口">Executor接口</a></li>
<li><a href="#executorservice-接口">ExecutorService 接口</a></li>
<li><a href="#scheduledexecutorservice-接口">ScheduledExecutorService 接口</a></li>
</ul></li>
<li><a href="#线程池-thread-pools">线程池（Thread Pools）</a></li>
<li><a href="#fork-join">Fork/Join</a>
<ul>
<li><a href="#基本使用-basic-use">基本使用（Basic Use）</a></li>
<li><a href="#照片模糊化-blurring-for-clarity">照片模糊化（Blurring for Clarity）</a></li>
<li><a href="#标准实现-standard-implementations">标准实现（Standard Implementations）</a></li>
</ul></li>
</ul></li>
<li><a href="#并发集合-concurrent-collections">并发集合（Concurrent Collections）</a></li>
<li><a href="#原子变量-atomic-variables">原子变量（Atomic Variables）</a></li>
<li><a href="#并发随机数-concurrent-random-numbers">并发随机数（Concurrent Random Numbers）</a></li>
</ul></li>
</ul>
</nav>
            </aside>
            <article>
                <div class="title">
                    <h1 id="title">Java Concurrency 5、高级并发对象</h1>
                </div>
                <div class="content">
                        

<h2 id="高级并发对象-high-level-concurrency-objects">高级并发对象（High Level Concurrency Objects）</h2>

<p>目前为止，这一教程集中于low-level并发API，它是Java平台非常初级的部分。这些API对于基础任务足矣，但更高级的构建模块需要更进行更多高级任务。现今大量充分利用多进程和多核心系统的并发应用尤其如此。</p>

<p>这一章节中，我们会看看从Java平台5.0版本引入的高级并发特性。大多数特性在新的java.util.concurrent包中实现。也有新的并发数据结构在Java Collections Framework中引入。
* 锁对象（ Lock objects）：支持锁（locking）惯用法，简化了许多并发应用
* 执行器（ Executors ）：定义了用于启动和管理线程的高级API，由 java.util.concurrent提供的Executor实现提供了适用于大型应用的线程池管理。
* 并发collections（ Concurrent collections）：使得管理大量数据集合更加简单，并极大减少了同步的需要。
* 原子变量（ Atomic variables）：具有最小化同步和帮助避免内存一致性错误的特性。
* ThreadLocalRandom（JDK 7）：从多线程中提供高效的伪随机数生成。</p>

<h2 id="锁对象-lock-objects">锁对象（Lock Objects）</h2>

<p>同步代码依赖于一种简单的重入锁（ reentrant lock），这种锁易于使用，但有许多限制。更精细的锁（locking idioms）惯用法由java.util.concurrent.locks包支持，我们不讨论该包的细节，而是集中讨论最基础的接口， Lock。</p>

<p>Lock 对象作用非常类似同步代码使用的隐式锁，像隐式锁那样，在一个时刻只能有一个线程能占有一个Lock对象。Lock对象通过其相关联的 Condition 对象，也能支持wait/notify 机制。</p>

<p>相对隐式锁Lock对象最大的优势在于其具有可以取消一个获取锁的尝试的能力，如果锁不是立即可用或者在一个暂停时间前（如果指定的话）不可用，tryLock 方法就会撤回。如果另一个线程在锁获取前发送了一个中断，lockInterruptibly方法会撤回。</p>

<p>我们可以利用Lock对象解决Liveness中的deadlock问题。Alphonse和Gaston训练他们自己去注意什么时候他的朋友要开始鞠躬了。我们将这种改进建模为需要我们的Friend对象在处理鞠躬时必须获取两个参与者的锁。以下就是改进后的代码，Safelock。为了演示这种惯用法的灵活性，我们假设Alphonse和Gaston对他们发现的安全鞠躬的新技能非常激动，以至于他们迫不及待地不停给对方鞠躬。</p>

<pre><code class="language-java">import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.Random;

public class Safelock {
    static class Friend {
        private final String name;
        private final Lock lock = new ReentrantLock();

        public Friend(String name) {
            this.name = name;
        }

        public String getName() {
            return this.name;
        }

        public boolean impendingBow(Friend bower) {
            Boolean myLock = false;
            Boolean yourLock = false;
            try {
                myLock = lock.tryLock();
                yourLock = bower.lock.tryLock();
            } finally {
                if (!(myLock &amp;&amp; yourLock)) {
                    if (myLock) {
                        lock.unlock();
                    }
                    if (yourLock) {
                        bower.lock.unlock();
                    }
                }
            }
            return myLock &amp;&amp; yourLock;
        }

        public void bow(Friend bower) {
            if (impendingBow(bower)) {
                try {
                    System.out.format(&quot;%s: %s has&quot; + &quot; bowed to me!%n&quot;, this.name, bower.getName());
                    bower.bowBack(this);
                } finally {
                    lock.unlock();
                    bower.lock.unlock();
                }
            } else {
                System.out.format(&quot;%s: %s started&quot; + &quot; to bow to me, but saw that&quot; + &quot; I was already bowing to&quot; + &quot; him.%n&quot;, this.name, bower.getName());
            }
        }

        public void bowBack(Friend bower) {
            System.out.format(&quot;%s: %s has&quot; + &quot; bowed back to me!%n&quot;, this.name, bower.getName());
        }
    }

    static class BowLoop implements Runnable {
        private Friend bower;
        private Friend bowee;

        public BowLoop(Friend bower, Friend bowee) {
            this.bower = bower;
            this.bowee = bowee;
        }

        public void run() {
            Random random = new Random();
            for (; ; ) {
                try {
                    Thread.sleep(random.nextInt(10));
                } catch (InterruptedException e) {
                }
                bowee.bow(bower);
            }
        }
    }

    public static void main(String[] args) {
        final Friend alphonse = new Friend(&quot;Alphonse&quot;);
        final Friend gaston = new Friend(&quot;Gaston&quot;);
        new Thread(new BowLoop(alphonse, gaston)).start();
        new Thread(new BowLoop(gaston, alphonse)).start();
    }
}
</code></pre>

<h2 id="执行器-executors">执行器（Executors）</h2>

<p>在所有前述示例中，被一个线程执行的任务（由该线程的Runnable对象定义）和线程本身（由一个Thread对象定义）有一个紧密的联系。对小型应用它工作良好，但在大型应用中，将线程管理和创建从应用的其余部分分离开十分有意义。将这些方法封装起来的对象称为执行器（executors），以下小结分别讨论了执行器的相关细节。
* 执行器接口（ Executor Interfaces）：定义了三种执行器对象类型。
* 线程池（ Thread Pools ）：是最常见的执行器实现。
* Fork/Join：是一个利用多处理器的框架（JDK 7中引入）。</p>

<h3 id="执行器接口-executor-interfaces">执行器接口（Executor Interfaces）</h3>

<p>java.util.concurrent包定义了三种执行器接口：
* Executor，一个支持启动新任务的简单接口。
* ExecutorService，一个Executor的子接口，添加了帮助管理单个任务以及执行器自身的生命周期的特性。
* ScheduledExecutorService，ExecutorService的子接口，支持未来的（延迟、定时）和/或周期性的任务执行。
一般，对执行器对象的引用变量由这三种接口类型中的一种来声明，而不是一个执行器类型。</p>

<h4 id="executor接口">Executor接口</h4>

<p>Executor 接口提供了单个方法，即execute，设计来对常见线程创建惯用法的非正式（drop-in）替代。如果r是一个Runnable 对象，e是一个Executor对象，你可以将：</p>

<pre><code class="language-java">(new Thread(r)).start();
</code></pre>

<p>替换为：</p>

<pre><code class="language-java">e.execute(r);
</code></pre>

<p>然而，execute方法的定义不那么具体。低层次的惯用法创建了一个新的线程并立即启动。execute方法可能会做相同的处理，但更可能使用一个已经存在的工作线程来运行 r ，或者将 r 放到一个队列中直到一个工作线程可用后再运行 r ，这取决于Executor的实现（工作线程将会在Thread Pools小节中讨论）。</p>

<p>java.util.concurrent 中的执行器实现设计为充分利用更高级的ExecutorService 和ScheduledExecutorService 接口，尽管他们和基础Executor 接口一起也可以工作。</p>

<h4 id="executorservice-接口">ExecutorService 接口</h4>

<p>ExecutorService 接口对execute方法进行了补充，提供了一个相似的但更通用（versatile ）的submit 方法。和execute方法一样，submit接收Runnable对象，但也接受Callable对象，它允许任务返回一个值。submit方法返回一个Future 对象，用于获取Callable 的返回值并且管理Callable和Runnable任务的状态。</p>

<p>ExecutorService 也提供用于提交大型Callable 对象集合的方法。最后，ExecutorService 提供了一些方法来管理执行器的关闭。为了支持立即关闭，任务应该正确地处理中断（ interrupts ）。</p>

<h4 id="scheduledexecutorservice-接口">ScheduledExecutorService 接口</h4>

<p>ScheduledExecutorService接口在其父接口ExecutorService 的基础上补充了schedule方法，可以在一个指定延迟后执行一个 Runnable 或 Callable 任务。此外，该接口还定义了scheduleAtFixedRate 和scheduleWithFixedDelay方法，可以以定义的时间间隔反复执行特定任务。</p>

<h3 id="线程池-thread-pools">线程池（Thread Pools）</h3>

<p>java.util.concurrent中大多数执行器使用线程池（ thread pools）实现，线程池包含工作线程（worker threads），这种线程与其执行的Runnable 和Callable任务分离开，并常用于执行多任务。</p>

<p>使用工作线程最小化线程创建引起的开销。线程对象会占用相当大的内存，在大型应用中，分配和解除分配许多的线程对象会导致相当大的内存管理开销。</p>

<p>线程池的一种常用类型是固定线程池（ fixed thread pool），这种类型的线程池总是有一个指定数量的线程运行，如果一个线程还在使用时因为某种原因而终结，那么它就会被一个新的线程取代。任务通过一个内部队列提交到池中，当激活的任务多余线程数时这个队列便会持有额外的任务。</p>

<p>固定线程池的一个重要的好处在于应用可以用它优雅降级（degrade gracefully），为了理解这一点，考虑一个web服务器应用，其每个HTTP请求都由一个单独的线程处理。如果应用简单地对每个新的HTTP请求创建一个新的线程，那么系统立即就会收到多于它能处理的的请求，当所有这些线程的开销超出了系统的处理能力，应用会对所有请求突然停止响应。如果只能创建有限数量的线程，虽然应用不能立即服务与每个进入的请求，但只要系统可以承受那么就会尽快处理请求。</p>

<p>创建一个使用固定线程池的执行器简单方式就是调用 java.util.concurrent.Executors中的工厂方法 newFixedThreadPool ，这个类还提供了以下工厂方法：
* newCachedThreadPool 方法创建一个带有可扩展线程池的执行器，该执行器适用于启动许多短时任务的应用。
*  newSingleThreadExecutor 创建一个一次执行一个任务的执行器。
* 若干工厂方法是上述执行器的 ScheduledExecutorService 版本。</p>

<p>如果上述工厂方法都不能提供你想要的执行器，那么创建java.util.concurrent.ThreadPoolExecutor 的实例或者使用java.util.concurrent.ScheduledThreadPoolExecutor ，会给你额外的选择。</p>

<h3 id="fork-join">Fork/Join</h3>

<p>fork/join框架是ExecutorService接口的一种实现，可以帮助你利用多处理器。它设计用于可以递归分解为更小的工作。其目标是使用所有可用的处理能力来强化应用的性能。</p>

<p>和任意的ExecutorService实现一样，fork/join框架将任务分发给线程池中的工作线程。fork/join框架不同的地方在于它使用了工作偷取（work-stealing）算法。处理完任务而无事可干的工作线程可以把仍处于忙碌状态的其他线程的任务偷取过来。</p>

<p>fork/join框架的核心是ForkJoinPool 类，它是AbstractExecutorService类的扩展。ForkJoinPool实现了核心的工作偷取算法并且执行 ForkJoinTask 过程。</p>

<h4 id="基本使用-basic-use">基本使用（Basic Use）</h4>

<p>使用 fork/join框架的第一步是编写执行工作段（a segment of the work）的代码。你的代码看上去和下述伪代码相似：
    if (my portion of the work is small enough)
    do the work directly
    else
    split my work into two pieces
    invoke the two pieces and wait for the results</p>

<p>将这一代码封装到一个ForkJoinTask 子类，一般使用它的一个更具体的类型，RecursiveTask（可以返回一个结果）或者RecursiveAction。</p>

<p>在你的ForkJoinTask子类就绪后，创建代表所有要处理任务的对象并将其传给一个ForkJoinPool 实例的invoke()方法。</p>

<h4 id="照片模糊化-blurring-for-clarity">照片模糊化（Blurring for Clarity）</h4>

<p>为了帮助你理解 fork/join 框架如何工作，考虑如下示例。假设你希望模糊一张图像。原始的源（source）图像由一个整形数组表示，其每个元素包含了单个像素的颜色值。模糊后的目标（destination ）图像也使用一个长度相同的整形数组表示。</p>

<p>模糊执行通过一次遍历源数组的一个像素。每个像素都取其周围像素的平均值（红，绿，蓝三个分量色上的平均），将结果放到目标数组。由于一个图像是一个大数组，其处理会花费较长时间。使用fork/join框架来实现该算法，你可以利用多处理器系统的并行处理能力。以下是可能的实现方法：</p>

<pre><code class="language-java">public class ForkBlur extends RecursiveAction {
    private int[] mSource;
    private int mStart;
    private int mLength;
    private int[] mDestination;
    // Processing window size; should be odd.
    private int mBlurWidth = 15;

    public ForkBlur(int[] src, int start, int length, int[] dst) {
        mSource = src;
        mStart = start;
        mLength = length;
        mDestination = dst;
    }

    protected void computeDirectly() {
        int sidePixels = (mBlurWidth - 1) / 2;
        for (int index = mStart; index &lt; mStart + mLength; index++) {
            // Calculate average.
            float rt = 0, gt = 0, bt = 0;
            for (int mi = -sidePixels; mi &lt;= sidePixels; mi++) {
                int mindex = Math.min(Math.max(mi + index, 0), mSource.length - 1);
                int pixel = mSource[mindex];
                rt += (float) ((pixel &amp; 0x00ff0000) &gt;&gt; 16) / mBlurWidth;
                gt += (float) ((pixel &amp; 0x0000ff00) &gt;&gt; 8) / mBlurWidth;
                bt += (float) ((pixel &amp; 0x000000ff) &gt;&gt; 0) / mBlurWidth;
            }
            // Reassemble destination pixel.
            int dpixel = (0xff000000) | (((int) rt) &lt;&lt; 16) | (((int) gt) &lt;&lt; 8) | (((int) bt) &lt;&lt; 0);
            mDestination[index] = dpixel;
        }
    }
    ...
</code></pre>

<p>现在你可以实现抽象方法compute()，它要么直接进行模糊处理，要么将其分为两个更小的任务。一个简单的数组长度阈值可以帮助确定工作是否执行或进行分割。</p>

<pre><code class="language-java">protected static int sThreshold = 100000;
protected void compute () {
    if (mLength &lt; sThreshold) {
        computeDirectly();
        return;
    }
    int split = mLength / 2;
    invokeAll(new ForkBlur(mSource, mStart, split, mDestination), new ForkBlur(mSource, mStart + split, mLength - split, mDestination));
}
</code></pre>

<p>如果上述方法在RecursiveAction 类的一个子类中，那么将任务设置到ForkJoinPool 中运行是直截了当的，这包含以下步骤：
1.创建一个代表所有要进行的工作的任务</p>

<pre><code class="language-java">// source image pixels are in src
// destination image pixels are in dst
ForkBlur fb = new ForkBlur(src, 0, src.length, dst);
</code></pre>

<p>2.创建将要运行任务的ForkJoinPool</p>

<pre><code class="language-java">ForkJoinPool pool = new ForkJoinPool();
</code></pre>

<p>3.运行任务</p>

<pre><code class="language-java">pool.invoke(fb);
</code></pre>

<h4 id="标准实现-standard-implementations">标准实现（Standard Implementations）</h4>

<p>除了使用fork/join框架来实现自定义的算法，并用于在多核处理器上并行执行任务（例如上述ForkBlur.java），Java SE中还有使用 fork/join框架实现的通用的有用特性。Java SE 8中的一个实现用于java.util.Arrays 类的parallelSort()方法。该方法类似sort()方法，但利用了fork/join框架的并发性。在多核系统中，对大型数组的并行排数比串行排序更加快速。然而，fork/join框架是如何被这些方法所利用超出了本文的讨论范文，更多信息请参考Java API文档。</p>

<p>fork/join 框架的另一种实现用于java.util.streams包的方法中，它是Java SE 8发行版 Project Lambda计划的一部分，更多信息请参考 Lambda Expressions章节。</p>

<h2 id="并发集合-concurrent-collections">并发集合（Concurrent Collections）</h2>

<p>java.util.concurrent包括了一些对Java Collections框架的扩展，下面列出的是最容易由集合接口提供的分类所归类：
* BlockingQueue 定义了一个FIFO数据结构，当视图添加到一个满的队列或从一个空队列中获取时会阻塞或超时。
* ConcurrentMap 是 java.util.Map的子接口，它定义了有用的原子操作。这些操作仅在key存在时移除或替换key-value对，或在仅在key不存在时添加key-value对。使这些操作具有原子性可以帮助避免同步。 ConcurrentMap的标准通用实现是 ConcurrentHashMap，它是 HashMap的并发类似物。
* ConcurrentNavigableMap是 ConcurrentMap 的子接口，它支持近似匹配。其标准通用实现是 ConcurrentSkipListMap，是 TreeMap的并发类似物。
所有这些集合都定义了添加对象到集合的操作和随后的对对象的访问或移除操作之间的前置发生关系，帮助避免了Memory Consistency Errors。</p>

<h2 id="原子变量-atomic-variables">原子变量（Atomic Variables）</h2>

<p>java.util.concurrent.atomic 包定义了用于支持在单个变量上进行原子操作的类。所有类都有get和set方法，其工作类似于在volatile变量上进行读写。也就是说，在同一个变量上，set方法与随后的get方法间具有前置发生关系。原子的compareAndSet方法也具有这些内存一致性特性，就像简单的原子算术方法应用于整形原子变量一样。</p>

<p>为了展示如何使用这个包，让我们回到之前用于阐述线程干扰的Counter类：</p>

<pre><code class="language-java">class Counter {
    private int c = 0;

    public void increment() {
        c++;
    }

    public void decrement() {
        c--;
    }

    public int value() {
        return c;
    }
}
</code></pre>

<p>一种使Counter避免线程干扰的方式是使其方法同步，像SynchronizedCounter那样：</p>

<pre><code class="language-java">class SynchronizedCounter {
    private int c = 0;

    public synchronized void increment() {
        c++;
    }

    public synchronized void decrement() {
        c--;
    }

    public synchronized int value() {
        return c;
    }
}
</code></pre>

<p>对于这个简单的示例，同步是一种可以接受的解决办法。但对一个更加复杂的类，我们或许想避免不必要的同步所带来的liveness影响。将int域修改为AtomicInteger可以让我们避免线程干扰，并且不用求助于同步，如下AtomicCounter所示：</p>

<pre><code class="language-java">import java.util.concurrent.atomic.AtomicInteger;

class AtomicCounter {
    private AtomicInteger c = new AtomicInteger(0);

    public void increment() {
        c.incrementAndGet();
    }

    public void decrement() {
        c.decrementAndGet();
    }

    public int value() {
        return c.get();
    }
}
</code></pre>

<h2 id="并发随机数-concurrent-random-numbers">并发随机数（Concurrent Random Numbers）</h2>

<p>JDK 7中，对希望在多线程或ForkJoinTasks中使用随机数的应用来说，java.util.concurrent包含了一个方便的类ThreadLocalRandom。</p>

<p>对并发访问，使用ThreadLocalRandom来代替 Math.random() 可以引起更少的竞争（contention），最终是会有更高的性能。</p>

<p>你所需做的就是调用 ThreadLocalRandom.current()，然后调用它的方法来获取一个随机数。例如：</p>

<pre><code class="language-java">int r = ThreadLocalRandom.current() .nextInt(4, 77);
</code></pre>

                </div>
                
            </article>
        </div>
    </div>

                <footer>
    Powered by <a target="_blank" href="https://gohugo.io/">Hugo</a>
</footer>
                <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
                

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.3.5/jquery.fancybox.min.css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.3.5/jquery.fancybox.min.js"></script>

                <link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.12.0/styles/default.min.css">
                <script src="/js/highlight.pack.js"></script>
                <script src="https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js"></script>
                <script type="text/javascript" async src="https://cdn.bootcss.com/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [
                ['$', '$'],
                ['\\(', '\\)']
            ],
            displayMath: [
                ['$$', '$$']
            ],
            processEscapes: true,
            processEnvironments: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            TeX: {
                equationNumbers: {
                    autoNumber: "AMS"
                },
                extensions: ["AMSmath.js", "AMSsymbols.js"]
            }
        }
    });
    MathJax.Hub.Queue(function () {



        var all = MathJax.Hub.getAllJax(),
            i;
        for (i = 0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });

    MathJax.Hub.Config({

        TeX: {
            equationNumbers: {
                autoNumber: "AMS"
            }
        }
    });
</script>
                <script type="text/javascript" src="/js/main.js"></script>
        </div>
    </body>

</html>