<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

<title>
  
     Java Concurrency 1、进程和线程 | 
    风格与布局
  
</title><meta name="description" content="Android移动应用开发"><meta name="author" content="jastrelax">

<link rel="apple-touch-icon" href="/apple-touch-icon.png" sizes="180x180">
<link rel="icon" href="/favicon-32x32.png " sizes="32x32" type="image/png">
<link rel="icon" href="/favicon-16x16.png" sizes="16x16" type="image/png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#0c344b">
<link rel="icon" href="/favicon.ico">




    
        
            <link rel="stylesheet" href="/dist/main.37ab3f61b95417873748.min.css">
        
    




<link rel="canonical" href="https://www.androidpi.com/java/core/2015-05-05-java-concurrency-1-process-and-thread/"><meta property="og:title" content="Java Concurrency 1、进程和线程" />
<meta property="og:description" content="进程和线程 并发（concurrency）编程用有两种基本的执行单元：进程和线程，在Java中，并发编程大多数只考虑线程，但进程也很重要。 一个" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.androidpi.com/java/core/2015-05-05-java-concurrency-1-process-and-thread/" />
<meta property="article:published_time" content="2015-05-05T16:21:45+08:00" />
<meta property="article:modified_time" content="2015-05-05T16:21:45+08:00" />
<meta itemprop="name" content="Java Concurrency 1、进程和线程">
<meta itemprop="description" content="进程和线程 并发（concurrency）编程用有两种基本的执行单元：进程和线程，在Java中，并发编程大多数只考虑线程，但进程也很重要。 一个">
<meta itemprop="datePublished" content="2015-05-05T16:21:45&#43;08:00" />
<meta itemprop="dateModified" content="2015-05-05T16:21:45&#43;08:00" />
<meta itemprop="wordCount" content="2805">



<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Java Concurrency 1、进程和线程"/>
<meta name="twitter:description" content="进程和线程 并发（concurrency）编程用有两种基本的执行单元：进程和线程，在Java中，并发编程大多数只考虑线程，但进程也很重要。 一个"/>

</head>
<body>
    
<nav class="navbar navbar-expand-md navbar-light bg-light fixed-top shadow-sm" id="navbar-main-menu">
    <div class="container">
        <a class="navbar-brand font-weight-bold" href="https://www.androidpi.com/">风格与布局</a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#main-menu" aria-controls="main-menu" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="main-menu">
            <ul class="navbar-nav ml-auto">
                
                    <li class="nav-item"><a class="nav-link" href="/android/">Android</a></li>
                
                    <li class="nav-item"><a class="nav-link" href="/blockchain/">Blockchain</a></li>
                
                    <li class="nav-item"><a class="nav-link" href="/book/">Books</a></li>
                
                    <li class="nav-item"><a class="nav-link" href="/cs/">CS</a></li>
                
                    <li class="nav-item"><a class="nav-link" href="/ee/">EE</a></li>
                
                    <li class="nav-item"><a class="nav-link" href="/java/">Java</a></li>
                
                    <li class="nav-item"><a class="nav-link" href="/puzzles/">Puzzles</a></li>
                
                    <li class="nav-item"><a class="nav-link" href="/web/">Web</a></li>
                
                    <li class="nav-item"><a class="nav-link" href="/backend/">后端</a></li>
                
                    <li class="nav-item"><a class="nav-link" href="/engineering/">工程与架构</a></li>
                
                    <li class="nav-item"><a class="nav-link" href="/dev/">开发</a></li>
                
            
            </ul>
        </div>
    </div>
</nav>


    
<main class="content-page container pt-7 pb-5">
    <div class="row">
        <div class="col">
            <article>
                <div class="row justify-content-center">
                    <div class="col-lg-8">
                        <h2 class="mb-3">Java Concurrency 1、进程和线程</h2>

                        <div class="content">
                            <h2 id="进程和线程">进程和线程</h2>
<p>并发（concurrency）编程用有两种基本的执行单元：进程和线程，在Java中，并发编程大多数只考虑线程，但进程也很重要。</p>
<p>一个计算机系统通常有许多活动的进程和线程，即使在仅有一个执行核心系统中，因此实际上在任意给定时刻，只有一个线程在执行任务。通过在时间上进行处理单一核心可以被多个进程和线程共享，这通过称为时间切片的系统特性来实现。</p>
<h3 id="进程processes">进程（Processes）</h3>
<p>一个进程有一个自有的执行环境，通常有一个完整的，私有的基本运行时资源集，特别是每个进程有其各自的内存空间。</p>
<p>进程常常被看做程序或应用的同义词，然而，用户看到的一个应用事实上可能由一个相互协作的进程集合组成。为了利用进程间通信，大多数操作系统支持内部进程通信（IPC，Inter Process Communication）资源，例如管道（pipes）和套子节（sockets），IPC不仅仅用于同一系统下的进程间，也可以用于不同系统的进程间。</p>
<p>大多数JVM的实现以单一进程运行，一个Java应用可以使用一个 ProcessBuilder 创建额外的进程。多进程应用在此暂不讨论。</p>
<h3 id="线程threads">线程（Threads）</h3>
<p>线程有时被称为轻量级进程（lightweight processes）。进程和线程都提供了一个执行环境，但相比进程，创建一个线程需要更少的资源。</p>
<p>线程存在与一个进程中，每个进程至少有一个线程。线程共享进程的资源，包括内存和打开的文件，这有利于高效的通信，但也有潜在的问题。</p>
<p>多线程（Multithreaded）执行Java平台的一个重要特性。每个应用至少有一个线程，如果将“系统”中进行内存管理和信号处理的形成也算在内，那么可以说是至少有若干个，但从应用程序员的角度来看，你的工作从称为主线程（main thread）的线程开始，它可以创建额外的线程。</p>
<h2 id="线程对象thread-objects">线程对象（Thread Objects）</h2>
<p>每个线程都与 Thread类的一个实例相关联，有两种基本的策略来使用Thread对象来构建并发应用。</p>
<ul>
<li>直接控制线程的创建和管理，每次当应用需要初始化一个一异步任务时仅仅需要实例化Thread就可以。</li>
<li>从应用中将线程管理抽象出来，将应用的任务传给一个执行器（executor）。</li>
</ul>
<h3 id="定义和启动一个线程">定义和启动一个线程</h3>
<p>一个应用创建了一个Thread实例后必须得提供在这个线程中运行的代码。有两种实现方式：</p>
<ul>
<li>提供一个Runnable对象， Runnable 接口仅定义一个run方法，意味着将线程执行代码包含于其中。Runnable对象传给Thread构造函数。</li>
<li>继承（ Subclass ）Thread。Thread类自身实现了Runnable接口，其自身的run方法什么也没做。一个应用子类化线程，并提供自己的run方法实现。
他们都调用Thread.start来启动新的线程。两种惯常的用法该如何选择？第一种使用Runnable对象的更加通用，因为Runnable可以用于子类化其他非Thread的类。第二种用法 在简单应用中更易用，但受限于任务类必须是Thread的子类。这里主要使用第一种方式展开讨论，不仅仅是因为这种方法更具灵活性，也更适用于后面将要讨论到的高级线程管理API。</li>
</ul>
<p>Thread类还定义了许多用于线程管理的方法。这包括static方法，这些静态方法提供线程信息，或者影响调用静态方法的线程的状态。其它方法涉及对线程和线程对象的管理，它们从其它线程中进行调用。</p>
<h3 id="使用sleep暂停执行">使用Sleep暂停执行</h3>
<p>Thread.sleep可以使当前线程暂停执行一个指定的时间长度。这是一种有效的方法，使得处理器时间被用于应用的其他线程或系统中的其他应用。sleep方法也可以用于定时，并且可以用于等待另外执行任务的线程了解本线程的时间需求，如下文中的SimplThreads实例的那样。</p>
<p>提供两个重载（overloaded）版本的sleep方法：一种可以将sleep时间设置为毫秒，另一个可以设置到纳秒，但受限于运行的操作系统，这些时间不能保证是精确的。还有，sleep周期可以被interrupts终结。在任何情形下，都不能假设sleep的调用就会使线程精确地暂停指定的时间长度。</p>
<p>The SleepMessages example uses sleep to print messages at four-second intervals:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SleepMessages</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String args<span style="color:#f92672">[])</span> <span style="color:#66d9ef">throws</span> InterruptedException <span style="color:#f92672">{</span>
        String importantInfo<span style="color:#f92672">[]</span> <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
                <span style="color:#e6db74">&#34;Mares eat oats&#34;</span><span style="color:#f92672">,</span>
                <span style="color:#e6db74">&#34;Does eat oats&#34;</span><span style="color:#f92672">,</span>
                <span style="color:#e6db74">&#34;Little lambs eat ivy&#34;</span><span style="color:#f92672">,</span>
                <span style="color:#e6db74">&#34;A kid will eat ivy too&#34;</span>
        <span style="color:#f92672">};</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> importantInfo<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">//Pause for 4 seconds
</span><span style="color:#75715e"></span>            Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">sleep</span><span style="color:#f92672">(</span>4000<span style="color:#f92672">);</span>
            <span style="color:#75715e">//Print a message
</span><span style="color:#75715e"></span>            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>importantInfo<span style="color:#f92672">[</span>i<span style="color:#f92672">]);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h2 id="中断interrupts">中断（Interrupts）</h2>
<p>中断（interrupt）就是指示一个线程停止当前正在进行的任务并且开始进行其它任务。一个线程如何响应一个中断取决于开发者，但通常的做法是将线程终结。</p>
<p>对于要被中断的线程，（另外）一个线程通过调用其Thread对象的 interrupt 方法来发送中断。为了使中断机制正确运行，被中断的线程必须支持其自己的中断。</p>
<h3 id="支持中断supporting-interruption">支持中断（Supporting Interruption）</h3>
<p>一个线程如何支持其自身的中断？这取决于它正在做的事，如果线程正在频繁调用抛出 InterruptedException的方法，在俘获异常后它仅仅简单地从run方法返回。例如，假设SleepMessages 示例中间的消息循环在一个线程的Runnable对象的run方法中，做如下改动就可以使其支持中断：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> importantInfo<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">// Pause for 4 seconds
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
        Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">sleep</span><span style="color:#f92672">(</span>4000<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>InterruptedException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// We&#39;ve been interrupted: no more messages.
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span> <span style="color:#75715e">// Print a message
</span><span style="color:#75715e"></span>    System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>importantInfo<span style="color:#f92672">[</span>i<span style="color:#f92672">]);</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>许多方法都会抛出 InterruptedException，例如sleep方法，它们都被设计为接收到一个中断时取消当前操作并立即返回。</p>
<p>如果一个线程运行了很久却没有调用到一个抛出InterruptedException的方法？那么它必须周期性地调用Thread.interrupted，在一个中断接收到后会返回true。如下所示：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> inputs<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
    heavyCrunch<span style="color:#f92672">(</span>inputs<span style="color:#f92672">[</span>i<span style="color:#f92672">]);</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">interrupted</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// We&#39;ve been interrupted: no more crunching.
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>这个简单示例中，代码简单地测试中断并在接收到中断时退出线程，在一个更复杂的应用中，抛出InterruptedException更行之有效：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">interrupted</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> InterruptedException<span style="color:#f92672">();</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>这使得可以在catch子句中进行中断处理。</p>
<h3 id="中断状态标志the-interrupt-status-flag">中断状态标志（The Interrupt Status Flag）</h3>
<p>中断机制使用称为中断状态（interrupt status）的内部标志来实现，调用Thread.interrupt设置这一标志，当一个线程通过调用静态方法Thread.interrupted来检查一个中断，中断状态便被清除。非静态方法isInterrupted，用于一个线程询问另一个线程的状态，并不改变状态标志。</p>
<p>根据约定，任意方法通过抛出InterruptedException退出，会清除中断状态，然而，中断状态总是可以立即被其它调用interrupt的线程设置。</p>
<h2 id="joins">Joins</h2>
<p>join方法允许一个线程等待另一个线程执行完毕。如果t是一个Thread对象，其线程正在执行。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">t<span style="color:#f92672">.</span><span style="color:#a6e22e">join</span><span style="color:#f92672">();</span>
</code></pre></div><p>可以使当前线程暂停执行直到t的线程终止。join的重载方法允许程序员指定一个等待时间，然而，和sleep一样，join依赖于系统计时，不能假设join会等待精确的指定时长。</p>
<p>和sleep一样，join通过退出并抛出InterruptedException来响应中断。</p>

                        </div>
                    </div>
                </div>
            </article>
        </div>
    </div>
</main>


    <footer class="footer text-center bg-dark py-6">
    <div class="container">
        <div class="row">
            <div class="col">
                <ul class="list-inline">
                    
                </ul>

                <p class="text-muted">
                    
                        Copyright &copy; 风格与布局 2020
                    
                </p>

                <p class="text-muted">
                Powered by <a href="https://gohugo.io" target="_blank">Hugo</a> with <a href="https://github.com/puresyntax71/hugo-theme-chunky-poster" target="_blank">Chunky Poster</a>.
                </p>

                <p class="text-muted">
                    <a href="http://beian.miit.gov.cn" target="_blank">蜀ICP备18005659号-1</a>
                </p>
            
            </div>
        </div>
    </div>
</footer>

    
    
        
            <script src="/dist/main.d608eadfe5ac0688902e.min.js"></script>
        
    








    
</body>
</html>
