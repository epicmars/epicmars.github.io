<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" >
        <meta lang="zh">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title>Java字节码工程：ASM开发指南2-核心API | androidpi</title>
<meta name="description" content="本文示例代码见asm-develop-guide。 核心API 类（Classes） 结构 一个编译过的类是相当简单的。事实上，与原生编译的应用不同">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" type="text/css" media="screen" href="/css/main.css" />
        <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.0/css/solid.css" integrity="sha384-TbilV5Lbhlwdyc4RuIV/JhD8NR+BfMrvz4BL5QFa2we1hQu6wvREr3v6XSRfCTRp" crossorigin="anonymous">
        <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.0/css/brands.css" integrity="sha384-7xAnn7Zm3QC1jFjVc1A6v/toepoG3JXboQYzbM0jrPzou9OFXm/fY6Z/XiIebl/k" crossorigin="anonymous">
        <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.0/css/fontawesome.css" integrity="sha384-ozJwkrqb90Oa3ZNb+yKFW2lToAWYdTiF1vt8JiH5ptTGHTGcN7qdoR1F95e0kYyG" crossorigin="anonymous">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet">
        
    <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet">
    <link rel="stylesheet" type="text/css" media="screen" href="/css/article.css" />

    </head>

    <body>
        <div class="site-wrapper">
                <header>
    <nav>
        <a class="home" href="https://www.androidpi.com/">首页</a>
    </nav>
    
</header>
                <div class="site-main">
                    
    <div class="main">
        <div class="article">
            <aside>
                    <nav id="TableOfContents">
  <ul>
    <li><a href="#核心api">核心API</a>
      <ul>
        <li><a href="#类classes">类（Classes）</a></li>
        <li><a href="#方法">方法</a></li>
        <li><a href="#元数据">元数据</a></li>
      </ul>
    </li>
    <li><a href="#参考">参考</a></li>
  </ul>
</nav>
            </aside>
            <article>
                <div class="title">
                    <h1 id="title">Java字节码工程：ASM开发指南2-核心API</h1>
                </div>
                <div class="content">
                        <p>本文示例代码见<a href="https://github.com/jastrelax/asm-develop-guide">asm-develop-guide</a>。</p>
<h2 id="核心api">核心API</h2>
<h3 id="类classes">类（Classes）</h3>
<h4 id="结构">结构</h4>
<p>一个编译过的类是相当简单的。事实上，与原生编译的应用不同，一个编译的类保留了源代码的结构信息和几乎所有的符号。一个编译过的类包含：</p>
<ul>
<li>一个描述类的修饰符（例如<code>public</code>或者<code>private</code>）、名称、超类、接口和注解的块</li>
<li>每个域声明都有一个块，每个块描述域的修饰符、名称、类型和注解</li>
<li>每个方法和构造器都有一个块，每个块描述其修饰符、名称、返回类型、参数类型和注解。它还包含方法的编译代码，以Java字节码指令序列的形式进行表示。</li>
</ul>
<p>编译过的类和源代码也有一些不同之处：</p>
<ul>
<li>一个编译过的类仅描述一个类，然而一个源代码文件可以包含多个类。例如，一个具有一个内部类的类的源码文件会编译为两个class文件：一个是主类，另一个是内部类。然而，主类文件包含对内部类的引用，定义在方法内部的内部类包含对其包围方法的引用。</li>
<li>一个编译过的类不包含注释，但可以包含类、域、方法和与这些元素相关联的代码属性。由于Java 5中引入的注解也可以用于同一的目的，属性大多数情况下没有什么作用。</li>
<li>一个编译过的类不包含<code>package</code>和<code>import</code>块，因此所有的类型名都是全限定的（fully qualified）。</li>
</ul>
<p>另一个非常重要的结构区别是一个编译过的类包含一个常量池（constant pool）块。这个池子是一个包含类中出
现的所有数值、字符串和类型常量的一个数组。在常量池块中，这些常量仅仅定义一次，并且通过其索引被类文件的其它块进行引用。下图总结了一个编译过的类的总体结构，类的精确的结构可以参考JVM规范。</p>
<p><img src="/assets/images/java/asm/compiled-class-structure.png" alt="编译类的结构"></p>
<p>另一个重要的区别是Java类型在编译过的类和源代码中的表示。</p>
<h4 id="接口和组件">接口和组件</h4>
<p>用于生成和转换编译类的ASM API是基于抽象类<code>ClassVisitor</code>的。该类中的每个方法名称对于类文件结构中具有相同名称的块。简单的块使用单个方法调用进行访问，其参数描述了内容，并且返回<code>void</code>。有些块的内容的长度是任意的并且较为复杂，它们使用一个初始方法调用进行访问，并返回一个附加的visitor类。<code>visitAnnotation</code>，<code>visitField</code>，<code>visitMethod</code>就是这样的方法，它们分别返回<code>AnnotationVisitor</code>，<code>FieldVisitor</code>，<code>MethodVisitor</code>。</p>
<p>相同的原则使用于这几种附加类。例如<code>FieldVisitor</code>的每个方法的名称对应类文件中具有相同名称的子结构，其中<code>visitAnnotation</code>方法和<code>ClassVisitor</code>类中的一样，同样返回一个<code>AnnotationVisitor</code>。</p>
<p><code>ClassVisitor</code>中的方法必须以如下顺序进行访问：</p>
<pre><code>visit visitSource? visitOuterClass? (visitAnnotaion | visitAttribute)*
(visitInnerClass | visitField | visitMethod)*
visitEnd
</code></pre>
<p>这意味着必须首先调用<code>visit</code>，随后最多调用一次<code>visitSource</code>，然后最多调用一次<code>visitOuterClass</code>，然后以任意顺序调用任意数量的<code>visitAnnotation</code>和<code>visitAttribute</code>，然后任意顺序调用任意数量的<code>visitInnerClass</code>，<code>visitField</code>和<code>visitMethod</code>，最后以<code>visitEnd</code>结尾。</p>
<p>基于<code>ClassVisitor</code>API，ASM提供了三种核心组件，用于生成和转换类：</p>
<ul>
<li><code>ClassReader</code>类，以字节数组的形式解析一个编译过的类，并调用作为<code>accept</code>方法参数的<code>ClassVisitor</code>中对应的<code>visitXxx</code>方法，它可以被视作一个事件<strong>生产者</strong>。</li>
<li><code>ClassWriter</code>类是<code>ClassVisitor</code>抽象类的子类，它字节以二进制的形式构建编译过的类。它产出一个包含编译类的字节数组，可以通过<code>toByteArray</code>方法获取。它被视作一个事件<strong>消费者</strong>。</li>
<li><code>ClassVisitor</code>类将其所有的方法调用都委托给其接收到的一个<code>ClassVisitor</code>实例。它可以被视作一个事件<strong>过滤器</strong>。</li>
</ul>
<p>这些组件的具体使用包括：</p>
<ul>
<li>解析类</li>
<li>生成类</li>
<li>转换类</li>
<li>移除类的成员</li>
<li>添加类成员</li>
<li>转换链</li>
</ul>
<h4 id="工具">工具</h4>
<ul>
<li>
<p><code>Type</code>类</p>
<p>可以用于在类型的描述符及内部名称和该类型的源代码等效形式间进行转换，它可以表示一个Java类型，也可以表示一个方法类型，可以从描述符或者一个对象构建出<code>Type</code>对象，</p>
</li>
<li>
<p><code>TraceClassVisitor</code></p>
<p>可以用于检查一个生成或转换的类是否符合期望。它提供了一种生成类的文本输出形式。</p>
</li>
<li>
<p><code>CheckClassAdapter</code></p>
<p>继承了<code>ClassVisitor</code>，在将visitXxx方法调用委托给下一个<code>ClassVisitor</code>之前，它会检查方法以合适的顺序进行调用，并且参数是有效的。</p>
</li>
<li>
<p><code>ASMifier</code></p>
<p>该类为<code>TraceClassVisitor</code>提供了一个可选的后端（它默认使用的是<code>Textifier</code>）。当联合使用<code>TraceClassVisitor</code>和<code>ASMifier</code>时，它会打印出用于生成该类的ASM源代码。</p>
</li>
</ul>
<h3 id="方法">方法</h3>
<h4 id="结构-1">结构</h4>
<p>在编译过的类中，方法的代码以字节码指令序列的形式进行存储。为了生成并转换类，知晓这些指令并理解它们如何工作是
基本要求。本节给出了这些指令的一个概述，对于完整的定义可以参考JVM规范。</p>
<h5 id="执行模型">执行模型</h5>
<p>在讲解字节码指令前有必要先熟悉JVM的执行模型。如你所知的，Java代码是执行在线程中的。每个线程有自己的执行栈(stack)，它由帧（frames）组成。每个帧代表一个方法调用：每次一个方法调用时，一个新的帧被推入当前线程的执行栈中。当方法正常或异常返回时，该帧就从执行栈中弹出，执行流在当前正在调用的方法（该方法的帧位于栈顶）中继续。</p>
<p>每个帧包含两部分：一个局部变量数组和一个操作数栈。局部变量包含可以根据索引进行访问的变量，访问的顺序可以是任意的。操作数栈中的值用作字节码指令的操作数。这意味着栈中的值只能以LIFO的顺序访问。注意不要将操作数栈与线程执行栈相混淆：执行栈中的每个帧都有其自身的操作数栈。</p>
<p>局部变量数组和操作数栈的大小取决于方法代码。它们是在编译期就确定了的，并和编译过的类的字节码指令存储在一起。因此对于一个给定方法的不同调用，不同的帧对应的本地方法变量和操作数栈的大小都是一样的。</p>
<p><img src="/assets/images/java/asm/execution-stack-and-frames.png" alt="execution stack and frames"></p>
<p>在创建时，一个帧使用一个空的栈进行初始化，其局部变量数组使用目标对象<code>this</code>（对非静态方法而已）和方法的参数进行初始化。</p>
<p>局部变量和操作数栈中的每个槽（slot）可以持有任何Java值，但<code>long</code>和<code>double</code>除外，因为它们需要两个槽。</p>
<h5 id="字节码指令">字节码指令</h5>
<p>一个字节码指令由标识指令的操作码和对应固定数量的参数组成：</p>
<ul>
<li>
<p>操作码<code>opcode</code>是一个无符号byte值，这也是字节码（bytecode）名称的由来，它有一些助记符进行标识。例如操作码<code>0</code>由助记符<code>NOP</code>标识，它对应的指令是“什么也不作”。</p>
</li>
<li>
<p>参数<code>arguments</code>是定义指令精确行为的静态值。它们跟随在操作码之后。例如<code>GOTO label</code>指令，其操作码是<code>167</code>，将label作为其参数，它指明了下一个要执行的指令。<strong>指令参数不能和指令操作码相混淆：参数值是静态可知的，并保存在编译过的代码中。而操作数是从操作数栈中获取的，仅在运行时可知</strong>。</p>
</li>
</ul>
<p>字节码指令可以分为两个类别：一个小的指令集用于在局部变量和操作数栈之间传输值。其它指令只作用于操作数栈：它们从栈中弹出一些值，计算一个结果，然后将结果压回栈中。</p>
<p><code>ILOAD, LLOAD, FLOAD, DLOAD, ALOAD</code>指令读取一个局部变量，并将其压入操作数栈中。它们将必须读取的局部变量的的索引<code>i</code>作为参数。<code>ILOAD</code>用于加载一个<code>boolean, byte, char, short, int</code>变量。<code>LLOAD, FLOAD</code>和<code>DLOAD</code>分别用于加载一个<code>long</code>，<code>float</code>和<code>double</code>值。最后，<code>ALOAD</code>用于加载任何非基础类型值，例如对象和数组引用。对应地，<code>ISTORE, LSTORE, FSTORE, DSTORE</code>和<code>ASTORE</code>指令用于从操作数栈中弹出一个值，并将其存储到局部变量中由索引<code>i</code>说指定的位置处。</p>
<p>你可以看到<code>xLOAD</code>和<code>xSTORE</code>指令是类型化的（事实上几乎所有指令都是类型化的）。这用于确保没有非法转换。事实上，将一个值存储在一个局部变量中，然后使用一个不同的类型来加载它是非法的。例如<code>ISTORE 1 ALOAD 1</code>是非法的，这样做就是允许存储一个任意的内存地址到局部变量1中，然后将这个地址转换为一个对象引用。但将一个与局部变量中当前位置类型不同的值存储到局部变量的同一位置是合法的。这意味着，一个局部变量的类型，也就是存储在这个局部变量中的值的类型在执行中是可以改变的。</p>
<p>如上所述，所有其它字节码指令仅仅可以在操作数栈上工作，它们可以被分为如下类别：</p>
<ul>
<li>
<p>栈（Stack）</p>
<p>这些指令用于操作栈中的值：<code>POP</code>将栈顶端的值弹出，<code>DUP</code>将栈顶的值进行复制后压入栈顶，<code>SWAP</code>将两个值弹出后再以原来的逆序进行压入。</p>
</li>
<li>
<p>常量（Constants）</p>
<p>这些指令将一个常量值压入操作数栈，<code>ACONST_NULL</code>压入<code>null</code>，<code>ICONST_0</code>压入整形值<code>0</code>，<code>FCONST_0</code>压入<code>0f</code>，<code>DCONST_0</code>压入<code>0d</code>，<code>BIPUSH b</code>压入<code>byte</code>值<code>b</code>，<code>SIPUSH s</code>压入短整型<code>s</code>，<code>LDC cst</code>压入任意的<code>int, float, long, double, String</code>或<code>class</code>常量值cst，等等。</p>
</li>
<li>
<p>算术与逻辑（Arithmetic and logic）</p>
<p>这些指令从操作数栈中弹出数字值，将其进行运算后再将结果压入栈中。它们没有参数，<code>xADD, xSUB, xMUL, xDIV, xREM</code>对应<code>+, -, *, /, %</code>操作，其中<code>x</code>是<code> I, L, F</code>或<code>D</code>。类似地，其它逻辑操作指令对应于作用与<code>int</code>和<code>long</code>型值的<code>&lt;&lt;, &gt;&gt;, &gt;&gt;&gt;, |, &amp;</code>和<code>^</code>操作。</p>
</li>
<li>
<p>转型（Casts）</p>
<p>这些指令从操作数栈中弹出一个值，将其转换为另一个类型，然后将结果压入栈中。它们对应于Java中的转型表达式。例如<code>I2F, F2D, L2D</code>等，将一个数字值从一个类型转换为另一个。<code>CHECKCAST t</code>将一个引用值转换为类型<code>t</code>。</p>
</li>
<li>
<p>对象（Objects）</p>
<p>这些指令用于创建对象，对其加锁，测试其类型，等。例如<code>NEW t</code>将一个类型为<code>t</code>的新对象压入栈中。</p>
</li>
<li>
<p>域（Fields）</p>
<p>这些指令读取或写入一个域的值。<code>GETFIELD owner name desc</code>弹出一个对象引用，并将该对象中名为<code>name</code>的域的值压入栈中。<code>PUTFIELD owner name desc</code>弹出一个值和一个对象引用，并将该值存储在对象的名为<code>name</code>的域中。两种情形中，对象的类型必须是<code>owner</code>，其域类型必须是<code>desc</code>。<code>GETSTATIC</code>和<code>PUTSTATIC</code>是类似的指令，但作用于静态域。</p>
</li>
<li>
<p>方法（Methods）</p>
<p>这些指令调用一个方法或一个构造器。它们从操作数栈中弹出与方法参数个数一样的值，加上目标对象本身，然后将方法调用的结果压入栈中。<code>INVOKEVIRTUAL owner name desc</code>调用类<code>owner</code>中名为<code>name</code>并且描述符为<code>desc</code>的方法。<code>INVOKESTATIC</code>用于静态方法，<code>INVOKESPECIAL</code>用于私有方法和构造器。<code>INVOKEINTERFACE</code>用于接口中定义的方法。最后，对于Java 7的类，<code>INVOKEDYNAMIC</code>用于新的动态方法调用机制。</p>
</li>
<li>
<p>数组（Arrays）</p>
<p>这些指令用于读写数组中的值。<code>xALOAD</code>指令弹出一个索引和一个数组，将索引处的数组元素压入栈中。<code>xASTORE</code>弹出一个值、一个索引和一个数组，并将该值存储到数组中索引对应的位置处。其中<code>x</code>可以是<code>I,L,F,D</code>或<code>A</code>，也可以是<code>B,C</code>或<code>S</code>。</p>
</li>
<li>
<p>跳转（Jumps）</p>
<p>如果满足条件，这些指令可以跳转到一个任意指令处，也可以进行无条件的跳转。它们用于编译<code>if, for, do, while, break</code>和<code>continue</code>指令。例如，<code>IFEQ label</code>从栈中弹出一个<code>int</code>值，如果等于<code>0</code>就跳转到<code>label</code>指定的指令处，否则会正常地执行下一条指令。还有许多其它跳转指令，例如<code>IFNE</code>或<code>IFGE</code>。最后<code>TABLESWITCH</code>和<code>LOOKUPSWITCH</code>对应于Java的<code>switch</code>语句。</p>
</li>
<li>
<p>返回（Return）</p>
<p>最后，<code>xRETURN</code>和<code>RETURN</code>指令用于终止一个方法的执行，并将其结果返回给其调用者。<code>RETURN</code>用于返回<code>void</code>的方法，<code>xRETURN</code>用于其它方法。</p>
</li>
</ul>
<h5 id="异常处理">异常处理</h5>
<p>没有进行异常捕获的字节码指令，实际上，一个方法的字节码是和一个异常处理器列表关联的，这个列表指定了当该方法的异常发生时要执行的代码。一个异常处理器类似一个<code>try catch</code>块：它有一个范围（range），对应于<code>try</code>块内容的一个指令序列，和一个对应于<code>catch</code>块内容的处理器（handler）。该范围由一个起始标签和一个结束标签指明，处理器（handler）由一个起始标签。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">sleep</span><span style="color:#f92672">(</span><span style="color:#66d9ef">long</span> d<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
        Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">sleep</span><span style="color:#f92672">(</span>d<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>InterruptedException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        e<span style="color:#f92672">.</span><span style="color:#a6e22e">printStackTrace</span><span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>可以编译为：</p>
<pre><code>TRYCATCHBLOCK try catch catch java/lang/InterruptedException 
try:
        LLOAD 0
        INVOKESTATIC java/lang/Thread sleep (J)V
        RETURN
catch:
        INVOKEVIRTUAL java/lang/InterruptedException printStackTrace ()V
        RETURN
</code></pre>
<p><code>try</code>和<code>catch</code>标签中对于的代码对应<code>try</code>块，<code>catch</code>标签后的代码对应<code>catch</code>块。<code>TRYCATCHBLOCK</code>行指定了一个覆盖<code>try</code>和<code>catch</code>标签范围的一个异常处理器，该处理器从<code>catch</code>标签开始，并处理<code>InterruptedException</code>类型的异常。这意味着，如果<code>try</code>和<code>catch</code>中任意地方抛出了一个异常，栈就会被清空，然后将异常压入空的栈中，然后从<code>catch</code>标签处继续执行。</p>
<h5 id="帧">帧</h5>
<p>Java 6或更高版本编译的类中，除了字节码指令，还有一个栈映射帧（stack map frames）用于加速JVM中的类验证过程。一个栈映射帧给出了一个方法执行中某一点处执行帧的状态。更确切地说，在执行某个指令时，它给出了帧中局部变量的每个槽的值的类型和操作数栈中每个值的类型。</p>
<p>例如考虑如下代码中的<code>getF</code>方法：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">package</span> pkg<span style="color:#f92672">;</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Bean</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> f<span style="color:#f92672">;</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getF</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">f</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setF</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> f<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">f</span> <span style="color:#f92672">=</span> f<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span> 

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">checkAndSetF</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> f<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>f <span style="color:#f92672">&gt;=</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
          <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">f</span> <span style="color:#f92672">=</span> f<span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
          <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalArgumentException<span style="color:#f92672">();</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>其<code>getF</code>方法的字节码指令为：</p>
<pre><code>ALOAD 0
GETFIELD pkg/Bean f I
IRETURN
</code></pre>
<p>我们可以定义三个栈映射帧，它分别给出了执行指令<code>ALOAD</code>，<code>GETFIELD</code>，<code>IRETURN</code>前执行帧的状态：</p>
<pre><code>执行指令前帧的状态                      指令
[pkg/Bean] []                        ALOAD 0
[pkg/Bean] [pkg/Bean]                GETFIELD
[pkg/Bean] [I]                       IRETURN
</code></pre>
<p><code>checkAndSetF</code>方法的字节码指令为：</p>
<pre><code>ILOAD 1
IFLT label
ALOAD 0
ILOAD 1
PUTFIELD pkg/Bean f I GOTO end
label:
    NEW java/lang/IllegalArgumentException
    DUP
    INVOKESPECIAL java/lang/IllegalArgumentException &lt;init&gt; ()V
    ATHROW
end:
    RETURN
</code></pre>
<p>栈映射帧可以定义为：</p>
<pre><code>执行指令前帧的状态                                           指令
[pkg/Bean I] []                                           ILOAD 1
[pkg/Bean I] [I]                                          IFLT label 
[pkg/Bean I] []                                           ALOAD 0
[pkg/Bean I] [pkg/Bean]                                   ILOAD 1  
[pkg/Bean I] [pkg/Bean I]                                 PUTFIELD
[pkg/Bean I] []                                           GOTO end 
[pkg/Bean I] []                                           label :
[pkg/Bean I] []                                           NEW
[pkg/Bean I] [Uninitialized(label)]                       DUP
[pkg/Bean I] [Uninitialized(label) Uninitialized(label)]  INVOKESPECIAL
[pkg/Bean I] [java/lang/IllegalArgumentException]         ATHROW
[pkg/Bean I] []                                           end :
[pkg/Bean I] []                                           RETURN
</code></pre>
<p>其中<code>Uninitialized(label)</code>仅用于栈映射帧中，它标示一个对象的内存已经分配了，但构造函数还没有被调用，其参数标示创建对象的指令，唯一能在这个类型的值上进行调用的就是构造方法，当其调用时，所有该类型都被替换为真实类型，在上面的代码中就是<code>IllegalArgumentException</code>。</p>
<p>上面谈到，从Java 6开始，为了节约空间，一个编译过的方法并不是每条指令对应一个帧：实际上，它仅包含跳转目标、异常处理器或跟随在无条件跳转指令后的指令所对应的帧。其它帧可以快速地从这些帧推导出。</p>
<p>在上面的<code>checkAndSetF</code>方法中，这意味着仅有两个帧被保存：一个是<code>NEW</code>指令，因为他是<code>IFLT</code>指令的目标，但又由于它跟在无条件跳转<code>GOTO</code>后。另一个是<code>RETURN</code>指令，因为它是<code>GOTO</code>指令的目标，也因为它跟在无条件跳转<code>ATHROW</code>后。</p>
<p>为了节约空间，每个帧仅存储与前一个帧不同的部分，初始帧不进行存储，因为它可以很容易从方法参数推导出。对于<code>checkAndSetF</code>方法，有两个帧必须进行存储，它们和初始帧相同，因此它们被表示为一个单字节的助记符<code>F_SAME</code>，这些帧可以放在相关字节码指令前，这样该方法最终的字节码指令如下所示：</p>
<pre><code>ILOAD 1
IFLT label
ALOAD 0
ILOAD 1
PUTFIELD pkg/Bean f I GOTO end
label:
F_SAME
        NEW java/lang/IllegalArgumentException
        DUP
        INVOKESPECIAL java/lang/IllegalArgumentException &lt;init&gt; ()V
        ATHROW
end:
F_SAME
RETURN
</code></pre>
<h4 id="接口与组件">接口与组件</h4>
<p>ASM用于生成和转换编译过的方法的API是基于<code>MethodVisitor</code>抽象类的，它由<code>ClassVisitor</code>的<code>visitMethod</code>方法返回。除了一些与方法相关的注解和调试信息，该类为每个字节码指令类型都定义了一个方法，这些类型是根据指令的参数的数量和类型进行划分的（不同于之前采用功能进行的划分）。这些方法必须以如下顺序进行调用：</p>
<pre><code>visitAnnotationDefault?
( visitAnnotation | visitParameterAnnotation | visitAttribute )* ( visitCode
( visitTryCatchBlock | visitLabel | visitFrame | visitXxxInsn | visitLocalVariable | visitLineNumber )*
visitMaxs )? visitEnd
</code></pre>
<p>基于<code>MethodVisitor</code>ASM提供了三个核心组件用于生成和转换方法：</p>
<ul>
<li><code>ClassReader</code>解析编译过的方法的内容，通过<code>accept</code>接收到的<code>ClassVisitor</code>中相应方法返回的<code>MethodVisitor</code>，然后调用该<code>MethodVisitor</code>中相应的方法。</li>
<li><code>ClassWriter</code>的<code>visitMethod</code>方法返回一个<code>MethodVisitor</code>接口的实现，它直接以二进制形式构建编译方法。</li>
<li><code>MethodVisitor</code>类将它接收到的所有方法调用委托给另一个<code>MethodVisitor</code>实例，它可以被当做一个事件过滤器。</li>
</ul>
<p>对于一个方法的栈映射帧的计算，以及局部变量和操作数栈的计算现在可以说是更容易了，但实现起来并不是十分容易。正好<code>ClassWriter</code>提供了若干选项供选择，这可以通过<code>ClassWriter</code>的构造函数参数来指定：</p>
<ul>
<li><code>new ClassWriter(0)</code>：不进行任何自动计算，必须自行计算帧，以及局部变量和操作数栈的大小。</li>
<li><code>new ClassWriter(ClassWriter.COMPUTE_MAXS)</code>：计算局部变量和操作数栈的大小，但仍然需要调用<code>visitMaxs</code>方法，可以使用任何参数，它们会被忽略并重新计算。仍然需要自行计算帧。</li>
<li><code>new ClassWriter(ClassWriter.COMPUTE_FRAMES)</code>：全部进行自动计算，你不需要调用<code>visitFrame</code>，但仍然需要调用<code>visitMaxs</code>（参数会忽略并进行自动计算）。</li>
</ul>
<p>使用该选项较为方便，但也是有代价的：<code>COMPUTE_MAXS</code>会使<code>ClassWriter</code>有10%的性能损失，<code>COMPUTE_FRAMES</code>会使<code>ClassWriter</code>变慢两倍。</p>
<p>如果你决定自行计算帧，那么你可以让<code>ClassWriter</code>来进行压缩的步骤，对此，你只需要使用<code>visitFrame(F_NEW, nLocals, locals, nStack, stack)</code>访问未压缩的帧就可以了。</p>
<p>ASM中相关的API可以实现如下功能：</p>
<ul>
<li>生成方法</li>
<li>转换方法</li>
<li>无状态转换</li>
<li>有状态转换</li>
</ul>
<h4 id="工具-1">工具</h4>
<ul>
<li>
<p>基本工具</p>
<p>除了前文介绍的若干工具，还有相应的对应于方法访问的工具：</p>
<ul>
<li>如跟踪单个方法内容的工具<code>TraceMethodVisitor</code>，</li>
<li>检查方法有效性的工具<code>CheckMethodAdapter</code>，</li>
<li>同样的还可以使用ASM代码生成工具<code>ASMifier</code>。</li>
</ul>
</li>
<li>
<p><code>AnalyzerAdapter</code></p>
<p>基于<code>visitFrame</code>所访问的帧，它可以在每个指令前计算栈映射帧（stack map frames）。根据前面介绍的，为了节约空间，也由于“其它帧可以很容易从这些帧推导出”，因此<code>visitFrame</code>仅在一个方法的某些特定指令前进行调用。当然，它仅能在对栈映射帧进行了预先计算的类中，也就是使用Java 6或更高版本的编译过的类。</p>
</li>
<li>
<p><code>LocalVariablesSorter</code></p>
<p>该方法适配器​根据局部变量在一个方法中​出现的​顺序​对他们进行重新编号​。​例如​，一个有两个参数的方法​。前面三个局部变量对应于<code>this</code>和两个参数​，因此其索引不能被改变​。那么，​第一个被读写的本地​变量​的索引会大于等于3​，给它分配索引为3，第二个分配的索引​为4​，以此类推。这个适配器​对​于在方法中​插入新的局部变量十分有用​。如果没有这个适配器就需要​在所有已经存在的​局部变量​后​添加新的​局部变量​，但不幸的是直到方法结束​​，也就是在​<code>visitMaxs</code>中，​它们的​序号都​是​未知的​。</p>
</li>
<li>
<p><code>AdviceAdapter</code></p>
<p>该方法适配器​可以用于在方法的开头插入代码​，也可以正好在​任意的<code>RETURN</code>和<code>ATHROW</code>​指令之前，即方法退出前插入代码​。构造函数的开头不能够​插入​代码​，但可以在调用了​超类的​构造器​之后​插入，该类最大的优势在于它也可以用于构造函数​，因为它是经过专门定制的，可以​识别超类构造器的调用</p>
</li>
</ul>
<h3 id="元数据">元数据</h3>
<p>Java类型的元信息包括注解、泛型以及调试信息。</p>
<h4 id="泛型">泛型</h4>
<p>例如<code>List&lt;E&gt;</code>这样的泛型类以及使用它们的类中，包含所声明的泛型类型的相关信息。在运行时字节码指令并不会用到这些信息，但可以通过反射API对这些信息进行访问，也可以用于编译器。</p>
<h5 id="结构-2">结构</h5>
<p>出于向后兼容的原因，泛型信息没有保存在类型或方法描述符中，而是存储在一个类似的结构中，即类型、方法和类签名。当涉及到泛型时就会存储这些签名（泛型不会影响方法的字节码，编译器会使用它们进行类型检查，然后在必要的时候重新引入类型转换，这样在编译方法就像这些信息不存在一样）。</p>
<h5 id="接口和组件-1">接口和组件</h5>
<p>签名相关API基于<code>SignatureVisitor</code>抽象类。用于访问类型签名、方法签名和类签名。大多数方法都是访问一个类型签名。和用于访问类的API类似，<code>SignatureReader</code>用于解析签名，并调用一个<code>SignatureVisitor</code>的相关<code>visit</code>方法，<code>SignatureWriter</code>基于它接收到的方法调用构建出一个签名。</p>
<h4 id="注解">注解</h4>
<p>如果类、域、方法和方法参数的注解，如<code>@Deprecated</code>或<code>@Override</code>的保留策略不是<code>RetentionPolicy.SOURCE</code>，那么它们会存储在编译过的class中。运行时字节码指令不会用到这些信息，但可以通过反射API访问保留策略为<code>RetentionPolicy.RUNTIME</code>的注解信息。它也可以被编译器利用。</p>
<h5 id="结构-3">结构</h5>
<p>注解有各种各样的形式，但内部其形式是一致的，都是一个注解类型以及一个名称与值对的集合。</p>
<h5 id="接口和组件-2">接口和组件</h5>
<p>生成和转换注解相关的API基于抽象类<code>AnnotationVisitor</code>。</p>
<h4 id="调试">调试</h4>
<p>使用<code>javac -g</code>编译的类包含源文件的名称，源代码行号和字节码指令间的映射，以及源代码中局部变量名和字节码中的局部变量槽间的映射。这些可选的信息用于调试器和异常栈跟踪。</p>
<h5 id="结构-4">结构</h5>
<p>源代码行号和字节码指令的映射以一个<code>(line number, label)</code>列表的形式存储与方法的代码区中：</p>
<pre><code>(n1, l1) 
(n2, l2) 
(n3, l3)
</code></pre>
<p>上面的第一个映射对表示<code>l1</code>和<code>l2</code>间的指令来自<code>n1</code>行。</p>
<p>源代码中局部变量名和字节码中的局部变量槽间的映射以<code>(name, type descriptor, type signature, start, end, index)</code>元组列表的形式存储与方法的代码区中，即在两个标签<code>start</code>和<code>end</code>之间，索引为<code>index</code>的槽的局部变量对应于源代码中局部变量的名字、类型描述符和类型签名：</p>
<pre><code>l1:
... // here slot 1 contains local variable i
l2:
... // here slot 1 contains local variable j
l3:
... // here slot 1 contains local variable i again
end :
</code></pre>
<p>对应的元组列表如下：</p>
<pre><code>(&quot;i&quot;, &quot;I&quot;, null, l1, l2, 1) 
(&quot;j&quot;, &quot;I&quot;, null, l2, l3, 1) 
(&quot;i&quot;, &quot;I&quot;, null, l3, end, 1)
</code></pre>
<h5 id="接口和组件-3">接口和组件</h5>
<p>调试信息通过<code>ClassVisitor</code>和<code>MethodVisitor</code>类的三个方法进行访问：</p>
<ul>
<li><code>visitSource</code>访问源文件名</li>
<li><code>visitLineNumber</code>访问源行号和字节码指令映射</li>
<li><code>visitLocalVariable</code>访问源代码中的局部变量和字节码中的局部变量槽映射，一次一个元组</li>
</ul>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://asm.ow2.io/">ASM</a></li>
<li><a href="https://asm.ow2.io/javadoc/overview-summary.html">ASM Java Doc</a></li>
<li><a href="https://asm.ow2.io/asm4-guide.pdf">ASM4 Guide</a></li>
</ul>

                </div>
                
            </article>
        </div>
    </div>

                </div>
                <footer>
    Powered by <a target="_blank" href="https://gohugo.io/">Hugo</a> And 
    <a target="_blank" href="https://pages.github.com/">Github Pages</a>
</footer>
                <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
                

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.3.5/jquery.fancybox.min.css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.3.5/jquery.fancybox.min.js"></script>

                <link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.12.0/styles/default.min.css">
                <script src="/js/highlight.pack.js"></script>
                <script src="https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js"></script>
                <script type="text/javascript" async src="https://cdn.bootcss.com/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [
                ['$', '$'],
                ['\\(', '\\)']
            ],
            displayMath: [
                ['$$', '$$']
            ],
            processEscapes: true,
            processEnvironments: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            TeX: {
                equationNumbers: {
                    autoNumber: "AMS"
                },
                extensions: ["AMSmath.js", "AMSsymbols.js"]
            }
        }
    });
    MathJax.Hub.Queue(function () {



        var all = MathJax.Hub.getAllJax(),
            i;
        for (i = 0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });

    MathJax.Hub.Config({

        TeX: {
            equationNumbers: {
                autoNumber: "AMS"
            }
        }
    });
</script>
                <script type="text/javascript" src="/js/main.js"></script>
        </div>
    </body>

</html>