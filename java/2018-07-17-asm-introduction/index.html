<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta lang="zh"/>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title>
            
    Java字节码工程：ASM介绍 &ndash; DevNote

        </title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" type="text/css" media="screen" href="/css/main.css" />
        <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.0/css/solid.css" integrity="sha384-TbilV5Lbhlwdyc4RuIV/JhD8NR+BfMrvz4BL5QFa2we1hQu6wvREr3v6XSRfCTRp" crossorigin="anonymous">
        <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.0/css/brands.css" integrity="sha384-7xAnn7Zm3QC1jFjVc1A6v/toepoG3JXboQYzbM0jrPzou9OFXm/fY6Z/XiIebl/k" crossorigin="anonymous">
        <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.0/css/fontawesome.css" integrity="sha384-ozJwkrqb90Oa3ZNb+yKFW2lToAWYdTiF1vt8JiH5ptTGHTGcN7qdoR1F95e0kYyG" crossorigin="anonymous">
        
    <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet">
    <link rel="stylesheet" type="text/css" media="screen" href="/css/article.css" />

    </head>

    <body>
        <div class="site-wrapper">
                <header>
    <a href="https://www.jastrelax.com/">DevNote</a>
</header>
                
    <div class="main">
        <div class="article">
            <aside>
                    <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#java字节码">Java字节码</a>
<ul>
<li><a href="#jvm-java-virtual-machine">JVM（Java Virtual Machine）</a></li>
<li><a href="#基于栈的虚拟机">基于栈的虚拟机</a></li>
</ul></li>
<li><a href="#访问者模式-visitor-pattern">访问者模式（Visitor Pattern）</a>
<ul>
<li><a href="#代码示例">代码示例：</a></li>
</ul></li>
<li><a href="#参考">参考</a></li>
</ul></li>
</ul>
</nav>
            </aside>
            <article>
                <div class="title">
                    <h1 id="title">Java字节码工程：ASM介绍</h1>
                </div>
                <div class="content">
                        

<p><strong>ASM</strong>是一个通用的Java字节码操作和分析框架。它可以用于修改已有的classes或者直接以二进制形式动态生成classes。ASM提供了一些常用的字节码转换和分析算法，据此可以构建出自定义的复杂的转换和代码分析工具。ASM提供了与其它Java字节码框架相似的功能，但其专注于性能。因为它被设计和实现得尽可能小而快，它适合用在动态系统中（但当然也可以以静态的方式使用，例如在编译器中）。</p>

<p>ASM已经用在众多工程工程中，包括：</p>

<ul>
<li><code>OpenJDK</code>，用于生成lambda call sites，并且用于Nashorn编译器中</li>
<li><code>Groovy</code>编译器和<code>Kotlin</code>编译器</li>
<li><code>Cobertura</code>和<code>Jacoco</code></li>
<li><code>CGLIB</code>，用于动态生成<a href="https://github.com/cglib/cglib/blob/RELEASE_3_2_6/cglib/src/main/java/net/sf/cglib/core/ClassEmitter.java" target="_blank"><code>proxy</code></a>类（它用在如下工程中，如<code>Mockito</code>和<code>EasyMock</code>）</li>
<li><code>Gradle</code>，用于在运行时生成一些类</li>
</ul>

<h2 id="java字节码">Java字节码</h2>

<p>Java字节码是JVM的指令集。每个指令由一个字节的操作码(opcode)，以及后面跟随的零到多个操作数(operand)组成。例如，<code>iadd</code>，接收两个整形作为操作数并且将两者相加。以下是一个Java指令集的分组，可以帮助我们快速了解Java字节码都有些什么：</p>

<ul>
<li>加载和存储（例如, aload_0, istore）</li>
<li>算术和逻辑（例如, ladd, fcmpl）</li>
<li>类型转换（例如, i2b, d2i）</li>
<li>对象创建和操作（new, putfield）</li>
<li>操作数栈管理（例如，swap，dup2）</li>
<li>控制转移（例如，ifeq，goto）</li>
<li>方法调用和返回（例如，invokespecial, areturn）</li>
</ul>

<h3 id="jvm-java-virtual-machine">JVM（Java Virtual Machine）</h3>

<p>为了理解字节码的细节，我们需要讨论Java虚拟机是如何执行字节码的。JVM是一个独立于平台的执行环境，它将Java字节码转换为机器语言并进行执行。一个JVM是一个基于栈的机器。每个线程都有一个JVM栈，栈中存储着帧。一个帧在每次调用一个方法时调用，它由一个操作数栈、一个本地变量数组和一个对当前方法所在类的运行时常量池的引用组成。</p>

<p><img src="/assets/images/java/asm/jvm-stack.gif" alt="Java虚拟机栈" /></p>

<p>更多关于JVM的知识可以参考<a href="https://www.artima.com/insidejvm/ed2/jvm.html" target="_blank">这里</a>。</p>

<h3 id="基于栈的虚拟机">基于栈的虚拟机</h3>

<p>为了更好地理解Java字节码，我们需要了解一些关于基于栈的虚拟机。一个基于栈的虚拟机的内存结构中，操作数存储于一个栈数据结构中。通过从栈中弹出数据来执行操作，处理后将它们以后进先出的顺序压回栈中。在一个基于栈的虚拟机中，将两个数字相加通常需要以如下方式进行其中20，7和“result”是操作数）：</p>

<p><img src="/assets/images/java/asm/stack-based-vm.png" alt="基于栈的虚拟机" /></p>

<p>如果你想了解更多关于这部分的内容，可以在<a href="https://markfaction.wordpress.com/2012/07/15/stack-based-vs-register-based-virtual-machine-architecture-and-the-dalvik-vm/" target="_blank">这里</a>找到更多关于基于栈的虚拟机和基于寄存器的虚拟机的知识。</p>

<p>例子，考虑如下Java代码：</p>

<pre><code class="language-java">public class Test
{
    public static void main(String[] args) {
        printOne();
        printOne();
        printTwo();
    }
    
    public static void printOne() {
        System.out.println(&quot;Hello World&quot;);
    }
    
    public static void printTwo() {
        printOne();
        printOne();
    }
}
</code></pre>

<p>我们使用<code>javac</code>来编译Java程序，然后使用<code>javap -c</code>来反编译class文件，这样就可以看到java字节码。一个Java class文件（.class文件名后缀）是一个包含Java字节码并可以在JVM中执行的文件。以下是我们得到的字节码：</p>

<pre><code class="language-java">public class Test {
  public Test();
    Code:
       0: aload_0       
       1: invokespecial #1                  // Method java/lang/Object.&quot;&quot;:()V
       4: return        

  public static void main(java.lang.String[]);
    Code:
       0: invokestatic  #2                  // Method printOne:()V
       3: invokestatic  #2                  // Method printOne:()V
       6: invokestatic  #3                  // Method printTwo:()V
       9: return        

  public static void printOne();
    Code:
       0: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;
       3: ldc           #5                  // String Hello World
       5: invokevirtual #6                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
       8: return        

  public static void printTwo();
    Code:
       0: invokestatic  #2                  // Method printOne:()V
       3: invokestatic  #2                  // Method printOne:()V
       6: return        
}
</code></pre>

<p>解析：</p>

<ul>
<li><p>看看public的Test()构造器。这个构造器的字节码包含三个操作码指令。第一个操作码，<code>aload_0</code>，将索引为0的本地变量表中的值压入到操作数栈中。本地变量表用于给方法传递参数。下一个操作码指令，<code>invokespecial</code>，调用该类的超类的构造器。因为所有没有显式地继承任何其它类的类都隐式地继承<code>java.lang.Object</code>，因此编译器提供必要的字节码来调用这个基类的构造器。在这个操作码中，操作数栈中最顶部的值被弹出。最后一个指令，<code>return</code>，仅仅返回该返回的。字节码指令的索引数字不是连续的，因为有些操作码具有一些参数，这些参数会在字节码数组中占据一些空间。</p></li>

<li><p><code>#</code>号数字是用于在常量池中查找常量的常量索引。常量池是一个表结构的数据，代表各种字符串常量、类和接口名以及其它在class文件结构和其子结构中被引用的其它常量。我们可以使用<code>javac -c -v</code>查看整个常量池。</p></li>

<li><p>Java编程语言提供了两个基本类型的方法：实例方法（<code>invokevirtual</code>）和类方法（<code>invokestatic</code>，也称静态方法）。当Java虚拟机调用了一个类方法时，它根据对象引用的类型(type)来选择调用的方法，这总是在编译时就确定了的。另一方面，当虚拟机调用一个实例方法时，它根据对象的实际的类(class)来选择调用的方法，这只在运行时可以知晓。</p></li>

<li><p>这里有一个关于Java字节码的好的<a href="http://www.ibm.com/developerworks/library/it-haggar_bytecode/" target="_blank">技术文章</a>。</p></li>
</ul>

<h2 id="访问者模式-visitor-pattern">访问者模式（Visitor Pattern）</h2>

<p>在软件工程的面向对象编程中，访问者模式是将一个算法从它所作用的对象结构上进行分离的方式。这种分离的实际效果是在无需改变这些对象结构的前提下向其中添加新的操作。</p>

<p>本质上讲，访问者模式允许一个人将新的虚方法（virtual functions）添加到一个类家族中，而无需改变类本身；取而代之的是创建一个实现了所有这些适合的特定虚方法的访问者类来达到我们的目的。访问者将实例引用作为输入，并通过双重分发（double dispatch）来实现目标。</p>

<p>访问者模式需要一个支持单分发（single dispatch）的编程语言。这种条件下，考虑两个对象，每个都是某种类类型，一个称为“element”，另一个称为“visitor”。一个元素有一个接收一个访问者作为参数的<code>accept()</code>方法。<code>accept()</code>方法调用访问者的一个<code>visit()</code>方法，元素将其自身作为参数传递给<code>visit()</code>方法。</p>

<h3 id="代码示例">代码示例：</h3>

<p>本例中我们会使用类似ASM中用于操作字节码的访问器模式来</p>

<ul>
<li>添加一个<code>accept(Visitor)</code>方法到“element”层次结构中</li>
<li>创建一个“visitor”基类</li>
</ul>

<h2 id="参考">参考</h2>

<ul>
<li><a href="https://asm.ow2.io/" target="_blank">ASM官方站点</a></li>
<li><a href="https://blog.csdn.net/conquer0715/article/details/51283610" target="_blank">ASM技术研究</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-asm30/index.html" target="_blank">AOP 的利器：ASM 3.0 介绍</a></li>
<li><a href="http://web.cs.ucla.edu/~msb/cs239-tutorial/" target="_blank">Instrumenting Java Bytecode with ASM</a></li>
</ul>

                </div>
                
            </article>
        </div>
    </div>

                <footer>
    Powered by <a target="_blank" href="https://gohugo.io/">Hugo</a>
</footer>
                <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
                

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.3.5/jquery.fancybox.min.css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.3.5/jquery.fancybox.min.js"></script>

                <link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.12.0/styles/default.min.css">
                <script src="/js/highlight.pack.js"></script>
                <script src="https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js"></script>
                <script type="text/javascript" async src="https://cdn.bootcss.com/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [
                ['$', '$'],
                ['\\(', '\\)']
            ],
            displayMath: [
                ['$$', '$$']
            ],
            processEscapes: true,
            processEnvironments: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            TeX: {
                equationNumbers: {
                    autoNumber: "AMS"
                },
                extensions: ["AMSmath.js", "AMSsymbols.js"]
            }
        }
    });
    MathJax.Hub.Queue(function () {



        var all = MathJax.Hub.getAllJax(),
            i;
        for (i = 0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });

    MathJax.Hub.Config({

        TeX: {
            equationNumbers: {
                autoNumber: "AMS"
            }
        }
    });
</script>
                <script type="text/javascript" src="/js/main.js"></script>
        </div>
    </body>

</html>