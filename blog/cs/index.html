<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>CS | AndroidPi</title>
<meta name=keywords content><meta name=description content="CS - AndroidPi"><meta name=author content="LEOY"><link rel=canonical href=https://epicmars.github.io/blog/cs/><link crossorigin=anonymous href=/assets/css/stylesheet.3045213cee0439fa94bd732879be5b19072f75f4d28f6e62dd58c34f5243e49f.css integrity="sha256-MEUhPO4EOfqUvXMoeb5bGQcvdfTSj25i3VjDT1JD5J8=" rel="preload stylesheet" as=style><link rel=icon href=https://acd-assets.alicdn.com/acd_work/tongyi/assets/logo.svg><link rel=icon type=image/png sizes=16x16 href=https://acd-assets.alicdn.com/acd_work/tongyi/assets/logo.svg><link rel=icon type=image/png sizes=32x32 href=https://acd-assets.alicdn.com/acd_work/tongyi/assets/logo.svg%22><link rel=apple-touch-icon href=https://acd-assets.alicdn.com/acd_work/tongyi/assets/logo.svg><link rel=mask-icon href=https://acd-assets.alicdn.com/acd_work/tongyi/assets/logo.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://epicmars.github.io/blog/cs/index.xml><link rel=alternate hreflang=en href=https://epicmars.github.io/blog/cs/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script defer crossorigin=anonymous src=/js/custom.f20a5212619392e989b6d24ad9ce42302014debfad4d3c8c01db030c36d03475.js integrity="sha256-8gpSEmGTkumJttJK2c5CMCAU3r+tTTyMAdsDDDbQNHU="></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.3/dist/katex.min.css integrity=sha384-Juol1FqnotbkyZUT5Z7gUPjQ9gzlwCENvUZTpQBAPxtusdwFLRy382PSDx5UUJ4/ crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.3/dist/katex.min.js integrity=sha384-97gW6UIJxnlKemYavrqDHSX3SiygeOwIZhwyOKRfSaf0JWKRVj9hLASHgFTzT+0O crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.3/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-NMEMBZ8R90"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-NMEMBZ8R90")}</script><meta property="og:title" content="CS"><meta property="og:description" content="AndroidPi"><meta property="og:type" content="website"><meta property="og:url" content="https://epicmars.github.io/blog/cs/"><meta property="og:image" content="https://epicmars.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="og:site_name" content="androidpi"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://epicmars.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="CS"><meta name=twitter:description content="AndroidPi"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blogs","item":"https://epicmars.github.io/blog/"},{"@type":"ListItem","position":2,"name":"CS","item":"https://epicmars.github.io/blog/cs/"}]}</script></head><body class=list id=top><script>const hasHeaderBg=!1</script><header class=header><div class=nav-container><nav class=nav><div class=logo><a href=/ accesskey=h title="AndroidPi (Alt + H)"><svg width="25" height="24" viewBox="0 0 25 24" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><linearGradient x1="76.7202373%" y1="41.6070847%" x2="18.306123%" y2="65.5065085%" id="linearGradient-9_1k7ha4jv-1"><stop stop-color="#797beb" offset="0"/><stop stop-color="#373080" offset="100%"/></linearGradient></defs><g id="Symbols" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="_编组-7" fill="url(#linearGradient-9_1k7ha4jv-1)"><path d="M12.2746711.0C12.5125388.0 12.7434104.12583746 12.8693403.33556656l1.3852293 2.3769298h6.1425827C20.63502 2.71249636 20.8658915 2.83833382 20.9918215 3.04806292l1.7420308 2.97815322C22.8597822 6.23594524 22.8597822 6.5016021 22.7338523 6.7113312L22.6988718 6.76725896C22.6708873 6.80920478 22.6359068 6.8511506 22.5939301 6.88610545L21.2156969 9.24905331l3.050303 5.24322749L24.3429571 14.6041363C24.4339065 14.8138654 24.4548948 15.0795223 24.3919298 15.2682785l-1.6021086 2.7404602C22.6638912 18.2184678 22.4400158 18.3443053 22.195152 18.3443053L19.4176972 18.3582872 16.353402 23.6504515C16.227472 23.8601806 16.0035966 23.9860181 15.7587328 23.9860181L12.2886633 24H12.2396906C12.0158151 23.9860181 11.7989358 23.8601806 11.6869981 23.6644334l-1.490171-2.551704H4.13120166C4.0822289 21.1267113 4.04025225 21.1267113 3.9912795 21.1267113 3.75341183 21.1267113 3.52254028 21.0008739 3.39661034 20.7911448L1.79450165 18.0506845C1.66857171 17.8479464 1.66857171 17.5892805 1.79450165 17.3725604l1.37823324-2.3909117L.0944474553 9.69647539c-.1259299404-.20273813-.1259299404-.46140402.0-.678124089999999L1.80849387 6.02621614c.11193772-.2097291.34280928-.33556656.59466916-.33556656C2.466128 5.67666764 2.51510075 5.69064958 2.56407351 5.70463152H5.40449327L8.44080406.46140402C8.45479628.4194582 8.46179238.38450335 8.48278071.35653947L8.49677292.33556656C8.62270286.12583746 8.84657831.0 9.09144209.0H12.2816672 12.2746711zM9.04246933.72706088 5.74730256 6.41071949H2.3751786L8.93752771 17.6871541H5.59338819l-1.61610091 2.789397H10.5606247l1.6790659 2.8942616 6.5623491-11.3043985 1.6790659 2.8802797L23.7203035 14.9327119 20.4181406 9.24905331l1.6650737-2.8662977L9.00049268 6.39673755 10.6795586 3.51645791 9.04946544.72706088H9.04246933zM16.1435187 9.82930382 12.2187023 16.5755899 8.2938858 9.82930382h7.8496329z" id="_形状"/></g></g></svg></a><div class=logo-switches></div></div><ul id=menu><li><a href=/resources title=Resources><span>Resources</span></a></li><li><a href=/blog/ title=Blog><span>Blog</span></a></li><li><a href=/publication title=Publication><span>Publication</span></a></li><li><a href=/about title=About><span>About</span></a></li></ul></nav></div></header><div class=hero-container><div class=hero><h1 class=post-title>CS</h1></div></div><main class=main><article class=post-entry><header class=entry-header><h2>HTTPS与SSL/TLS协议</h2></header><div class=entry-content><p>HTTPS(Hypertext Transfer Protocol Secure)译为超文本传输安全协议，也称为HTTP over TLS，HTTP over SSL或HTTP Secure，它对HTTP协议进行的扩展，用于在计算机网络上进行安全通信。其主要目的是对站点服务器进行身份认证，保护交换数据的隐私与完整性。
SSL/TLS协议 HTTP协议位于TCP/IP四层模型最高层的应用层。HTTPS是在HTTP所在的应用层加入一个子层，位于HTTP子层之下，传输层之上。
根据RFC:
TLS协议的主要目的是为两个通信应用间提供隐私与数据完整性。该协议主要由两层组成：TLS Record协议和TLS Handshake协议。在某个稳定的传输协议（如TCP）之上，在最底层是TLS Record协议。
TLS Record协议所提供的连接安全性有两个基本属性：
连接是私有的。
对称加密用于数据加密（例如AES, RC4等），每个连接都会生成唯一的对称加密秘钥，并且该秘钥是基于另一个协议（例如TLS Handshake协议）经过协商后的秘钥得来的。Record协议也可以不使用加密。
连接是可靠的。
消息传输包含一个使用一个使用秘钥的MAC的消息完整性检查。安全哈希函数（例如，SHA-1等）用于MAC计算。Record协议可以不使用MAC进行运行，但这种情况通常仅使用在这种模式下，即另一个协议将Record协议作为协商安全参数的传输器。
TLS Record协议用于封装更高层级的协议。其中一个就是TLS Handshake协议，它允许服务器和客户端对彼此进行认证并且在应用层协议传输和接收数据的第一个字节前协商一个加密算法以及要使用的秘钥。
TLS Handshake协议提供的连接安全性有三个基本性质：
对等端的身份可以使用非对称加密或公钥密码学（如，RSA，DSA等）进行认证，这种认证是可选的，但一般需要对等端至少一方进行认证。
对共享秘钥的协商是安全的：协商的秘钥是不能被窃听者获取的，并且对任意未认证的连接都不能获取到秘钥，即使攻击者位于连接的中间。
协商是可靠的：没有攻击者能够修改协商通信内容并且不被通信方发现。
TLS的一项优点是它是与应用协议独立的，更高层级的协议可以透明地置于TLS协议之上。TLS标准并没有指定什么协议可以使用TLS来添加安全性，如何初始化TLS握手以及如何解释认证证书交换的决定留给TLS之上的协议的设计者和实现者。
HTTPS连接的建立与加密通信 在实现中，SSL/TLS子层作为HTTP子层和传输层的中间层，对套接字接口进行了一层封装，用于建立安全连接与通信。会话状态的加密参数是通过TLS握手协议来生成的，当一个TLS客户端和服务端首次开始进行通信时，它们在一个协议版本上达成一致、选择密码学算法、可选地对对方进行认证，并使用公钥加密技术来生成共享秘钥。
它包含如下步骤：
交换hello消息来对算法达成一致，交换随机值并进行恢复会话的检查 交换必要的机密参数，运行客户端和服务端对预主密钥（premaster secret）达成一致 交换证书和密码学信息，允许客户端和服务端对彼此进行认证 从预主密钥（premaster secret）生成一个主密钥并交换随机值 为Record层提供安全参数 允许客户端和服务端确认它们的对等端计算出相同的安全参数并且握手没有被攻击者干预 TLS握手的完整步骤如下所示（其中带*表示可选的或根据情况进行发送的消息，并不总是会发送）：
Client Server
ClientHello -------->
ServerHello
Certificate*
ServerKeyExchange*
CertificateRequest*
&lt;-------- ServerHelloDone
Certificate*
ClientKeyExchange
CertificateVerify*
[ChangeCipherSpec]
Finished -------->
[ChangeCipherSpec]
&lt;-------- Finished
Application Data &lt;-------> Application Data
可以使用openssl提供的工具来查看这一步骤的实际数据交换情况：...</p></div><footer class=entry-footer><span title='2018-08-10 21:14:48 +0800 CST'>August 10, 2018</span>&nbsp;·&nbsp;26 min&nbsp;·&nbsp;5368 words&nbsp;·&nbsp;LEOY</footer><a class=entry-link aria-label="post link to HTTPS与SSL/TLS协议" href=https://epicmars.github.io/blog/cs/networks/2018-08-10-https/></a></article><article class=post-entry><header class=entry-header><h2>CA与SSL/TLS证书</h2></header><div class=entry-content><p>CA 证书颁发机构（CA, Certificate Authorities）根据认证操作规则 (CPS) 授权颁发、暂停、更新或取消证书的实体。在其颁发的所有证书和 CRL 中都可通过识别名称来识别 CA。证书颁发机构必须公布其公钥，或者如果该证书颁发机构隶属一级证书颁发机构，则由更高级的 CA 提供证书证明其公钥的合法性。
数字证书（Digital Certificates）是可进行验证的包含身份证明的小的数据文件，它可以帮助网站、个人、设备来代表他们真实可信的在线身份（可信是因为CA已经对身份进行了验证）。CA在互联网上的操作以及如何进行透明可信的事务中扮演了关键角色。每年，证书机构都会颁发上百万的数字证书，它们用于保护信息，加密数以十亿计的事务，并确保安全的通信。
如何保证CA可信 浏览器、操作系统和移动设备会运行一个已授权的CA成员资格程序，其中一个CA必须满足详细的标准才能够被接受作为其中一员。一旦所接受的CA能够颁发直接被浏览器信任的证书，随后，人们和设备就可以依赖该证书进行工作。仅有少量经过授权的CA，从私有公司到政府机构都有，并且CA运作的越久，就会有越多的浏览器和设备信任该CA颁发的证书。
在颁发一个数字证书前，CA会对申请者的身份进行一些检查。这些检查与所申请的证书类型相关，例如，一个对域名所有权进行验证的SSL证书（Domain Validated (DV SSL) Certificates）会将已经验证了所有权的域名包含到证书中。而一个可扩展SSL(Extended Validation SSL)会包含公司相关的额外信息，这些信息由CA通过许多公司检查进行验证。
证书有许多种类型，不仅仅是支持SSL，还可以用于对人员和设备进行认证，对代码和文档添加合法性证明等。
PKI与信任层级 浏览器和设备通过在其根证书库（Root Store）中接受根证书（Root Certificate）来信任一个CA，这个根证书库本质上是一个预先安装在浏览器或设备上的已信任CA数据库。Windows、Apple、Mozilla以及一般的移动媒介都运行自己的根证书库。
各CA使用这些预安装的根证书来办法中介根证书和终端实体数字证书。CA接收证书请求，验证申请者，颁发证书，并对依赖于该证书的任何人发布已颁发证书的持续的有效性状态。
CA通常会创建一些中介CA（ICA，Intermediate CA）,用于办法终端实体证书，如SSL证书，这称为一个信任层次。
遵循最佳安全实践，CA不应该直接从发布给媒介的根证书来颁发数字证书，而应该通过一个或多个ICA。
CA是如何运作的 作为互联网中一个可信任的锚点，CA具有重大的责任。因此，在满足可审计的需求下运行一个CA是一个复杂的任务。一个CA基础设施由大量运作元素，硬件、软件、政策框架以及实践声明、审计、安保基础设施和人员组成。总体上，这些元素称为一个可信任的PKI(Public Key Infrastructure)。
SSL与TLS SSL(Secure Socket Layers)是指安全套接字层，它是一项标准技术，用于确保互联网连接安全。 TLS(Transport Layer Security)指传输层安全，它是SSL的升级版。
历史简介 SSL和TLS都是加密协议，用于提供服务器、设备、应用在网络上的认证和数据加密。SSL是先于TLS设计出的，最初它是由网景公司于1995年首先公布的，最初的版本是SSL2.0（SSL1.0从未公开发布）。在修正若干缺陷后，1996年版本2.0迅速被SSL3.0所取代。
TLS在1999年作为基于SSL3.0的一个新版本被发布，根据RFC2246：
该协议和SSL3.0没有十分巨大的差别，但已有的差别就足以使得两者不能进行互操作。
SSL2.0和SSL3.0分别在2011和2015年已经被IETF废弃，因此现在应该使用TLS协议。
SSL和TLS采用不同的加密方式。
SSL和TLS仅仅指客端和服务器端进行的握手，握手并没有进行任何加密，它仅仅是对需要共享的秘钥和加密类型上达成一致。
SSL/TLS证书 SSL证书是数字证书的一种，它用于将一个网站服务器的所有者详情和加密秘钥进行绑定。在浏览器和持有SSL证书的服务器之间，这些秘钥用于在SSL/TLS协议中激活一个安全会话。为了让浏览器相信一个SSL证书，并在不引起安全性警告的前提下建立SSL/TLS会话，SSL证书必须包含网站的域名，并且由可信任的CA颁发，并且没有过期。
SSL证书的功能 因此SSL证书主要有两个功能：
认证与验证
SSL证书中包含有关于一个人、商业或站点的身份的特定细节的可靠性信息。其中CA颁发的扩展验证SSL证书对申请人的审查标准最为严格，因此它是最值得信赖的SSL证书。
数据加密
SSL证书也可以进行加密，也就意味着通过网络交换的敏感信息不回被第三者窃取并破译出。
其用途举例如下：
保障站点和用户浏览器通信的安全 保障企业内网内部通信的安全 保障通过网络进行的邮件通信的安全 保障通过因特网或内网进行的服务器间通信的安全 保障移动设备收发信息的安全 SSL证书的类型 目前有如下几种不同类型的证书：
自签发证书
主要用于内部使用的非CA颁发的证书。如果在外部使用，因为其不具备可信任的身份认证能力，不能用于辨别伪造的服务器。
域名验证证书
可以快速进行颁发的入门级SSL证书。对申请人的验证中唯一需要确认的是其对域名的所有权。
完全认证证书...</p></div><footer class=entry-footer><span title='2018-08-10 19:50:14 +0800 CST'>August 10, 2018</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;89 words&nbsp;·&nbsp;LEOY</footer><a class=entry-link aria-label="post link to CA与SSL/TLS证书" href=https://epicmars.github.io/blog/cs/networks/2018-08-10-ca-and-ssl-tls-certificates/></a></article><article class=post-entry><header class=entry-header><h2>动态规划</h2></header><div class=entry-content><p>动态规划（Dynamic programming）通常用来解决最优化问题，在这类问题中，通过做出一组选择来达到最优解。在做出每个选择的同时，通常会生成与原问题形式相同的子问题。当多于一个选择子集都生成相同的子问题时，动态规划技术通常就会很有效，其关键技术就是对每个这样的子问题都保存其解，当重复出现时即可便重复求解。
动态规划与分治方法相似，都是通过组合子问题的解来求解原问题，分治法将问题划分为不相交的子问题，递归地求解子问题，再将它们组合起来求出原问题的解。与之相反，动态规划应用于子问题重叠的情况，即不同的子问题具有公共的子子问题（子问题的求解是递归进行的，将其划分为更小的子子问题）。
实现方法 与朴素递归算法之所以效率很低，是因为它反复求解相同的子问题。因此，动态规划方法仔细安排求解顺序，对每个子问题只求解一次，并将结果保存下来，如果随后再次需要此子问题的解，只需查找保存的结果，而不必重新计算。因此，动态规划方法是通过额外的空间来换取时间，是典型的时空权衡（time-memory trade-off）的例子。并且时间上的节约可能是非常巨大的，可能将一个指数时间的解转化为一个多项式时间的解。动态规划有两种等价的实现方法，分别是带备忘的自顶向下法和自底向上法。
带备忘的自顶向下法(top-down with memoization)
此方法仍按自然的递归形式编写过程，但过程会保存每个子问题的解（通常保存在一个数组或散列表中)。当需要一个子问题的解时，过程首先检查是否已经保存过此解。如果是则直接返回保存的值，从而节省了计算时间，否则，按通常的方式计算这个子问题。
自底向上法(bottom-up method)
这种方法一般需要恰当定义子问题“规模”的概念，使得任何子问题的求解都只依赖于“更小的”子问题的求解。因而可以将子问题按规模排序，按由小至大的顺序进行求解。当求解某个大问题时，它所依赖的那些更小的子问题都已经求解完毕，结果已经保存。么个子问题只需求解一次，当我们求解它时，它所有的前提子问题都已经求解完成。
两种方法得到的算法具有相同的渐进运行时间，仅有的差异是在某些特殊情况下，自顶向下的方法并未真正递归地考察所有可能的子问题。由于没有频繁递归函数调用的开销，自底向上方法的时间复杂度函数通常具有更小的系数。
子问题图 在思考一个动态规划问题时，应该弄清楚所涉及的子问题和子问题之间的依赖关系。问题的子问题图准确第表达了这些信息。它是一个有向图，每个顶点对应一个子问题，若求解子问题x的最优解时需要直接用到子问题y的最优解，那么在子问题图中就有一条从子问题x的顶点到子问题y的顶点的有向边。
自底向上的动态规划方法处理子问题图中顶点的顺序为：对于一个给定的子问题x，在求解它之前求解邻接到它的子问题y。即自底向上动态规划算法是按“逆拓扑序（reserve topological sort）”来处理子问题图中的顶点。类似，可以用“深度优先搜索”来描述自顶向下动态规划算法处理子问题的顺序。</p></div><footer class=entry-footer><span title='2017-12-04 01:21:55 +0800 CST'>December 4, 2017</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;19 words&nbsp;·&nbsp;LEOY</footer><a class=entry-link aria-label="post link to 动态规划" href=https://epicmars.github.io/blog/cs/algorithm/advanced/2017-12-04-dynamic-programming/></a></article><article class=post-entry><header class=entry-header><h2>图的表示与搜索</h2></header><div class=entry-content><p>图论问题渗透整个计算机科学，解决图论问题的相关算法对计算机科学领域至关重要。最基本的是对图的遍历与搜索，不过首先要讨论的是如何将图表示为可用的数据结构。
图的表示 算法导论中介绍了图的两种常用表示方法，分别是邻接链表和邻接矩阵，在面向对象编程中，还有一种常用表示方法，即对象和指针（引用），也有称为边列表（edge list）。
根据图的定义，有向图和无向图均由一个顶点集合和这个顶点集合$V$中顶点间是否连接以及是否有向所构成的一个边集合$E$组成，定义图为顶点集和相应边集的二元组\(G = (V, E)\)，对图的三种表示形式只是对这一定义在编程语言或者说是内存中的表示形式。其中对象和指针（边列表）表示方法是最接近原始的定义的，即顶点集合与边集合。
将图的n个顶点使用0到n-1的序号进行编号，下面分别对三种表示方法进行描述，并比较其在如下几个方面的不同：
内存占用 判断两个顶点是否相连(即连接这两个顶点的边是否存在)的时间复杂度 寻找一个顶点的所有邻居顶点 对象指针（边列表） 对象指针 Set&lt;Vertex> vertexSet = new HashSet(); Set&lt;Edge> edgeSet = new HashSet(); Vertex a = new Vertex(0); Vertex b = new Vertex(1); Vertex c = new Vertex(2); Vertex d = new Vertex(3); vertexSet.add(Arrays.asList({})); edgeSet.addAll(Arrays.asList({new Edge(a, b), new Edge(a, c), new Edge(a, d), new Edge(b, a), new Edge(c, a), new Edge(c, d), new Edge(d, a), new Edge(d, c)})); 边列表 边列表中的每个元素表示两个相邻顶点构成的边，其中顶点用其序号给出。 int[][] edgeList = {{0, 1}, {0, 2}, {0, 3}, {1, 0}, {2, 0}, {2, 3}, {3, 0}, {3, 2}}; 邻接链表 邻接链表中第$i$个元素包含与顶点$v[i]$相邻的其它顶点的序号：...</p></div><footer class=entry-footer><span title='2017-12-03 04:50:28 +0800 CST'>December 3, 2017</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;183 words&nbsp;·&nbsp;LEOY</footer><a class=entry-link aria-label="post link to 图的表示与搜索" href=https://epicmars.github.io/blog/cs/algorithm/graph/2017-12-03-graph-representation-and-searching/></a></article><article class=post-entry><header class=entry-header><h2>红黑树</h2></header><div class=entry-content><p>在二叉搜索树的讨论中可以得出各种查询以及插入、删除操作的时间复杂度上界为$O(h)$，其中$h$为树的高度，即树的叶子节点的最大深度。
因此树的高度很大程度上决定了动态集合操作的时间复杂度。对于一个包含确定数量元素的二叉搜索树，我们希望得到一棵较为“平衡”的二叉树，即后代结点能够较均匀分布在一个祖先结点的两颗子树中，这样相对于元素总量，其高度是一个较小的值。因此，可以将平衡的度量认为是树高h与结点总量n的比率$\frac{h}{n}$，即结点对树高的平均贡献率。
考察树的第i层的$k_i$个结点，有：
$$ n = \sum\limits_{i=0}^h k_i, \space k_i \leq 2^i $$
如果树中有大量不平衡的结点，那么每个第i层的结点越少，会导致树高$h$越大。
红黑树及其性质 红黑树是平衡二叉搜索树的一种，可以保证最坏情况下动态集合操作的时间复杂度为$O(\lg n)$，它在每个结点上增加一个存储位来表示结点颜色，可以是RED或BLACK，通过对任一条从根到叶子结点的路径上各个结点的颜色进行约束，可以确保没有一条路径会比其它路径长出2倍，因而是近似于平衡的。
一棵红黑树中的每个结点包含5个属性，color，key，left，right和p，如果一个结点没有子结点或父结点，这改结点相应指针属性的值为NIL，可以把这些NIL视为指向二叉搜索树的叶结点（外部结点）的指针，而把带关键字的结点视为树的内部结点。
一棵红黑树是满足下面红黑性质的二叉搜索树：
每个结点是红色的或黑色的 根结点是黑色的 每个叶结点（NIL）是黑色的 如果一个结点是红色的，则它的两个子结点都是黑色的 对每个结点，从该结点到所有后代叶结点的简单路径上，均包含相同数目的黑色结点 从某个结点x出发(不含该结点)到达一个叶结点的任意一条简单路径上的黑色结点个数称为该结点的黑高(black height)，定义红黑树的黑高为其根结点的黑高。
红黑树动态集合操作 对不修改树的数据结构的操作，如遍历、查询、最大、最小、前驱、后继一类操作对红黑树和普通二叉搜索树都是一样的，对于插入与删除操作，红黑树需要进行额外的变换，不仅改变数据结构，也需要改变结点的颜色以保证红黑树的性质。
旋转 对于数据结构的修改，可以通过旋转来完成，它是能保持二叉搜索树的性质的局部操作。主要有两种旋转方式，分别为左旋和右旋。
插入 首先采用稍作修改的普通二叉搜索树插入方法将新的结点插入到树中，为了保证红黑树的性质，还需要对结点进行着色和旋转操作。
删除 首先采用进行了一定修改的普通的二叉搜索树删除方法将给定结点z从树T中删除，其中需要维持一个结点y为从树中删除的结点或移至树内的结点，并记录y的初始颜色，如果y的初始颜色为黑色，那么需要进行着色和旋转操作来恢复红黑性质。此外还要跟踪移动到结点y原来位置的x结点，因为它也有可能破坏红黑树性质。</p></div><footer class=entry-footer><span title='2017-12-02 16:02:18 +0800 CST'>December 2, 2017</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;34 words&nbsp;·&nbsp;LEOY</footer><a class=entry-link aria-label="post link to 红黑树" href=https://epicmars.github.io/blog/cs/algorithm/tree/2017-12-02-red-black-tree/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://epicmars.github.io/blog/cs/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2024 <a href=https://epicmars.github.io/>AndroidPi</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 8" fill="currentcolor"><path d="M12 8H0l6-8z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script></body></html>