<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Android View事件处理机制与分发流程 | AndroidPi</title>
<meta name=keywords content><meta name=description content="View类还包含一系列嵌套接口以及您可以更加轻松定义的回调。 这些接口称为事件侦听器，是您捕获用户与UI之间交互的票证。
尽管您通常会使用事件侦听器来侦听用户交互，但有时您确实需要扩展View类以构建自定义组件。也许，您想扩展 Button类来丰富某些内容的样式。 在这种情况下，您将能够使用该类的事件处理程序为类定义默认事件行为。
API 事件侦听器（Event Listeners） 事件侦听器是View类中包含一个回调方法的接口。 当用户与UI项目之间的交互触发已注册此视图的侦听器时，Android框架将调用这些方法。
各事件侦听器接口包含的回调方法如下：
onClick()
在 View.OnClickListener 中。 当用户触摸项目（处于触摸模式下）时，或者使用导航键或轨迹球聚焦于项目，然后按适用的“Enter”键或按下轨迹球时，将调用此方法。
onLongClick()
在 View.OnLongClickListener 中。 当用户触摸并按住项目（处于触摸模式下）时，或者使用导航键或轨迹球聚焦于项目，然后按住适用的“Enter”键或按住轨迹球（持续一秒钟）时，将调用此方法。
onFocusChange()
在 View.OnFocusChangeListener 中。 当用户使用导航键或轨迹球导航到或远离项目时，将调用此方法。 onKey() 在 View.OnKeyListener 中。 当用户聚焦于项目并按下或释放设备上的硬按键时，将调用此方法。
onTouch()
在 View.OnTouchListener 中。 当用户执行可视为触摸事件的操作时，其中包括按下、释放或屏幕上的任何移动手势（在项目边界内），将调用此方法。
onCreateContextMenu()
在 View.OnCreateContextMenuListener 中。 当（因持续“长按”而）生成上下文菜单时，将调用此方法。请参见菜单开发者指南中有关上下文菜单的阐述。 这些方法是其相应接口的唯一成员。
请注意，上述示例中的 onClick() 回调没有返回值，但是其他某些事件侦听器方法必须返回布尔值。具体原因取决于事件。 对于这几个事件侦听器，必须返回布尔值的原因如下：
onLongClick()：此方法返回一个布尔值，表示您是否已处理完事件，以及是否应该将它继续传下去。 也就是说，返回 true 表示您已经处理事件且事件应就此停止；如果您尚未处理事件和/或事件应该继续传递给其他任何点击侦听器，则返回 false。 onKey()：此方法返回一个布尔值，表示您是否已处理完事件，以及是否应该将它继续传下去。 也就是说，返回 true 表示您已经处理事件且事件应就此停止；如果您尚未处理事件和/或事件应该继续传递给其他任何按键侦听器，则返回 false。 onTouch()： 此方法返回一个布尔值，表示侦听器是否处理完此事件。重要的是，此事件可以拥有多个分先后顺序的操作。 因此，如果在收到关闭操作事件时返回 false，则表示您并未处理完此事件，而且对其后续操作也不感兴趣。 因此，您无需执行事件内的任何其他操作，如手势或最终操作事件。 事件处理程序(Event Handlers) 如果您从视图构建自定义组件，则将能够定义几种用作默认事件处理程序的回调方法。在有关自定义组件的文档中，您将了解某些用于事件处理的常见回调，其中包括：
onKeyDown(int, KeyEvent)：在发生新的按键事件时调用 onKeyUp(int, KeyEvent)：在发生按键弹起事件时调用 onTrackballEvent(MotionEvent)：在发生轨迹球运动事件时调用 onTouchEvent(MotionEvent)：在发生触摸屏运动事件时调用 onFocusChanged(boolean, int, Rect)：在视图获得或失去焦点时调用 还有一些其他方法值得您注意，尽管它们并非 View 类的一部分，但可能会直接影响所能采取的事件处理方式。 因此，在管理布局内更复杂的事件时，请考虑使用以下其他方法："><meta name=author content="LEOY"><link rel=canonical href=https://epicmars.github.io/blog/android/framework/2018-03-11-android-view-event-dispatching/><link crossorigin=anonymous href=/assets/css/stylesheet.3045213cee0439fa94bd732879be5b19072f75f4d28f6e62dd58c34f5243e49f.css integrity="sha256-MEUhPO4EOfqUvXMoeb5bGQcvdfTSj25i3VjDT1JD5J8=" rel="preload stylesheet" as=style><link rel=icon href=https://acd-assets.alicdn.com/acd_work/tongyi/assets/logo.svg><link rel=icon type=image/png sizes=16x16 href=https://acd-assets.alicdn.com/acd_work/tongyi/assets/logo.svg><link rel=icon type=image/png sizes=32x32 href=https://acd-assets.alicdn.com/acd_work/tongyi/assets/logo.svg%22><link rel=apple-touch-icon href=https://acd-assets.alicdn.com/acd_work/tongyi/assets/logo.svg><link rel=mask-icon href=https://acd-assets.alicdn.com/acd_work/tongyi/assets/logo.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://epicmars.github.io/blog/android/framework/2018-03-11-android-view-event-dispatching/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script defer crossorigin=anonymous src=/js/custom.f20a5212619392e989b6d24ad9ce42302014debfad4d3c8c01db030c36d03475.js integrity="sha256-8gpSEmGTkumJttJK2c5CMCAU3r+tTTyMAdsDDDbQNHU="></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.3/dist/katex.min.css integrity=sha384-Juol1FqnotbkyZUT5Z7gUPjQ9gzlwCENvUZTpQBAPxtusdwFLRy382PSDx5UUJ4/ crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.3/dist/katex.min.js integrity=sha384-97gW6UIJxnlKemYavrqDHSX3SiygeOwIZhwyOKRfSaf0JWKRVj9hLASHgFTzT+0O crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.3/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-NMEMBZ8R90"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-NMEMBZ8R90")}</script><meta property="og:title" content="Android View事件处理机制与分发流程"><meta property="og:description" content="View类还包含一系列嵌套接口以及您可以更加轻松定义的回调。 这些接口称为事件侦听器，是您捕获用户与UI之间交互的票证。
尽管您通常会使用事件侦听器来侦听用户交互，但有时您确实需要扩展View类以构建自定义组件。也许，您想扩展 Button类来丰富某些内容的样式。 在这种情况下，您将能够使用该类的事件处理程序为类定义默认事件行为。
API 事件侦听器（Event Listeners） 事件侦听器是View类中包含一个回调方法的接口。 当用户与UI项目之间的交互触发已注册此视图的侦听器时，Android框架将调用这些方法。
各事件侦听器接口包含的回调方法如下：
onClick()
在 View.OnClickListener 中。 当用户触摸项目（处于触摸模式下）时，或者使用导航键或轨迹球聚焦于项目，然后按适用的“Enter”键或按下轨迹球时，将调用此方法。
onLongClick()
在 View.OnLongClickListener 中。 当用户触摸并按住项目（处于触摸模式下）时，或者使用导航键或轨迹球聚焦于项目，然后按住适用的“Enter”键或按住轨迹球（持续一秒钟）时，将调用此方法。
onFocusChange()
在 View.OnFocusChangeListener 中。 当用户使用导航键或轨迹球导航到或远离项目时，将调用此方法。 onKey() 在 View.OnKeyListener 中。 当用户聚焦于项目并按下或释放设备上的硬按键时，将调用此方法。
onTouch()
在 View.OnTouchListener 中。 当用户执行可视为触摸事件的操作时，其中包括按下、释放或屏幕上的任何移动手势（在项目边界内），将调用此方法。
onCreateContextMenu()
在 View.OnCreateContextMenuListener 中。 当（因持续“长按”而）生成上下文菜单时，将调用此方法。请参见菜单开发者指南中有关上下文菜单的阐述。 这些方法是其相应接口的唯一成员。
请注意，上述示例中的 onClick() 回调没有返回值，但是其他某些事件侦听器方法必须返回布尔值。具体原因取决于事件。 对于这几个事件侦听器，必须返回布尔值的原因如下：
onLongClick()：此方法返回一个布尔值，表示您是否已处理完事件，以及是否应该将它继续传下去。 也就是说，返回 true 表示您已经处理事件且事件应就此停止；如果您尚未处理事件和/或事件应该继续传递给其他任何点击侦听器，则返回 false。 onKey()：此方法返回一个布尔值，表示您是否已处理完事件，以及是否应该将它继续传下去。 也就是说，返回 true 表示您已经处理事件且事件应就此停止；如果您尚未处理事件和/或事件应该继续传递给其他任何按键侦听器，则返回 false。 onTouch()： 此方法返回一个布尔值，表示侦听器是否处理完此事件。重要的是，此事件可以拥有多个分先后顺序的操作。 因此，如果在收到关闭操作事件时返回 false，则表示您并未处理完此事件，而且对其后续操作也不感兴趣。 因此，您无需执行事件内的任何其他操作，如手势或最终操作事件。 事件处理程序(Event Handlers) 如果您从视图构建自定义组件，则将能够定义几种用作默认事件处理程序的回调方法。在有关自定义组件的文档中，您将了解某些用于事件处理的常见回调，其中包括：
onKeyDown(int, KeyEvent)：在发生新的按键事件时调用 onKeyUp(int, KeyEvent)：在发生按键弹起事件时调用 onTrackballEvent(MotionEvent)：在发生轨迹球运动事件时调用 onTouchEvent(MotionEvent)：在发生触摸屏运动事件时调用 onFocusChanged(boolean, int, Rect)：在视图获得或失去焦点时调用 还有一些其他方法值得您注意，尽管它们并非 View 类的一部分，但可能会直接影响所能采取的事件处理方式。 因此，在管理布局内更复杂的事件时，请考虑使用以下其他方法："><meta property="og:type" content="article"><meta property="og:url" content="https://epicmars.github.io/blog/android/framework/2018-03-11-android-view-event-dispatching/"><meta property="og:image" content="https://epicmars.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="blog"><meta property="article:published_time" content="2018-03-11T16:00:39+08:00"><meta property="article:modified_time" content="2018-03-11T16:00:39+08:00"><meta property="og:site_name" content="androidpi"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://epicmars.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Android View事件处理机制与分发流程"><meta name=twitter:description content="View类还包含一系列嵌套接口以及您可以更加轻松定义的回调。 这些接口称为事件侦听器，是您捕获用户与UI之间交互的票证。
尽管您通常会使用事件侦听器来侦听用户交互，但有时您确实需要扩展View类以构建自定义组件。也许，您想扩展 Button类来丰富某些内容的样式。 在这种情况下，您将能够使用该类的事件处理程序为类定义默认事件行为。
API 事件侦听器（Event Listeners） 事件侦听器是View类中包含一个回调方法的接口。 当用户与UI项目之间的交互触发已注册此视图的侦听器时，Android框架将调用这些方法。
各事件侦听器接口包含的回调方法如下：
onClick()
在 View.OnClickListener 中。 当用户触摸项目（处于触摸模式下）时，或者使用导航键或轨迹球聚焦于项目，然后按适用的“Enter”键或按下轨迹球时，将调用此方法。
onLongClick()
在 View.OnLongClickListener 中。 当用户触摸并按住项目（处于触摸模式下）时，或者使用导航键或轨迹球聚焦于项目，然后按住适用的“Enter”键或按住轨迹球（持续一秒钟）时，将调用此方法。
onFocusChange()
在 View.OnFocusChangeListener 中。 当用户使用导航键或轨迹球导航到或远离项目时，将调用此方法。 onKey() 在 View.OnKeyListener 中。 当用户聚焦于项目并按下或释放设备上的硬按键时，将调用此方法。
onTouch()
在 View.OnTouchListener 中。 当用户执行可视为触摸事件的操作时，其中包括按下、释放或屏幕上的任何移动手势（在项目边界内），将调用此方法。
onCreateContextMenu()
在 View.OnCreateContextMenuListener 中。 当（因持续“长按”而）生成上下文菜单时，将调用此方法。请参见菜单开发者指南中有关上下文菜单的阐述。 这些方法是其相应接口的唯一成员。
请注意，上述示例中的 onClick() 回调没有返回值，但是其他某些事件侦听器方法必须返回布尔值。具体原因取决于事件。 对于这几个事件侦听器，必须返回布尔值的原因如下：
onLongClick()：此方法返回一个布尔值，表示您是否已处理完事件，以及是否应该将它继续传下去。 也就是说，返回 true 表示您已经处理事件且事件应就此停止；如果您尚未处理事件和/或事件应该继续传递给其他任何点击侦听器，则返回 false。 onKey()：此方法返回一个布尔值，表示您是否已处理完事件，以及是否应该将它继续传下去。 也就是说，返回 true 表示您已经处理事件且事件应就此停止；如果您尚未处理事件和/或事件应该继续传递给其他任何按键侦听器，则返回 false。 onTouch()： 此方法返回一个布尔值，表示侦听器是否处理完此事件。重要的是，此事件可以拥有多个分先后顺序的操作。 因此，如果在收到关闭操作事件时返回 false，则表示您并未处理完此事件，而且对其后续操作也不感兴趣。 因此，您无需执行事件内的任何其他操作，如手势或最终操作事件。 事件处理程序(Event Handlers) 如果您从视图构建自定义组件，则将能够定义几种用作默认事件处理程序的回调方法。在有关自定义组件的文档中，您将了解某些用于事件处理的常见回调，其中包括：
onKeyDown(int, KeyEvent)：在发生新的按键事件时调用 onKeyUp(int, KeyEvent)：在发生按键弹起事件时调用 onTrackballEvent(MotionEvent)：在发生轨迹球运动事件时调用 onTouchEvent(MotionEvent)：在发生触摸屏运动事件时调用 onFocusChanged(boolean, int, Rect)：在视图获得或失去焦点时调用 还有一些其他方法值得您注意，尽管它们并非 View 类的一部分，但可能会直接影响所能采取的事件处理方式。 因此，在管理布局内更复杂的事件时，请考虑使用以下其他方法："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blogs","item":"https://epicmars.github.io/blog/"},{"@type":"ListItem","position":2,"name":"Android","item":"https://epicmars.github.io/blog/android/"},{"@type":"ListItem","position":3,"name":"Android View事件处理机制与分发流程","item":"https://epicmars.github.io/blog/android/framework/2018-03-11-android-view-event-dispatching/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Android View事件处理机制与分发流程","name":"Android View事件处理机制与分发流程","description":"View类还包含一系列嵌套接口以及您可以更加轻松定义的回调。 这些接口称为事件侦听器，是您捕获用户与UI之间交互的票证。\n尽管您通常会使用事件侦听器来侦听用户交互，但有时您确实需要扩展View类以构建自定义组件。也许，您想扩展 Button类来丰富某些内容的样式。 在这种情况下，您将能够使用该类的事件处理程序为类定义默认事件行为。\nAPI 事件侦听器（Event Listeners） 事件侦听器是View类中包含一个回调方法的接口。 当用户与UI项目之间的交互触发已注册此视图的侦听器时，Android框架将调用这些方法。\n各事件侦听器接口包含的回调方法如下：\nonClick()\n在 View.OnClickListener 中。 当用户触摸项目（处于触摸模式下）时，或者使用导航键或轨迹球聚焦于项目，然后按适用的“Enter”键或按下轨迹球时，将调用此方法。\nonLongClick()\n在 View.OnLongClickListener 中。 当用户触摸并按住项目（处于触摸模式下）时，或者使用导航键或轨迹球聚焦于项目，然后按住适用的“Enter”键或按住轨迹球（持续一秒钟）时，将调用此方法。\nonFocusChange()\n在 View.OnFocusChangeListener 中。 当用户使用导航键或轨迹球导航到或远离项目时，将调用此方法。 onKey() 在 View.OnKeyListener 中。 当用户聚焦于项目并按下或释放设备上的硬按键时，将调用此方法。\nonTouch()\n在 View.OnTouchListener 中。 当用户执行可视为触摸事件的操作时，其中包括按下、释放或屏幕上的任何移动手势（在项目边界内），将调用此方法。\nonCreateContextMenu()\n在 View.OnCreateContextMenuListener 中。 当（因持续“长按”而）生成上下文菜单时，将调用此方法。请参见菜单开发者指南中有关上下文菜单的阐述。 这些方法是其相应接口的唯一成员。\n请注意，上述示例中的 onClick() 回调没有返回值，但是其他某些事件侦听器方法必须返回布尔值。具体原因取决于事件。 对于这几个事件侦听器，必须返回布尔值的原因如下：\nonLongClick()：此方法返回一个布尔值，表示您是否已处理完事件，以及是否应该将它继续传下去。 也就是说，返回 true 表示您已经处理事件且事件应就此停止；如果您尚未处理事件和/或事件应该继续传递给其他任何点击侦听器，则返回 false。 onKey()：此方法返回一个布尔值，表示您是否已处理完事件，以及是否应该将它继续传下去。 也就是说，返回 true 表示您已经处理事件且事件应就此停止；如果您尚未处理事件和/或事件应该继续传递给其他任何按键侦听器，则返回 false。 onTouch()： 此方法返回一个布尔值，表示侦听器是否处理完此事件。重要的是，此事件可以拥有多个分先后顺序的操作。 因此，如果在收到关闭操作事件时返回 false，则表示您并未处理完此事件，而且对其后续操作也不感兴趣。 因此，您无需执行事件内的任何其他操作，如手势或最终操作事件。 事件处理程序(Event Handlers) 如果您从视图构建自定义组件，则将能够定义几种用作默认事件处理程序的回调方法。在有关自定义组件的文档中，您将了解某些用于事件处理的常见回调，其中包括：\nonKeyDown(int, KeyEvent)：在发生新的按键事件时调用 onKeyUp(int, KeyEvent)：在发生按键弹起事件时调用 onTrackballEvent(MotionEvent)：在发生轨迹球运动事件时调用 onTouchEvent(MotionEvent)：在发生触摸屏运动事件时调用 onFocusChanged(boolean, int, Rect)：在视图获得或失去焦点时调用 还有一些其他方法值得您注意，尽管它们并非 View 类的一部分，但可能会直接影响所能采取的事件处理方式。 因此，在管理布局内更复杂的事件时，请考虑使用以下其他方法：","keywords":[],"articleBody":"View类还包含一系列嵌套接口以及您可以更加轻松定义的回调。 这些接口称为事件侦听器，是您捕获用户与UI之间交互的票证。\n尽管您通常会使用事件侦听器来侦听用户交互，但有时您确实需要扩展View类以构建自定义组件。也许，您想扩展 Button类来丰富某些内容的样式。 在这种情况下，您将能够使用该类的事件处理程序为类定义默认事件行为。\nAPI 事件侦听器（Event Listeners） 事件侦听器是View类中包含一个回调方法的接口。 当用户与UI项目之间的交互触发已注册此视图的侦听器时，Android框架将调用这些方法。\n各事件侦听器接口包含的回调方法如下：\nonClick()\n在 View.OnClickListener 中。 当用户触摸项目（处于触摸模式下）时，或者使用导航键或轨迹球聚焦于项目，然后按适用的“Enter”键或按下轨迹球时，将调用此方法。\nonLongClick()\n在 View.OnLongClickListener 中。 当用户触摸并按住项目（处于触摸模式下）时，或者使用导航键或轨迹球聚焦于项目，然后按住适用的“Enter”键或按住轨迹球（持续一秒钟）时，将调用此方法。\nonFocusChange()\n在 View.OnFocusChangeListener 中。 当用户使用导航键或轨迹球导航到或远离项目时，将调用此方法。 onKey() 在 View.OnKeyListener 中。 当用户聚焦于项目并按下或释放设备上的硬按键时，将调用此方法。\nonTouch()\n在 View.OnTouchListener 中。 当用户执行可视为触摸事件的操作时，其中包括按下、释放或屏幕上的任何移动手势（在项目边界内），将调用此方法。\nonCreateContextMenu()\n在 View.OnCreateContextMenuListener 中。 当（因持续“长按”而）生成上下文菜单时，将调用此方法。请参见菜单开发者指南中有关上下文菜单的阐述。 这些方法是其相应接口的唯一成员。\n请注意，上述示例中的 onClick() 回调没有返回值，但是其他某些事件侦听器方法必须返回布尔值。具体原因取决于事件。 对于这几个事件侦听器，必须返回布尔值的原因如下：\nonLongClick()：此方法返回一个布尔值，表示您是否已处理完事件，以及是否应该将它继续传下去。 也就是说，返回 true 表示您已经处理事件且事件应就此停止；如果您尚未处理事件和/或事件应该继续传递给其他任何点击侦听器，则返回 false。 onKey()：此方法返回一个布尔值，表示您是否已处理完事件，以及是否应该将它继续传下去。 也就是说，返回 true 表示您已经处理事件且事件应就此停止；如果您尚未处理事件和/或事件应该继续传递给其他任何按键侦听器，则返回 false。 onTouch()： 此方法返回一个布尔值，表示侦听器是否处理完此事件。重要的是，此事件可以拥有多个分先后顺序的操作。 因此，如果在收到关闭操作事件时返回 false，则表示您并未处理完此事件，而且对其后续操作也不感兴趣。 因此，您无需执行事件内的任何其他操作，如手势或最终操作事件。 事件处理程序(Event Handlers) 如果您从视图构建自定义组件，则将能够定义几种用作默认事件处理程序的回调方法。在有关自定义组件的文档中，您将了解某些用于事件处理的常见回调，其中包括：\nonKeyDown(int, KeyEvent)：在发生新的按键事件时调用 onKeyUp(int, KeyEvent)：在发生按键弹起事件时调用 onTrackballEvent(MotionEvent)：在发生轨迹球运动事件时调用 onTouchEvent(MotionEvent)：在发生触摸屏运动事件时调用 onFocusChanged(boolean, int, Rect)：在视图获得或失去焦点时调用 还有一些其他方法值得您注意，尽管它们并非 View 类的一部分，但可能会直接影响所能采取的事件处理方式。 因此，在管理布局内更复杂的事件时，请考虑使用以下其他方法：\nActivity.dispatchTouchEvent(MotionEvent)：此方法允许 Activity 在分派给窗口之前截获所有触摸事件。 ViewGroup.onInterceptTouchEvent(MotionEvent)：此方法允许 ViewGroup 监视分派给子视图的事件。 ViewParent.requestDisallowInterceptTouchEvent(boolean)： 对父视图调用此方法表明不应使用 onInterceptTouchEvent(MotionEvent) 截获触摸事件。 事件分发流程 将一个动作(鼠标、手写笔、触摸、轨迹球)事件MotionEvent进行分发过程，目的是将产生的动作事件分发给特定的对象进行消费。分发的层级由上至下从Activity到Window再到View。\n这里的事件分发指各个组件的dispatchTouchEvent(MotionEvent ev)方法:\n首先事件从Activity开始分发，首先它让Window进行事件分发，如果事件未被消费，则直接由Activity的onTouchEvent()消费。\nWindow事件分发，Window的实现类为PhoneWindow，PhoneWindow将事件直接传递给顶级DecorView进行分发。\nView事件分发\nViewGroup事件分发\n不拦截事件，事件将沿着View层次嵌套结构继续向下分发，直到事件被消费。如果向下分发过程中事件未被消费，则事件将沿着原来的传递路径向上传递，直到事件被消费。 事件被拦截，将由拦截事件的ViewGroup来消费事件，如果未消费将事件向上传递，直到被消费。 这里需要注意的是，对于每次接收到ACTION_DOWN事件，mFirstTouchTarget会置为空，FLAG_DISALLOW_INTERCEPT标志位被重置，ViewGroup总是调用onInterceptTouchEvent()来判断是否进行拦截。因此如果ACTION_DOWN被拦截，那么后续其它事件都由它自身来处理。如果ACTION_DOWN未被拦截，那么mFirstTouchTarget不为空，对于后续其它事件，子View通过调用ViewParent的requestDisallowInterceptTouchEvent()方法来控制对onInterceptTouchEvent(）的调用。如果后续某个事件被拦截，子View会接收到ACTION_CANCEL事件，该事件后续事件将由拦截该事件的ViewGroup来消费。如果未拦截，则按照正常分发流程处理。\n常规View事件分发与消费\n如果OnTouchListener不为空并且enabled为true，事件由OnTouchListener消费，否则由onTouchEvent消费。如果OnTouchListener的onTouch方法返回false，事件将也由onTouchEvent消费。\n源码分析 ViewGroup.java\n@Override public boolean dispatchTouchEvent(MotionEvent ev) { if (mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onTouchEvent(ev, 1); } // If the event targets the accessibility focused view and this is it, start // normal event dispatch. Maybe a descendant is what will handle the click. if (ev.isTargetAccessibilityFocus() \u0026\u0026 isAccessibilityFocusedViewOrHost()) { ev.setTargetAccessibilityFocus(false); } boolean handled = false; if (onFilterTouchEventForSecurity(ev)) { final int action = ev.getAction(); final int actionMasked = action \u0026 MotionEvent.ACTION_MASK; // Handle an initial down. if (actionMasked == MotionEvent.ACTION_DOWN) { // Throw away all previous state when starting a new touch gesture. // The framework may have dropped the up or cancel event for the previous gesture // due to an app switch, ANR, or some other state change. cancelAndClearTouchTargets(ev); resetTouchState(); } // Check for interception. final boolean intercepted; if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) { final boolean disallowIntercept = (mGroupFlags \u0026 FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) { intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed } else { intercepted = false; } } else { // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true; } // If intercepted, start normal event dispatch. Also if there is already // a view that is handling the gesture, do normal event dispatch. if (intercepted || mFirstTouchTarget != null) { ev.setTargetAccessibilityFocus(false); } // Check for cancelation. final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL; // Update list of touch targets for pointer down, if needed. final boolean split = (mGroupFlags \u0026 FLAG_SPLIT_MOTION_EVENTS) != 0; TouchTarget newTouchTarget = null; boolean alreadyDispatchedToNewTouchTarget = false; if (!canceled \u0026\u0026 !intercepted) { // If the event is targeting accessiiblity focus we give it to the // view that has accessibility focus and if it does not handle it // we clear the flag and dispatch the event to all children as usual. // We are looking up the accessibility focused host to avoid keeping // state since these events are very rare. View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus() : null; if (actionMasked == MotionEvent.ACTION_DOWN || (split \u0026\u0026 actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) { final int actionIndex = ev.getActionIndex(); // always 0 for down final int idBitsToAssign = split ? 1 \u003c\u003c ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS; // Clean up earlier touch targets for this pointer id in case they // have become out of sync. removePointersFromTouchTargets(idBitsToAssign); final int childrenCount = mChildrenCount; if (newTouchTarget == null \u0026\u0026 childrenCount != 0) { final float x = ev.getX(actionIndex); final float y = ev.getY(actionIndex); // Find a child that can receive the event. // Scan children from front to back. final ArrayList\u003cView\u003e preorderedList = buildTouchDispatchChildList(); final boolean customOrder = preorderedList == null \u0026\u0026 isChildrenDrawingOrderEnabled(); final View[] children = mChildren; for (int i = childrenCount - 1; i \u003e= 0; i--) { final int childIndex = getAndVerifyPreorderedIndex( childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView( preorderedList, children, childIndex); // If there is a view that has accessibility focus we want it // to get the event first and if not handled we will perform a // normal dispatch. We may do a double iteration but this is // safer given the timeframe. if (childWithAccessibilityFocus != null) { if (childWithAccessibilityFocus != child) { continue; } childWithAccessibilityFocus = null; i = childrenCount - 1; } if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) { ev.setTargetAccessibilityFocus(false); continue; } newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) { // Child is already receiving touch within its bounds. // Give it the new pointer in addition to the ones it is handling. newTouchTarget.pointerIdBits |= idBitsToAssign; break; } resetCancelNextUpFlag(child); if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) { // Child wants to receive touch within its bounds. mLastTouchDownTime = ev.getDownTime(); if (preorderedList != null) { // childIndex points into presorted list, find original index for (int j = 0; j \u003c childrenCount; j++) { if (children[childIndex] == mChildren[j]) { mLastTouchDownIndex = j; break; } } } else { mLastTouchDownIndex = childIndex; } mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; } // The accessibility focus didn't handle the event, so clear // the flag and do a normal dispatch to all children. ev.setTargetAccessibilityFocus(false); } if (preorderedList != null) preorderedList.clear(); } if (newTouchTarget == null \u0026\u0026 mFirstTouchTarget != null) { // Did not find a child to receive the event. // Assign the pointer to the least recently added target. newTouchTarget = mFirstTouchTarget; while (newTouchTarget.next != null) { newTouchTarget = newTouchTarget.next; } newTouchTarget.pointerIdBits |= idBitsToAssign; } } } // Dispatch to touch targets. if (mFirstTouchTarget == null) { // No touch targets so treat this as an ordinary view. handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); } else { // Dispatch to touch targets, excluding the new touch target if we already // dispatched to it. Cancel touch targets if necessary. TouchTarget predecessor = null; TouchTarget target = mFirstTouchTarget; while (target != null) { final TouchTarget next = target.next; if (alreadyDispatchedToNewTouchTarget \u0026\u0026 target == newTouchTarget) { handled = true; } else { final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted; if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) { handled = true; } if (cancelChild) { if (predecessor == null) { mFirstTouchTarget = next; } else { predecessor.next = next; } target.recycle(); target = next; continue; } } predecessor = target; target = next; } } // Update list of touch targets for pointer up or cancel, if needed. if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) { resetTouchState(); } else if (split \u0026\u0026 actionMasked == MotionEvent.ACTION_POINTER_UP) { final int actionIndex = ev.getActionIndex(); final int idBitsToRemove = 1 \u003c\u003c ev.getPointerId(actionIndex); removePointersFromTouchTargets(idBitsToRemove); } } if (!handled \u0026\u0026 mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1); } return handled; } ","wordCount":"1047","inLanguage":"en","datePublished":"2018-03-11T16:00:39+08:00","dateModified":"2018-03-11T16:00:39+08:00","author":{"@type":"Person","name":"LEOY"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://epicmars.github.io/blog/android/framework/2018-03-11-android-view-event-dispatching/"},"publisher":{"@type":"Organization","name":"AndroidPi","logo":{"@type":"ImageObject","url":"https://acd-assets.alicdn.com/acd_work/tongyi/assets/logo.svg"}}}</script></head><body id=top><script>const hasHeaderBg=!1</script><header class=header><div class=nav-container><nav class=nav><div class=logo><a href=/ accesskey=h title="AndroidPi (Alt + H)"><svg width="25" height="24" viewBox="0 0 25 24" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><linearGradient x1="76.7202373%" y1="41.6070847%" x2="18.306123%" y2="65.5065085%" id="linearGradient-9_1k7ha4jv-1"><stop stop-color="#797beb" offset="0"/><stop stop-color="#373080" offset="100%"/></linearGradient></defs><g id="Symbols" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="_编组-7" fill="url(#linearGradient-9_1k7ha4jv-1)"><path d="M12.2746711.0C12.5125388.0 12.7434104.12583746 12.8693403.33556656l1.3852293 2.3769298h6.1425827C20.63502 2.71249636 20.8658915 2.83833382 20.9918215 3.04806292l1.7420308 2.97815322C22.8597822 6.23594524 22.8597822 6.5016021 22.7338523 6.7113312L22.6988718 6.76725896C22.6708873 6.80920478 22.6359068 6.8511506 22.5939301 6.88610545L21.2156969 9.24905331l3.050303 5.24322749L24.3429571 14.6041363C24.4339065 14.8138654 24.4548948 15.0795223 24.3919298 15.2682785l-1.6021086 2.7404602C22.6638912 18.2184678 22.4400158 18.3443053 22.195152 18.3443053L19.4176972 18.3582872 16.353402 23.6504515C16.227472 23.8601806 16.0035966 23.9860181 15.7587328 23.9860181L12.2886633 24H12.2396906C12.0158151 23.9860181 11.7989358 23.8601806 11.6869981 23.6644334l-1.490171-2.551704H4.13120166C4.0822289 21.1267113 4.04025225 21.1267113 3.9912795 21.1267113 3.75341183 21.1267113 3.52254028 21.0008739 3.39661034 20.7911448L1.79450165 18.0506845C1.66857171 17.8479464 1.66857171 17.5892805 1.79450165 17.3725604l1.37823324-2.3909117L.0944474553 9.69647539c-.1259299404-.20273813-.1259299404-.46140402.0-.678124089999999L1.80849387 6.02621614c.11193772-.2097291.34280928-.33556656.59466916-.33556656C2.466128 5.67666764 2.51510075 5.69064958 2.56407351 5.70463152H5.40449327L8.44080406.46140402C8.45479628.4194582 8.46179238.38450335 8.48278071.35653947L8.49677292.33556656C8.62270286.12583746 8.84657831.0 9.09144209.0H12.2816672 12.2746711zM9.04246933.72706088 5.74730256 6.41071949H2.3751786L8.93752771 17.6871541H5.59338819l-1.61610091 2.789397H10.5606247l1.6790659 2.8942616 6.5623491-11.3043985 1.6790659 2.8802797L23.7203035 14.9327119 20.4181406 9.24905331l1.6650737-2.8662977L9.00049268 6.39673755 10.6795586 3.51645791 9.04946544.72706088H9.04246933zM16.1435187 9.82930382 12.2187023 16.5755899 8.2938858 9.82930382h7.8496329z" id="_形状"/></g></g></svg></a><div class=logo-switches></div></div><ul id=menu><li><a href=/resources title=Resources><span>Resources</span></a></li><li><a href=/blog/ title=Blog><span>Blog</span></a></li><li><a href=/publication title=Publication><span>Publication</span></a></li><li><a href=/about title=About><span>About</span></a></li></ul></nav></div></header><div class=hero-container><div class=hero><h1 class=post-title>Android View事件处理机制与分发流程</h1><div class=post-meta><span title='2018-03-11 16:00:39 +0800 CST'>March 11, 2018</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;1047 words&nbsp;·&nbsp;LEOY</div></div></div><main class=main><article class=post-single><div class=post-content><p>View类还包含一系列嵌套接口以及您可以更加轻松定义的回调。 这些接口称为事件侦听器，是您捕获用户与UI之间交互的票证。</p><p>尽管您通常会使用事件侦听器来侦听用户交互，但有时您确实需要扩展View类以构建自定义组件。也许，您想扩展 Button类来丰富某些内容的样式。 在这种情况下，您将能够使用该类的事件处理程序为类定义默认事件行为。</p><h2 id=api>API<a hidden class=anchor aria-hidden=true href=#api>#</a></h2><h3 id=事件侦听器event-listeners>事件侦听器（Event Listeners）<a hidden class=anchor aria-hidden=true href=#事件侦听器event-listeners>#</a></h3><p>事件侦听器是View类中包含一个回调方法的接口。 当用户与UI项目之间的交互触发已注册此视图的侦听器时，Android框架将调用这些方法。</p><p>各事件侦听器接口包含的回调方法如下：</p><ul><li><p>onClick()</p><p>在 View.OnClickListener 中。 当用户触摸项目（处于触摸模式下）时，或者使用导航键或轨迹球聚焦于项目，然后按适用的“Enter”键或按下轨迹球时，将调用此方法。</p></li><li><p>onLongClick()</p><p>在 View.OnLongClickListener 中。 当用户触摸并按住项目（处于触摸模式下）时，或者使用导航键或轨迹球聚焦于项目，然后按住适用的“Enter”键或按住轨迹球（持续一秒钟）时，将调用此方法。</p></li><li><p>onFocusChange()</p><p>在 View.OnFocusChangeListener 中。 当用户使用导航键或轨迹球导航到或远离项目时，将调用此方法。
onKey()
在 View.OnKeyListener 中。 当用户聚焦于项目并按下或释放设备上的硬按键时，将调用此方法。</p></li><li><p>onTouch()</p><p>在 View.OnTouchListener 中。 当用户执行可视为触摸事件的操作时，其中包括按下、释放或屏幕上的任何移动手势（在项目边界内），将调用此方法。</p></li><li><p>onCreateContextMenu()</p><p>在 View.OnCreateContextMenuListener 中。 当（因持续“长按”而）生成上下文菜单时，将调用此方法。请参见菜单开发者指南中有关上下文菜单的阐述。
这些方法是其相应接口的唯一成员。</p></li></ul><p>请注意，上述示例中的 onClick() 回调没有返回值，但是其他某些事件侦听器方法必须返回布尔值。具体原因取决于事件。 对于这几个事件侦听器，必须返回布尔值的原因如下：</p><ul><li>onLongClick()：此方法返回一个布尔值，表示您是否已处理完事件，以及是否应该将它继续传下去。 也就是说，返回 true 表示您已经处理事件且事件应就此停止；如果您尚未处理事件和/或事件应该继续传递给其他任何点击侦听器，则返回 false。</li><li>onKey()：此方法返回一个布尔值，表示您是否已处理完事件，以及是否应该将它继续传下去。 也就是说，返回 true 表示您已经处理事件且事件应就此停止；如果您尚未处理事件和/或事件应该继续传递给其他任何按键侦听器，则返回 false。</li><li>onTouch()： 此方法返回一个布尔值，表示侦听器是否处理完此事件。重要的是，此事件可以拥有多个分先后顺序的操作。 因此，如果在收到关闭操作事件时返回 false，则表示您并未处理完此事件，而且对其后续操作也不感兴趣。 因此，您无需执行事件内的任何其他操作，如手势或最终操作事件。</li></ul><h3 id=事件处理程序event-handlers>事件处理程序(Event Handlers)<a hidden class=anchor aria-hidden=true href=#事件处理程序event-handlers>#</a></h3><p>如果您从视图构建自定义组件，则将能够定义几种用作默认事件处理程序的回调方法。在有关自定义组件的文档中，您将了解某些用于事件处理的常见回调，其中包括：</p><ul><li>onKeyDown(int, KeyEvent)：在发生新的按键事件时调用</li><li>onKeyUp(int, KeyEvent)：在发生按键弹起事件时调用</li><li>onTrackballEvent(MotionEvent)：在发生轨迹球运动事件时调用</li><li>onTouchEvent(MotionEvent)：在发生触摸屏运动事件时调用</li><li>onFocusChanged(boolean, int, Rect)：在视图获得或失去焦点时调用</li></ul><p>还有一些其他方法值得您注意，尽管它们并非 View 类的一部分，但可能会直接影响所能采取的事件处理方式。 因此，在管理布局内更复杂的事件时，请考虑使用以下其他方法：</p><ul><li>Activity.dispatchTouchEvent(MotionEvent)：此方法允许 Activity 在分派给窗口之前截获所有触摸事件。</li><li>ViewGroup.onInterceptTouchEvent(MotionEvent)：此方法允许 ViewGroup 监视分派给子视图的事件。</li><li>ViewParent.requestDisallowInterceptTouchEvent(boolean)： 对父视图调用此方法表明不应使用 onInterceptTouchEvent(MotionEvent) 截获触摸事件。</li></ul><h2 id=事件分发流程>事件分发流程<a hidden class=anchor aria-hidden=true href=#事件分发流程>#</a></h2><p>将一个动作(鼠标、手写笔、触摸、轨迹球)事件MotionEvent进行分发过程，目的是将产生的动作事件分发给特定的对象进行消费。分发的层级由上至下从Activity到Window再到View。</p><p>这里的事件分发指各个组件的<code>dispatchTouchEvent(MotionEvent ev)</code>方法:</p><ul><li><p>首先事件从Activity开始分发，首先它让Window进行事件分发，如果事件未被消费，则直接由Activity的onTouchEvent()消费。</p></li><li><p>Window事件分发，Window的实现类为PhoneWindow，PhoneWindow将事件直接传递给顶级DecorView进行分发。</p></li><li><p>View事件分发</p><ul><li><p>ViewGroup事件分发</p><ul><li>不拦截事件，事件将沿着View层次嵌套结构继续向下分发，直到事件被消费。如果向下分发过程中事件未被消费，则事件将沿着原来的传递路径向上传递，直到事件被消费。</li><li>事件被拦截，将由拦截事件的ViewGroup来消费事件，如果未消费将事件向上传递，直到被消费。</li></ul><p>这里需要注意的是，对于每次接收到ACTION_DOWN事件，mFirstTouchTarget会置为空，FLAG_DISALLOW_INTERCEPT标志位被重置，ViewGroup总是调用onInterceptTouchEvent()来判断是否进行拦截。因此如果ACTION_DOWN被拦截，那么后续其它事件都由它自身来处理。如果ACTION_DOWN未被拦截，那么mFirstTouchTarget不为空，对于后续其它事件，子View通过调用ViewParent的requestDisallowInterceptTouchEvent()方法来控制对onInterceptTouchEvent(）的调用。如果后续某个事件被拦截，子View会接收到ACTION_CANCEL事件，该事件后续事件将由拦截该事件的ViewGroup来消费。如果未拦截，则按照正常分发流程处理。</p></li><li><p>常规View事件分发与消费</p><p>如果OnTouchListener不为空并且enabled为true，事件由OnTouchListener消费，否则由onTouchEvent消费。如果OnTouchListener的onTouch方法返回false，事件将也由onTouchEvent消费。</p></li></ul></li></ul><h2 id=源码分析>源码分析<a hidden class=anchor aria-hidden=true href=#源码分析>#</a></h2><p>ViewGroup.java</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=w>    </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>boolean</span><span class=w> </span><span class=nf>dispatchTouchEvent</span><span class=p>(</span><span class=n>MotionEvent</span><span class=w> </span><span class=n>ev</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>mInputEventConsistencyVerifier</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>mInputEventConsistencyVerifier</span><span class=p>.</span><span class=na>onTouchEvent</span><span class=p>(</span><span class=n>ev</span><span class=p>,</span><span class=w> </span><span class=n>1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// If the event targets the accessibility focused view and this is it, start</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// normal event dispatch. Maybe a descendant is what will handle the click.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>ev</span><span class=p>.</span><span class=na>isTargetAccessibilityFocus</span><span class=p>()</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=n>isAccessibilityFocusedViewOrHost</span><span class=p>())</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>ev</span><span class=p>.</span><span class=na>setTargetAccessibilityFocus</span><span class=p>(</span><span class=kc>false</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>boolean</span><span class=w> </span><span class=n>handled</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>false</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>onFilterTouchEventForSecurity</span><span class=p>(</span><span class=n>ev</span><span class=p>))</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kd>final</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>action</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>ev</span><span class=p>.</span><span class=na>getAction</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kd>final</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>actionMasked</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>action</span><span class=w> </span><span class=o>&amp;</span><span class=w> </span><span class=n>MotionEvent</span><span class=p>.</span><span class=na>ACTION_MASK</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// Handle an initial down.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>actionMasked</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>MotionEvent</span><span class=p>.</span><span class=na>ACTION_DOWN</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=c1>// Throw away all previous state when starting a new touch gesture.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=c1>// The framework may have dropped the up or cancel event for the previous gesture</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=c1>// due to an app switch, ANR, or some other state change.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>cancelAndClearTouchTargets</span><span class=p>(</span><span class=n>ev</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>resetTouchState</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// Check for interception.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kd>final</span><span class=w> </span><span class=kt>boolean</span><span class=w> </span><span class=n>intercepted</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>actionMasked</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>MotionEvent</span><span class=p>.</span><span class=na>ACTION_DOWN</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=o>||</span><span class=w> </span><span class=n>mFirstTouchTarget</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=kd>final</span><span class=w> </span><span class=kt>boolean</span><span class=w> </span><span class=n>disallowIntercept</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=n>mGroupFlags</span><span class=w> </span><span class=o>&amp;</span><span class=w> </span><span class=n>FLAG_DISALLOW_INTERCEPT</span><span class=p>)</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>disallowIntercept</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>intercepted</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>onInterceptTouchEvent</span><span class=p>(</span><span class=n>ev</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>ev</span><span class=p>.</span><span class=na>setAction</span><span class=p>(</span><span class=n>action</span><span class=p>);</span><span class=w> </span><span class=c1>// restore action in case it was changed</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>intercepted</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>false</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=c1>// There are no touch targets and this action is not an initial down</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=c1>// so this view group continues to intercept touches.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>intercepted</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// If intercepted, start normal event dispatch. Also if there is already</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// a view that is handling the gesture, do normal event dispatch.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>intercepted</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=n>mFirstTouchTarget</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>ev</span><span class=p>.</span><span class=na>setTargetAccessibilityFocus</span><span class=p>(</span><span class=kc>false</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// Check for cancelation.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kd>final</span><span class=w> </span><span class=kt>boolean</span><span class=w> </span><span class=n>canceled</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>resetCancelNextUpFlag</span><span class=p>(</span><span class=k>this</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=o>||</span><span class=w> </span><span class=n>actionMasked</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>MotionEvent</span><span class=p>.</span><span class=na>ACTION_CANCEL</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// Update list of touch targets for pointer down, if needed.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kd>final</span><span class=w> </span><span class=kt>boolean</span><span class=w> </span><span class=n>split</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=n>mGroupFlags</span><span class=w> </span><span class=o>&amp;</span><span class=w> </span><span class=n>FLAG_SPLIT_MOTION_EVENTS</span><span class=p>)</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>TouchTarget</span><span class=w> </span><span class=n>newTouchTarget</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>null</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kt>boolean</span><span class=w> </span><span class=n>alreadyDispatchedToNewTouchTarget</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>false</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>canceled</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=o>!</span><span class=n>intercepted</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=c1>// If the event is targeting accessiiblity focus we give it to the</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=c1>// view that has accessibility focus and if it does not handle it</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=c1>// we clear the flag and dispatch the event to all children as usual.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=c1>// We are looking up the accessibility focused host to avoid keeping</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=c1>// state since these events are very rare.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>View</span><span class=w> </span><span class=n>childWithAccessibilityFocus</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>ev</span><span class=p>.</span><span class=na>isTargetAccessibilityFocus</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=o>?</span><span class=w> </span><span class=n>findChildWithAccessibilityFocus</span><span class=p>()</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=kc>null</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>actionMasked</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>MotionEvent</span><span class=p>.</span><span class=na>ACTION_DOWN</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=o>||</span><span class=w> </span><span class=p>(</span><span class=n>split</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=n>actionMasked</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>MotionEvent</span><span class=p>.</span><span class=na>ACTION_POINTER_DOWN</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=o>||</span><span class=w> </span><span class=n>actionMasked</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>MotionEvent</span><span class=p>.</span><span class=na>ACTION_HOVER_MOVE</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=kd>final</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>actionIndex</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>ev</span><span class=p>.</span><span class=na>getActionIndex</span><span class=p>();</span><span class=w> </span><span class=c1>// always 0 for down</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=kd>final</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>idBitsToAssign</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>split</span><span class=w> </span><span class=o>?</span><span class=w> </span><span class=n>1</span><span class=w> </span><span class=o>&lt;&lt;</span><span class=w> </span><span class=n>ev</span><span class=p>.</span><span class=na>getPointerId</span><span class=p>(</span><span class=n>actionIndex</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=p>:</span><span class=w> </span><span class=n>TouchTarget</span><span class=p>.</span><span class=na>ALL_POINTER_IDS</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=c1>// Clean up earlier touch targets for this pointer id in case they</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=c1>// have become out of sync.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>removePointersFromTouchTargets</span><span class=p>(</span><span class=n>idBitsToAssign</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=kd>final</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>childrenCount</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>mChildrenCount</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>newTouchTarget</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>null</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=n>childrenCount</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=n>0</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=kd>final</span><span class=w> </span><span class=kt>float</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>ev</span><span class=p>.</span><span class=na>getX</span><span class=p>(</span><span class=n>actionIndex</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=kd>final</span><span class=w> </span><span class=kt>float</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>ev</span><span class=p>.</span><span class=na>getY</span><span class=p>(</span><span class=n>actionIndex</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=c1>// Find a child that can receive the event.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=c1>// Scan children from front to back.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=kd>final</span><span class=w> </span><span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>View</span><span class=o>&gt;</span><span class=w> </span><span class=n>preorderedList</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>buildTouchDispatchChildList</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=kd>final</span><span class=w> </span><span class=kt>boolean</span><span class=w> </span><span class=n>customOrder</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>preorderedList</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>null</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=n>isChildrenDrawingOrderEnabled</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=kd>final</span><span class=w> </span><span class=n>View</span><span class=o>[]</span><span class=w> </span><span class=n>children</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>mChildren</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>childrenCount</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>1</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>&gt;=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=o>--</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=kd>final</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>childIndex</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>getAndVerifyPreorderedIndex</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                    </span><span class=n>childrenCount</span><span class=p>,</span><span class=w> </span><span class=n>i</span><span class=p>,</span><span class=w> </span><span class=n>customOrder</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=kd>final</span><span class=w> </span><span class=n>View</span><span class=w> </span><span class=n>child</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>getAndVerifyPreorderedView</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                    </span><span class=n>preorderedList</span><span class=p>,</span><span class=w> </span><span class=n>children</span><span class=p>,</span><span class=w> </span><span class=n>childIndex</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=c1>// If there is a view that has accessibility focus we want it</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=c1>// to get the event first and if not handled we will perform a</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=c1>// normal dispatch. We may do a double iteration but this is</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=c1>// safer given the timeframe.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>childWithAccessibilityFocus</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>childWithAccessibilityFocus</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=n>child</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                    </span><span class=k>continue</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                </span><span class=n>childWithAccessibilityFocus</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>null</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>childrenCount</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>canViewReceivePointerEvents</span><span class=p>(</span><span class=n>child</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                    </span><span class=o>||</span><span class=w> </span><span class=o>!</span><span class=n>isTransformedTouchPointInView</span><span class=p>(</span><span class=n>x</span><span class=p>,</span><span class=w> </span><span class=n>y</span><span class=p>,</span><span class=w> </span><span class=n>child</span><span class=p>,</span><span class=w> </span><span class=kc>null</span><span class=p>))</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                </span><span class=n>ev</span><span class=p>.</span><span class=na>setTargetAccessibilityFocus</span><span class=p>(</span><span class=kc>false</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                </span><span class=k>continue</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=n>newTouchTarget</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>getTouchTarget</span><span class=p>(</span><span class=n>child</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>newTouchTarget</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                </span><span class=c1>// Child is already receiving touch within its bounds.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                </span><span class=c1>// Give it the new pointer in addition to the ones it is handling.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                </span><span class=n>newTouchTarget</span><span class=p>.</span><span class=na>pointerIdBits</span><span class=w> </span><span class=o>|=</span><span class=w> </span><span class=n>idBitsToAssign</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                </span><span class=k>break</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=n>resetCancelNextUpFlag</span><span class=p>(</span><span class=n>child</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>dispatchTransformedTouchEvent</span><span class=p>(</span><span class=n>ev</span><span class=p>,</span><span class=w> </span><span class=kc>false</span><span class=p>,</span><span class=w> </span><span class=n>child</span><span class=p>,</span><span class=w> </span><span class=n>idBitsToAssign</span><span class=p>))</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                </span><span class=c1>// Child wants to receive touch within its bounds.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                </span><span class=n>mLastTouchDownTime</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>ev</span><span class=p>.</span><span class=na>getDownTime</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>preorderedList</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                    </span><span class=c1>// childIndex points into presorted list, find original index</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                    </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>j</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=n>j</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>childrenCount</span><span class=p>;</span><span class=w> </span><span class=n>j</span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>children</span><span class=o>[</span><span class=n>childIndex</span><span class=o>]</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>mChildren</span><span class=o>[</span><span class=n>j</span><span class=o>]</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                            </span><span class=n>mLastTouchDownIndex</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>j</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                            </span><span class=k>break</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                    </span><span class=n>mLastTouchDownIndex</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>childIndex</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                </span><span class=n>mLastTouchDownX</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>ev</span><span class=p>.</span><span class=na>getX</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                </span><span class=n>mLastTouchDownY</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>ev</span><span class=p>.</span><span class=na>getY</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                </span><span class=n>newTouchTarget</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>addTouchTarget</span><span class=p>(</span><span class=n>child</span><span class=p>,</span><span class=w> </span><span class=n>idBitsToAssign</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                </span><span class=n>alreadyDispatchedToNewTouchTarget</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                </span><span class=k>break</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=c1>// The accessibility focus didn&#39;t handle the event, so clear</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=c1>// the flag and do a normal dispatch to all children.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=n>ev</span><span class=p>.</span><span class=na>setTargetAccessibilityFocus</span><span class=p>(</span><span class=kc>false</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>preorderedList</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=n>preorderedList</span><span class=p>.</span><span class=na>clear</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>newTouchTarget</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>null</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=n>mFirstTouchTarget</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=c1>// Did not find a child to receive the event.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=c1>// Assign the pointer to the least recently added target.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=n>newTouchTarget</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>mFirstTouchTarget</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=n>newTouchTarget</span><span class=p>.</span><span class=na>next</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=n>newTouchTarget</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>newTouchTarget</span><span class=p>.</span><span class=na>next</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=n>newTouchTarget</span><span class=p>.</span><span class=na>pointerIdBits</span><span class=w> </span><span class=o>|=</span><span class=w> </span><span class=n>idBitsToAssign</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// Dispatch to touch targets.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>mFirstTouchTarget</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=c1>// No touch targets so treat this as an ordinary view.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>handled</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>dispatchTransformedTouchEvent</span><span class=p>(</span><span class=n>ev</span><span class=p>,</span><span class=w> </span><span class=n>canceled</span><span class=p>,</span><span class=w> </span><span class=kc>null</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=n>TouchTarget</span><span class=p>.</span><span class=na>ALL_POINTER_IDS</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=c1>// Dispatch to touch targets, excluding the new touch target if we already</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=c1>// dispatched to it.  Cancel touch targets if necessary.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>TouchTarget</span><span class=w> </span><span class=n>predecessor</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>null</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>TouchTarget</span><span class=w> </span><span class=n>target</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>mFirstTouchTarget</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=n>target</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=kd>final</span><span class=w> </span><span class=n>TouchTarget</span><span class=w> </span><span class=n>next</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>target</span><span class=p>.</span><span class=na>next</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>alreadyDispatchedToNewTouchTarget</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=n>target</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>newTouchTarget</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=n>handled</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=kd>final</span><span class=w> </span><span class=kt>boolean</span><span class=w> </span><span class=n>cancelChild</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>resetCancelNextUpFlag</span><span class=p>(</span><span class=n>target</span><span class=p>.</span><span class=na>child</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                </span><span class=o>||</span><span class=w> </span><span class=n>intercepted</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>dispatchTransformedTouchEvent</span><span class=p>(</span><span class=n>ev</span><span class=p>,</span><span class=w> </span><span class=n>cancelChild</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                </span><span class=n>target</span><span class=p>.</span><span class=na>child</span><span class=p>,</span><span class=w> </span><span class=n>target</span><span class=p>.</span><span class=na>pointerIdBits</span><span class=p>))</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=n>handled</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>cancelChild</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>predecessor</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                </span><span class=n>mFirstTouchTarget</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>next</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                </span><span class=n>predecessor</span><span class=p>.</span><span class=na>next</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>next</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=n>target</span><span class=p>.</span><span class=na>recycle</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=n>target</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>next</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=k>continue</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>predecessor</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>target</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>target</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>next</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// Update list of touch targets for pointer up or cancel, if needed.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>canceled</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=o>||</span><span class=w> </span><span class=n>actionMasked</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>MotionEvent</span><span class=p>.</span><span class=na>ACTION_UP</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=o>||</span><span class=w> </span><span class=n>actionMasked</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>MotionEvent</span><span class=p>.</span><span class=na>ACTION_HOVER_MOVE</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>resetTouchState</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>split</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=n>actionMasked</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>MotionEvent</span><span class=p>.</span><span class=na>ACTION_POINTER_UP</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=kd>final</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>actionIndex</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>ev</span><span class=p>.</span><span class=na>getActionIndex</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=kd>final</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>idBitsToRemove</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>1</span><span class=w> </span><span class=o>&lt;&lt;</span><span class=w> </span><span class=n>ev</span><span class=p>.</span><span class=na>getPointerId</span><span class=p>(</span><span class=n>actionIndex</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>removePointersFromTouchTargets</span><span class=p>(</span><span class=n>idBitsToRemove</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>handled</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=n>mInputEventConsistencyVerifier</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>mInputEventConsistencyVerifier</span><span class=p>.</span><span class=na>onUnhandledEvent</span><span class=p>(</span><span class=n>ev</span><span class=p>,</span><span class=w> </span><span class=n>1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>handled</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div></div></article></main><footer class=footer><span>&copy; 2024 <a href=https://epicmars.github.io/>AndroidPi</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 8" fill="currentcolor"><path d="M12 8H0l6-8z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>