<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Kotlin高阶函数与Lambdas | AndroidPi</title>
<meta name=keywords content><meta name=description content="参考：
Lambdas 高阶函数 一个高阶函数接收函数作为其参数，或者返回一个函数。举个栗子，如下所示，lock()函数接收一个lock对象和一个函数，获取锁，运行函数，然后释放锁：
fun <T> lock(lock: Lock, body: () -> T): T { lock.lock() try { return body() } finally { lock.unlock() } } body有一个函数类型：() -> T，它是一个返回类型为T的值的方法。
如果我们想调用lock()，我们可以将另一个函数作为参数传递给它（参考：方法引用):
fun toBeSynchronized() = sharedResource.operation() val result = lock(lock, ::toBeSynchronized) 此外，一个更加便捷的方式是传递一个lambda表达式:
val result = lock(lock, { sharedResource.operation() }) Lambda表达式先简要介绍下，后面小节会有详细描述：
一个lambda表达式总是由花括弧包围 它的参数在记号->前声明，参数类型可以忽略 正文跟在->后 在Kotlin中如果一个函数的最后一个参数是一个函数，并且使用lambda表达式传递对应的参数，有一个简便的方式来表示，即将lambda表达式放在函数参数列表括弧外：
lock (lock) { sharedResource.operation() } 另一个例子，如下map()函数所示：
fun <T, R> List<T>.map(transform: (T) -> R): List<R> { val result = arrayListOf<R>() for (item in this) result."><meta name=author content="LEOY"><link rel=canonical href=https://epicmars.github.io/blog/kotlin/2017-10-30-kotlin-lambdas/><link crossorigin=anonymous href=/assets/css/stylesheet.8c0deceb290760c5fd82c47a972a18d5ab7cd5d722684689069ae8f152e19b25.css integrity="sha256-jA3s6ykHYMX9gsR6lyoY1at81dciaEaJBpro8VLhmyU=" rel="preload stylesheet" as=style><link rel=icon href=https://acd-assets.alicdn.com/acd_work/tongyi/assets/logo.svg><link rel=icon type=image/png sizes=16x16 href=https://acd-assets.alicdn.com/acd_work/tongyi/assets/logo.svg><link rel=icon type=image/png sizes=32x32 href=https://acd-assets.alicdn.com/acd_work/tongyi/assets/logo.svg%22><link rel=apple-touch-icon href=https://acd-assets.alicdn.com/acd_work/tongyi/assets/logo.svg><link rel=mask-icon href=https://acd-assets.alicdn.com/acd_work/tongyi/assets/logo.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://epicmars.github.io/blog/kotlin/2017-10-30-kotlin-lambdas/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script defer crossorigin=anonymous src=/js/custom.f20a5212619392e989b6d24ad9ce42302014debfad4d3c8c01db030c36d03475.js integrity="sha256-8gpSEmGTkumJttJK2c5CMCAU3r+tTTyMAdsDDDbQNHU="></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-NMEMBZ8R90"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-NMEMBZ8R90")}</script><meta property="og:title" content="Kotlin高阶函数与Lambdas"><meta property="og:description" content="参考：
Lambdas 高阶函数 一个高阶函数接收函数作为其参数，或者返回一个函数。举个栗子，如下所示，lock()函数接收一个lock对象和一个函数，获取锁，运行函数，然后释放锁：
fun <T> lock(lock: Lock, body: () -> T): T { lock.lock() try { return body() } finally { lock.unlock() } } body有一个函数类型：() -> T，它是一个返回类型为T的值的方法。
如果我们想调用lock()，我们可以将另一个函数作为参数传递给它（参考：方法引用):
fun toBeSynchronized() = sharedResource.operation() val result = lock(lock, ::toBeSynchronized) 此外，一个更加便捷的方式是传递一个lambda表达式:
val result = lock(lock, { sharedResource.operation() }) Lambda表达式先简要介绍下，后面小节会有详细描述：
一个lambda表达式总是由花括弧包围 它的参数在记号->前声明，参数类型可以忽略 正文跟在->后 在Kotlin中如果一个函数的最后一个参数是一个函数，并且使用lambda表达式传递对应的参数，有一个简便的方式来表示，即将lambda表达式放在函数参数列表括弧外：
lock (lock) { sharedResource.operation() } 另一个例子，如下map()函数所示：
fun <T, R> List<T>.map(transform: (T) -> R): List<R> { val result = arrayListOf<R>() for (item in this) result."><meta property="og:type" content="article"><meta property="og:url" content="https://epicmars.github.io/blog/kotlin/2017-10-30-kotlin-lambdas/"><meta property="og:image" content="https://epicmars.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="blog"><meta property="article:published_time" content="2017-10-30T16:34:18+08:00"><meta property="article:modified_time" content="2017-10-30T16:34:18+08:00"><meta property="og:site_name" content="androidpi"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://epicmars.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Kotlin高阶函数与Lambdas"><meta name=twitter:description content="参考：
Lambdas 高阶函数 一个高阶函数接收函数作为其参数，或者返回一个函数。举个栗子，如下所示，lock()函数接收一个lock对象和一个函数，获取锁，运行函数，然后释放锁：
fun <T> lock(lock: Lock, body: () -> T): T { lock.lock() try { return body() } finally { lock.unlock() } } body有一个函数类型：() -> T，它是一个返回类型为T的值的方法。
如果我们想调用lock()，我们可以将另一个函数作为参数传递给它（参考：方法引用):
fun toBeSynchronized() = sharedResource.operation() val result = lock(lock, ::toBeSynchronized) 此外，一个更加便捷的方式是传递一个lambda表达式:
val result = lock(lock, { sharedResource.operation() }) Lambda表达式先简要介绍下，后面小节会有详细描述：
一个lambda表达式总是由花括弧包围 它的参数在记号->前声明，参数类型可以忽略 正文跟在->后 在Kotlin中如果一个函数的最后一个参数是一个函数，并且使用lambda表达式传递对应的参数，有一个简便的方式来表示，即将lambda表达式放在函数参数列表括弧外：
lock (lock) { sharedResource.operation() } 另一个例子，如下map()函数所示：
fun <T, R> List<T>.map(transform: (T) -> R): List<R> { val result = arrayListOf<R>() for (item in this) result."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blogs","item":"https://epicmars.github.io/blog/"},{"@type":"ListItem","position":2,"name":"Kotlin","item":"https://epicmars.github.io/blog/kotlin/"},{"@type":"ListItem","position":3,"name":"Kotlin高阶函数与Lambdas","item":"https://epicmars.github.io/blog/kotlin/2017-10-30-kotlin-lambdas/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Kotlin高阶函数与Lambdas","name":"Kotlin高阶函数与Lambdas","description":"参考：\nLambdas 高阶函数 一个高阶函数接收函数作为其参数，或者返回一个函数。举个栗子，如下所示，lock()函数接收一个lock对象和一个函数，获取锁，运行函数，然后释放锁：\nfun \u0026lt;T\u0026gt; lock(lock: Lock, body: () -\u0026gt; T): T { lock.lock() try { return body() } finally { lock.unlock() } } body有一个函数类型：() -\u0026gt; T，它是一个返回类型为T的值的方法。\n如果我们想调用lock()，我们可以将另一个函数作为参数传递给它（参考：方法引用):\nfun toBeSynchronized() = sharedResource.operation() val result = lock(lock, ::toBeSynchronized) 此外，一个更加便捷的方式是传递一个lambda表达式:\nval result = lock(lock, { sharedResource.operation() }) Lambda表达式先简要介绍下，后面小节会有详细描述：\n一个lambda表达式总是由花括弧包围 它的参数在记号-\u0026gt;前声明，参数类型可以忽略 正文跟在-\u0026gt;后 在Kotlin中如果一个函数的最后一个参数是一个函数，并且使用lambda表达式传递对应的参数，有一个简便的方式来表示，即将lambda表达式放在函数参数列表括弧外：\nlock (lock) { sharedResource.operation() } 另一个例子，如下map()函数所示：\nfun \u0026lt;T, R\u0026gt; List\u0026lt;T\u0026gt;.map(transform: (T) -\u0026gt; R): List\u0026lt;R\u0026gt; { val result = arrayListOf\u0026lt;R\u0026gt;() for (item in this) result.","keywords":[],"articleBody":"参考：\nLambdas 高阶函数 一个高阶函数接收函数作为其参数，或者返回一个函数。举个栗子，如下所示，lock()函数接收一个lock对象和一个函数，获取锁，运行函数，然后释放锁：\nfun \u003cT\u003e lock(lock: Lock, body: () -\u003e T): T { lock.lock() try { return body() } finally { lock.unlock() } } body有一个函数类型：() -\u003e T，它是一个返回类型为T的值的方法。\n如果我们想调用lock()，我们可以将另一个函数作为参数传递给它（参考：方法引用):\nfun toBeSynchronized() = sharedResource.operation() val result = lock(lock, ::toBeSynchronized) 此外，一个更加便捷的方式是传递一个lambda表达式:\nval result = lock(lock, { sharedResource.operation() }) Lambda表达式先简要介绍下，后面小节会有详细描述：\n一个lambda表达式总是由花括弧包围 它的参数在记号-\u003e前声明，参数类型可以忽略 正文跟在-\u003e后 在Kotlin中如果一个函数的最后一个参数是一个函数，并且使用lambda表达式传递对应的参数，有一个简便的方式来表示，即将lambda表达式放在函数参数列表括弧外：\nlock (lock) { sharedResource.operation() } 另一个例子，如下map()函数所示：\nfun \u003cT, R\u003e List\u003cT\u003e.map(transform: (T) -\u003e R): List\u003cR\u003e { val result = arrayListOf\u003cR\u003e() for (item in this) result.add(transform(item)) return result } 该函数可以如下调用：\nval doubled = ints.map { value -\u003e value * 2 } 语法糖\n如果lambda表达式是函数的唯一参数，那么参数括弧也可以省略。\n另一个惯用法是，如果函数仅有一个参数，该参数的声明（以及后面的-\u003e）可以忽略，并使用it代表该参数：\nints.map { it * 2 } 它允许编写LINQ样式的代码：\nstrings.filter { it.length == 5 }.sortedBy { it }.map { it.toUpperCase() } 如果lambda参数未使用，你可以使用一个下划线声明：\nmap.forEach { _, value -\u003e println(\"$value!\") } Lambda表达式与匿名函数 一个\blambda表达式或匿名函数是一个“函数\u001b\b字面量（function literal）”，也就是未声明的函数，作为表达式直接传递。考虑如下例子：\nmax(strings, { a, b -\u003e a.length \u003c b.length }) 函数max是一个高阶函数，它接收一个函数值作为第二个参数，第二个参数是自身为函数的一个表达式，也就是函数字面量。作为一个函数，它等价于：\nfun compare(a: String, b: String): Boolean = a.length \u003c b.length 函数类型 为了让一个函数接收另一个函数作为参数，必须为接收的参数指定一个函数类型，上面的例子中，max的定义如下：\nfun \u003cT\u003e max(collection: Collection\u003cT\u003e, less: (T, T) -\u003e Boolean): T? { var max: T? = null for (it in collection) if (max == null || less(max, it)) max = it return max } 参数less的类型是(T, T) -\u003e Boolean，即一个接收两个类型为T的参数并返回一个Boolean值的函数，它的行为是如果第一个参数小于第二个参数就返回true。\n函数类型中的参数可以命名：\nval compare: (x: T, y: T) -\u003e Int = ... 如果声明了一个可以为空的函数类型变量，将函数类型用括弧包围并加一个问号：\nvar sum: ((Int, Int) -\u003e Int)? = null Lambda表达式语法 Lambda表达式的完整语法形式如下：\nval sum = { x: Int, y: Int -\u003e x + y } 一个Lambda表达式总是使用花括弧包围，参数声明在花括号中，可以有可选的类型标识，正文跟在右箭头符号-\u003e后。如果推断出lambda返回类型不是Unit，那么最后一个表达式就是返回值。\n如果将可选的标识移到外面，可以表示如下：\nval sum: (Int, Int) -\u003e Int = { x, y -\u003e x + y } 我们可以使用限定的return语法从lambda中显式地返回一个值，否则会返回最后一个表达式的值，下面两种表示是等价的：\nints.filter { val shouldFilter = it \u003e 0 shouldFilter } ints.filter { val shouldFilter = it \u003e 0 return@filter shouldFilter } 匿名函数 上面的lambda表达式中不能指定函数的返回类型，大多数情况下，可以进行自动推断。然而，如果你想特别指定，可以使用匿名函数：\nfun(x: Int, y: Int): Int = x + y fun(x: Int, y: Int): Int { return x + y } 参数和返回类型的指定和常规函数一样，除了一点以外，即匿名函数参数类型如果可以从上下文中推断出，那么可以将其忽略：\nints.filter(fun(item) = item \u003e 0) 匿名函数和lambda表达式的不同之处在于它不能作为括弧外参数传递，此外，两者的非局部返回(non-local returns)行为也不一样，一个无标签的return总是从fun声明的函数内返回，这表明lambda表达式中的return会从包围函数返回，而匿名函数会从自身返回。\n闭包（Closures） 一个lambda表达式或者匿名函数（以及局部函数和对象表达式）可以访问其闭包，也就是在外部范围声明的变量。\nvar sum = 0 ints.filter { it \u003e 0 }.forEach { sum += it } print(sum) 带接收器的函数字面量 Kotlin允许用一个指定的接收对象调用一个函数字面量。在函数字面量的正文中，你可以直接调用接收对象的方法。这有点类似扩展函数，它允许你在函数体重访问接收对象的成员。\n这种类型的函数字面量是一个带接收器的函数类型：\nsum : Int.(other: Int) -\u003e Int 函数字面量可以像接受对象的成员一样进行调用：\n1.sum(2) 你们函数语法允许你直接指定一个函数字面量的接收器类型。如果你需要声明一个带接收器的函数类型变量，这就十分有用：\nval sum = fun Int.(other: Int): Int = this + other 对于一个带接收器函数类型的非字面量值，在一个接收常规函数作为参数的地方并且该常规函数类型第一个参数与该值的接收器类型一样，那么该值可以作为参数传递，反之亦然。例如，类型String.(Int) -\u003e Boolean和(String, Int) -\u003e Boolean是兼容的：\nval represents: String.(Int) -\u003e Boolean = { other -\u003e toIntOrNull() == other } println(\"123\".represents(123)) // true fun testOperation(op: (String, Int) -\u003e Boolean, a: String, b: Int, c: Boolean) = assert(op(a, b) == c) testOperation(represents, \"100\", 100, true) // OK 当接收器类型可以从上下文中推断出时，Lambda表达式可以用作带接收器的函数字面量：\nclass HTML { fun body() { ... } } fun html(init: HTML.() -\u003e Unit): HTML { val html = HTML() // create the receiver object html.init() // pass the receiver object to the lambda return html } html { // lambda with receiver begins here body() // calling a method on the receiver object } ","wordCount":"428","inLanguage":"en","image":"https://epicmars.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2017-10-30T16:34:18+08:00","dateModified":"2017-10-30T16:34:18+08:00","author":{"@type":"Person","name":"LEOY"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://epicmars.github.io/blog/kotlin/2017-10-30-kotlin-lambdas/"},"publisher":{"@type":"Organization","name":"AndroidPi","logo":{"@type":"ImageObject","url":"https://acd-assets.alicdn.com/acd_work/tongyi/assets/logo.svg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://epicmars.github.io/ accesskey=h title="AndroidPi (Alt + H)">AndroidPi</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://epicmars.github.io/zh/ title=简体中文 aria-label=简体中文>简体中文</a></li></ul></div></div><ul id=menu><li><a href=https://epicmars.github.io/resources title=Resources><span>Resources</span></a></li><li><a href=https://epicmars.github.io/blog/ title=Blog><span>Blog</span></a></li><li><a href=https://epicmars.github.io/publication title=Publication><span>Publication</span></a></li><li><a href=https://epicmars.github.io/about title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Kotlin高阶函数与Lambdas</h1><div class=post-meta><span title='2017-10-30 16:34:18 +0800 CST'>October 30, 2017</span>&nbsp;·&nbsp;LEOY</div></header><div class=post-content><p>参考：</p><ul><li><a href=https://kotlinlang.org/docs/reference/lambdas.html>Lambdas</a></li></ul><h2 id=高阶函数>高阶函数<a hidden class=anchor aria-hidden=true href=#高阶函数>#</a></h2><p>一个高阶函数接收函数作为其参数，或者返回一个函数。举个栗子，如下所示，lock()函数接收一个lock对象和一个函数，获取锁，运行函数，然后释放锁：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>    <span class=k>fun</span> <span class=p>&lt;</span><span class=nc>T</span><span class=p>&gt;</span> <span class=nf>lock</span><span class=p>(</span><span class=n>lock</span><span class=p>:</span> <span class=n>Lock</span><span class=p>,</span> <span class=n>body</span><span class=p>:</span> <span class=p>()</span> <span class=o>-&gt;</span> <span class=n>T</span><span class=p>):</span> <span class=n>T</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>lock</span><span class=p>.</span><span class=n>lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=k>try</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>body</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>finally</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>lock</span><span class=p>.</span><span class=n>unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span></code></pre></div><p>body有一个<a href=https://kotlinlang.org/docs/reference/lambdas.html#function-types>函数类型</a>：() -> T，它是一个返回类型为T的值的方法。</p><p>如果我们想调用lock()，我们可以将另一个函数作为参数传递给它（参考：<a href=https://kotlinlang.org/docs/reference/reflection.html#function-references>方法引用</a>):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>    <span class=k>fun</span> <span class=nf>toBeSynchronized</span><span class=p>()</span> <span class=p>=</span> <span class=n>sharedResource</span><span class=p>.</span><span class=n>operation</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>result</span> <span class=p>=</span> <span class=n>lock</span><span class=p>(</span><span class=n>lock</span><span class=p>,</span> <span class=o>::</span><span class=n>toBeSynchronized</span><span class=p>)</span>
</span></span></code></pre></div><p>此外，一个更加便捷的方式是传递一个<a href=https://kotlinlang.org/docs/reference/lambdas.html#lambda-expressions-and-anonymous-functions>lambda表达式</a>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>    <span class=k>val</span> <span class=py>result</span> <span class=p>=</span> <span class=n>lock</span><span class=p>(</span><span class=n>lock</span><span class=p>,</span> <span class=p>{</span> <span class=n>sharedResource</span><span class=p>.</span><span class=n>operation</span><span class=p>()</span> <span class=p>})</span>
</span></span></code></pre></div><p>Lambda表达式先简要介绍下，后面小节会有详细描述：</p><ul><li>一个lambda表达式总是由花括弧包围</li><li>它的参数在记号<code>-></code>前声明，参数类型可以忽略</li><li>正文跟在<code>-></code>后</li></ul><p>在Kotlin中如果一个函数的最后一个参数是一个函数，并且使用lambda表达式传递对应的参数，有一个简便的方式来表示，即将lambda表达式放在函数参数列表括弧外：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>    <span class=n>lock</span> <span class=p>(</span><span class=n>lock</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>sharedResource</span><span class=p>.</span><span class=n>operation</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span></code></pre></div><p>另一个例子，如下map()函数所示：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>    <span class=k>fun</span> <span class=p>&lt;</span><span class=nc>T</span><span class=p>,</span> <span class=nc>R</span><span class=p>&gt;</span> <span class=nf>List</span><span class=p>&lt;</span><span class=n>T</span><span class=p>&gt;.</span><span class=n>map</span><span class=p>(</span><span class=n>transform</span><span class=p>:</span> <span class=p>(</span><span class=n>T</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>R</span><span class=p>):</span> <span class=n>List</span><span class=p>&lt;</span><span class=n>R</span><span class=p>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>val</span> <span class=py>result</span> <span class=p>=</span> <span class=n>arrayListOf</span><span class=p>&lt;</span><span class=n>R</span><span class=p>&gt;()</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=n>item</span> <span class=k>in</span> <span class=k>this</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>result</span><span class=p>.</span><span class=n>add</span><span class=p>(</span><span class=n>transform</span><span class=p>(</span><span class=n>item</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>result</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span></code></pre></div><p>该函数可以如下调用：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>    <span class=k>val</span> <span class=py>doubled</span> <span class=p>=</span> <span class=n>ints</span><span class=p>.</span><span class=n>map</span> <span class=p>{</span> <span class=k>value</span> <span class=o>-&gt;</span> <span class=k>value</span> <span class=p>*</span> <span class=m>2</span> <span class=p>}</span>
</span></span></code></pre></div><p><em>语法糖</em></p><blockquote><p>如果lambda表达式是函数的唯一参数，那么参数括弧也可以省略。</p><p>另一个惯用法是，如果函数仅有一个参数，该参数的声明（以及后面的<code>-></code>）可以忽略，并使用<code>it</code>代表该参数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>    <span class=n>ints</span><span class=p>.</span><span class=n>map</span> <span class=p>{</span> <span class=k>it</span> <span class=p>*</span> <span class=m>2</span> <span class=p>}</span>
</span></span></code></pre></div><p>它允许编写<a href=http://msdn.microsoft.com/en-us/library/bb308959.aspx>LINQ样式</a>的代码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>    <span class=n>strings</span><span class=p>.</span><span class=n>filter</span> <span class=p>{</span> <span class=k>it</span><span class=p>.</span><span class=n>length</span> <span class=o>==</span> <span class=m>5</span> <span class=p>}.</span><span class=n>sortedBy</span> <span class=p>{</span> <span class=k>it</span> <span class=p>}.</span><span class=n>map</span> <span class=p>{</span> <span class=k>it</span><span class=p>.</span><span class=n>toUpperCase</span><span class=p>()</span> <span class=p>}</span>
</span></span></code></pre></div><p>如果lambda参数未使用，你可以使用一个下划线声明：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>    <span class=n>map</span><span class=p>.</span><span class=n>forEach</span> <span class=p>{</span> <span class=n>_</span><span class=p>,</span> <span class=k>value</span> <span class=o>-&gt;</span> <span class=n>println</span><span class=p>(</span><span class=s2>&#34;</span><span class=si>$value</span><span class=s2>!&#34;</span><span class=p>)</span> <span class=p>}</span>
</span></span></code></pre></div></blockquote><h2 id=lambda表达式与匿名函数>Lambda表达式与匿名函数<a hidden class=anchor aria-hidden=true href=#lambda表达式与匿名函数>#</a></h2><p>一个lambda表达式或匿名函数是一个“函数字面量（function literal）”，也就是未声明的函数，作为表达式直接传递。考虑如下例子：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>    <span class=n>max</span><span class=p>(</span><span class=n>strings</span><span class=p>,</span> <span class=p>{</span> <span class=n>a</span><span class=p>,</span> <span class=n>b</span> <span class=o>-&gt;</span> <span class=n>a</span><span class=p>.</span><span class=n>length</span> <span class=p>&lt;</span> <span class=n>b</span><span class=p>.</span><span class=n>length</span> <span class=p>})</span>
</span></span></code></pre></div><p>函数max是一个高阶函数，它接收一个函数值作为第二个参数，第二个参数是自身为函数的一个表达式，也就是函数字面量。作为一个函数，它等价于：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>    <span class=k>fun</span> <span class=nf>compare</span><span class=p>(</span><span class=n>a</span><span class=p>:</span> <span class=n>String</span><span class=p>,</span> <span class=n>b</span><span class=p>:</span> <span class=n>String</span><span class=p>):</span> <span class=n>Boolean</span> <span class=p>=</span> <span class=n>a</span><span class=p>.</span><span class=n>length</span> <span class=p>&lt;</span> <span class=n>b</span><span class=p>.</span><span class=n>length</span>
</span></span></code></pre></div><h3 id=函数类型>函数类型<a hidden class=anchor aria-hidden=true href=#函数类型>#</a></h3><p>为了让一个函数接收另一个函数作为参数，必须为接收的参数指定一个函数类型，上面的例子中，max的定义如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>    <span class=k>fun</span> <span class=p>&lt;</span><span class=nc>T</span><span class=p>&gt;</span> <span class=nf>max</span><span class=p>(</span><span class=n>collection</span><span class=p>:</span> <span class=n>Collection</span><span class=p>&lt;</span><span class=n>T</span><span class=p>&gt;,</span> <span class=n>less</span><span class=p>:</span> <span class=p>(</span><span class=n>T</span><span class=p>,</span> <span class=n>T</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Boolean</span><span class=p>):</span> <span class=n>T</span><span class=p>?</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>var</span> <span class=py>max</span><span class=p>:</span> <span class=n>T</span><span class=p>?</span> <span class=p>=</span> <span class=k>null</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=k>it</span> <span class=k>in</span> <span class=n>collection</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>max</span> <span class=o>==</span> <span class=k>null</span> <span class=o>||</span> <span class=n>less</span><span class=p>(</span><span class=n>max</span><span class=p>,</span> <span class=k>it</span><span class=p>))</span>
</span></span><span class=line><span class=cl>                <span class=n>max</span> <span class=p>=</span> <span class=k>it</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>max</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span></code></pre></div><p>参数less的类型是<code>(T, T) -> Boolean</code>，即一个接收两个类型为T的参数并返回一个Boolean值的函数，它的行为是如果第一个参数小于第二个参数就返回true。</p><p>函数类型中的参数可以命名：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>    <span class=k>val</span> <span class=py>compare</span><span class=p>:</span> <span class=p>(</span><span class=n>x</span><span class=p>:</span> <span class=n>T</span><span class=p>,</span> <span class=n>y</span><span class=p>:</span> <span class=n>T</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Int</span> <span class=p>=</span> <span class=o>..</span><span class=p>.</span>
</span></span></code></pre></div><p>如果声明了一个可以为空的函数类型变量，将函数类型用括弧包围并加一个问号：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>    <span class=k>var</span> <span class=py>sum</span><span class=p>:</span> <span class=p>((</span><span class=n>Int</span><span class=p>,</span> <span class=n>Int</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Int</span><span class=p>)?</span> <span class=p>=</span> <span class=k>null</span>
</span></span></code></pre></div><h3 id=lambda表达式语法>Lambda表达式语法<a hidden class=anchor aria-hidden=true href=#lambda表达式语法>#</a></h3><p>Lambda表达式的完整语法形式如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>    <span class=k>val</span> <span class=py>sum</span> <span class=p>=</span> <span class=p>{</span> <span class=n>x</span><span class=p>:</span> <span class=n>Int</span><span class=p>,</span> <span class=n>y</span><span class=p>:</span> <span class=n>Int</span> <span class=o>-&gt;</span> <span class=n>x</span> <span class=p>+</span> <span class=n>y</span> <span class=p>}</span>
</span></span></code></pre></div><p>一个Lambda表达式总是使用花括弧包围，参数声明在花括号中，可以有可选的类型标识，正文跟在右箭头符号<code>-></code>后。如果推断出lambda返回类型不是Unit，那么最后一个表达式就是返回值。</p><p>如果将可选的标识移到外面，可以表示如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>    <span class=k>val</span> <span class=py>sum</span><span class=p>:</span> <span class=p>(</span><span class=n>Int</span><span class=p>,</span> <span class=n>Int</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Int</span> <span class=p>=</span> <span class=p>{</span> <span class=n>x</span><span class=p>,</span> <span class=n>y</span> <span class=o>-&gt;</span> <span class=n>x</span> <span class=p>+</span> <span class=n>y</span> <span class=p>}</span>
</span></span></code></pre></div><p>我们可以使用<a href=https://kotlinlang.org/docs/reference/returns.html#return-at-labels>限定的return</a>语法从lambda中显式地返回一个值，否则会返回最后一个表达式的值，下面两种表示是等价的：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>    <span class=n>ints</span><span class=p>.</span><span class=n>filter</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>val</span> <span class=py>shouldFilter</span> <span class=p>=</span> <span class=k>it</span> <span class=p>&gt;</span> <span class=m>0</span> 
</span></span><span class=line><span class=cl>        <span class=n>shouldFilter</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>ints</span><span class=p>.</span><span class=n>filter</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>val</span> <span class=py>shouldFilter</span> <span class=p>=</span> <span class=k>it</span> <span class=p>&gt;</span> <span class=m>0</span> 
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=nd>@filter</span> <span class=n>shouldFilter</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span></code></pre></div><h3 id=匿名函数>匿名函数<a hidden class=anchor aria-hidden=true href=#匿名函数>#</a></h3><p>上面的lambda表达式中不能指定函数的返回类型，大多数情况下，可以进行自动推断。然而，如果你想特别指定，可以使用匿名函数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>    <span class=k>fun</span><span class=p>(</span><span class=n>x</span><span class=p>:</span> <span class=n>Int</span><span class=p>,</span> <span class=n>y</span><span class=p>:</span> <span class=n>Int</span><span class=p>):</span> <span class=n>Int</span> <span class=p>=</span> <span class=n>x</span> <span class=p>+</span> <span class=n>y</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>fun</span><span class=p>(</span><span class=n>x</span><span class=p>:</span> <span class=n>Int</span><span class=p>,</span> <span class=n>y</span><span class=p>:</span> <span class=n>Int</span><span class=p>):</span> <span class=n>Int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>x</span> <span class=p>+</span> <span class=n>y</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span></code></pre></div><p>参数和返回类型的指定和常规函数一样，除了一点以外，即匿名函数参数类型如果可以从上下文中推断出，那么可以将其忽略：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>    <span class=n>ints</span><span class=p>.</span><span class=n>filter</span><span class=p>(</span><span class=k>fun</span><span class=p>(</span><span class=n>item</span><span class=p>)</span> <span class=p>=</span> <span class=n>item</span> <span class=p>&gt;</span> <span class=m>0</span><span class=p>)</span>
</span></span></code></pre></div><p>匿名函数和lambda表达式的不同之处在于它不能作为括弧外参数传递，此外，两者的<a href=https://kotlinlang.org/docs/reference/inline-functions.html#non-local-returns>非局部返回(non-local returns)</a>行为也不一样，一个无标签的return总是从fun声明的函数内返回，这表明lambda表达式中的return会从包围函数返回，而匿名函数会从自身返回。</p><h3 id=闭包closures>闭包（Closures）<a hidden class=anchor aria-hidden=true href=#闭包closures>#</a></h3><p>一个lambda表达式或者匿名函数（以及局部函数和对象表达式）可以访问其闭包，也就是在外部范围声明的变量。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>    <span class=k>var</span> <span class=py>sum</span> <span class=p>=</span> <span class=m>0</span>
</span></span><span class=line><span class=cl>    <span class=n>ints</span><span class=p>.</span><span class=n>filter</span> <span class=p>{</span> <span class=k>it</span> <span class=p>&gt;</span> <span class=m>0</span> <span class=p>}.</span><span class=n>forEach</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>sum</span> <span class=o>+=</span> <span class=k>it</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>print</span><span class=p>(</span><span class=n>sum</span><span class=p>)</span>
</span></span></code></pre></div><h3 id=带接收器的函数字面量>带接收器的函数字面量<a hidden class=anchor aria-hidden=true href=#带接收器的函数字面量>#</a></h3><p>Kotlin允许用一个指定的接收对象调用一个函数字面量。在函数字面量的正文中，你可以直接调用接收对象的方法。这有点类似扩展函数，它允许你在函数体重访问接收对象的成员。</p><p>这种类型的函数字面量是一个带接收器的函数类型：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>    <span class=n>sum</span> <span class=p>:</span> <span class=nc>Int</span><span class=p>.(</span><span class=n>other</span><span class=p>:</span> <span class=n>Int</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Int</span>
</span></span></code></pre></div><p>函数字面量可以像接受对象的成员一样进行调用：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>    <span class=m>1.</span><span class=n>sum</span><span class=p>(</span><span class=m>2</span><span class=p>)</span>
</span></span></code></pre></div><p>你们函数语法允许你直接指定一个函数字面量的接收器类型。如果你需要声明一个带接收器的函数类型变量，这就十分有用：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>    <span class=k>val</span> <span class=py>sum</span> <span class=p>=</span> <span class=k>fun</span> <span class=nf>Int</span><span class=p>.(</span><span class=n>other</span><span class=p>:</span> <span class=n>Int</span><span class=p>):</span> <span class=n>Int</span> <span class=p>=</span> <span class=k>this</span> <span class=p>+</span> <span class=n>other</span>
</span></span></code></pre></div><p>对于一个带接收器函数类型的非字面量值，在一个接收常规函数作为参数的地方并且该常规函数类型第一个参数与该值的接收器类型一样，那么该值可以作为参数传递，反之亦然。例如，类型<code>String.(Int) -> Boolean</code>和<code>(String, Int) -> Boolean</code>是兼容的：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>    <span class=k>val</span> <span class=py>represents</span><span class=p>:</span> <span class=nc>String</span><span class=p>.(</span><span class=n>Int</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Boolean</span> <span class=p>=</span> <span class=p>{</span> <span class=n>other</span> <span class=o>-&gt;</span> <span class=n>toIntOrNull</span><span class=p>()</span> <span class=o>==</span> <span class=n>other</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>println</span><span class=p>(</span><span class=s2>&#34;123&#34;</span><span class=p>.</span><span class=n>represents</span><span class=p>(</span><span class=m>123</span><span class=p>))</span> <span class=c1>// true
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=k>fun</span> <span class=nf>testOperation</span><span class=p>(</span><span class=n>op</span><span class=p>:</span> <span class=p>(</span><span class=n>String</span><span class=p>,</span> <span class=n>Int</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Boolean</span><span class=p>,</span> <span class=n>a</span><span class=p>:</span> <span class=n>String</span><span class=p>,</span> <span class=n>b</span><span class=p>:</span> <span class=n>Int</span><span class=p>,</span> <span class=n>c</span><span class=p>:</span> <span class=n>Boolean</span><span class=p>)</span> <span class=p>=</span>
</span></span><span class=line><span class=cl>        <span class=n>assert</span><span class=p>(</span><span class=n>op</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>)</span> <span class=o>==</span> <span class=n>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>    <span class=n>testOperation</span><span class=p>(</span><span class=n>represents</span><span class=p>,</span> <span class=s2>&#34;100&#34;</span><span class=p>,</span> <span class=m>100</span><span class=p>,</span> <span class=k>true</span><span class=p>)</span> <span class=c1>// OK
</span></span></span></code></pre></div><p>当接收器类型可以从上下文中推断出时，Lambda表达式可以用作带接收器的函数字面量：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>    <span class=k>class</span> <span class=nc>HTML</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>fun</span> <span class=nf>body</span><span class=p>()</span> <span class=p>{</span> <span class=o>..</span><span class=p>.</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>fun</span> <span class=nf>html</span><span class=p>(</span><span class=k>init</span><span class=p>:</span> <span class=nc>HTML</span><span class=p>.()</span> <span class=o>-&gt;</span> <span class=n>Unit</span><span class=p>):</span> <span class=n>HTML</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>val</span> <span class=py>html</span> <span class=p>=</span> <span class=n>HTML</span><span class=p>()</span>  <span class=c1>// create the receiver object
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>html</span><span class=p>.</span><span class=k>init</span><span class=p>()</span>        <span class=c1>// pass the receiver object to the lambda
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>return</span> <span class=n>html</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>html</span> <span class=p>{</span>       <span class=c1>// lambda with receiver begins here
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>body</span><span class=p>()</span>   <span class=c1>// calling a method on the receiver object
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://epicmars.github.io/>AndroidPi</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>