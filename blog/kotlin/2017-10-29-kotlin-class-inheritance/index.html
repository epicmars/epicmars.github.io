<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Kotlin类与继承 | AndroidPi</title>
<meta name=keywords content><meta name=description content='类定义 类声明由类名、类首部（指定类型参数，主构造器等）、类正文（用花括号包围）。类首部和正文都是可选的。因此最简单的类定义为：
class Empty // Implicitly inherits from Any 类似所有Java类都继承类Object，所有Kotlin类都继承类Any，但Any不是与特定平台（例如JVM）相关的，它不是一个java.lang.Object，这表明当Kotlin与Java代码进行互操作时，为了使用Object的成员方法，Kotlin提供了扩展函数。
例如为了调用Object的wait()/notify()方法，可以将一个kotlin对象foo转型为Object：
(foo as java.lang.Object).wait() 为了获取一个kotlin对象的Java类，Kotlin1.1之后可以使用class引用的java扩展属性，也可以直接使用扩展属性javaClass:
val fooClass = foo::class.java // class reference val fooClass = foo.javaClass // extension property: javaClass 与Java代码进行互操作，Kotlin在语言层面上是这样设计的，但在编译为Java字节码以及JVM运行时中，每个类总是默认继承了Object。
构造器 Kotlin的构造器分为主构造器（primary constructor）和次要构造器（secondary constructors）。两者都是可选的，即可以不用明确定义任何构造器，这时如果该类不是抽象类，就采用默认生成的无参主构造器。主构造器只能有一个，次要构造器可以有多个，次要构造器必须代理到主构造器，可以是直接的代理或使用其它次要构造器间接代理。造器的可见性默认是public的。
这里讨论下主构造器，先了解下Java对象的初始化，大致说了Java对象初始化机制有三种：实例初始化器（初始化块）、实例变量初始化器、构造器。初始化块和实例变量初始化器可以认为是实例初始化器的两种不同形式，实例变量初始化器只不过定义了实例变量并使用表达式而非块进行了初始化。在对象初始化时，由于存在继承层次结构，每一层级类都需要进行初始化，一个对象从自身开始向上到父类，到父类的父类等等，直到Object类，完成整个类层次的初始化。所以该对象的构造器必须直接或间接地调用父类构造器，这也说明了为什么构造器不属于Java类成员，它不会被子类继承，不然会造成初始化的死循环。构造器是初始化的入口，但不是初始化的全部，并且为了保证初始化过程的顺序，编译器会为每个构造器生成一个<init>方法，包含以下代码：
对另一个构造函数的调用（为了直接或间接调用父类构造器） 初始化器（包括变量初始器器和块初始化器，为了保证初始化器仅运行一次，如果第1步调用是本地另一个构造函数,那么便不需要 初始化器的代码） 构造函数正文 在Kotlin中，初始化块使用init关键字声明：
init { print("This is a intializer block.") } 如果一个Kotlin类未继承其它另外定义的类，那么它默认继承类Any, 如下所示：
未定义主构造器
未定义次要构造器：编译器会为其生成一个无参主构造器 定义了次要构造器：那么它将仅有次要构造器，不会自动生成无参构造器 class Car { // ... constructor(type: String, name: String) { // ... } } 定义了主构造器，并且定义了次要构造器
class Car(type: String, name: String) { // .'><meta name=author content="LEOY"><link rel=canonical href=https://epicmars.github.io/blog/kotlin/2017-10-29-kotlin-class-inheritance/><link crossorigin=anonymous href=/assets/css/stylesheet.1715a8df06a9f4f4b7cfb26895ef9124122a85cbef9cde37608112c4ba7767f6.css integrity="sha256-FxWo3wap9PS3z7Jole+RJBIqhcvvnN43YIESxLp3Z/Y=" rel="preload stylesheet" as=style><link rel=icon href=https://acd-assets.alicdn.com/acd_work/tongyi/assets/logo.svg><link rel=icon type=image/png sizes=16x16 href=https://acd-assets.alicdn.com/acd_work/tongyi/assets/logo.svg><link rel=icon type=image/png sizes=32x32 href=https://acd-assets.alicdn.com/acd_work/tongyi/assets/logo.svg%22><link rel=apple-touch-icon href=https://acd-assets.alicdn.com/acd_work/tongyi/assets/logo.svg><link rel=mask-icon href=https://acd-assets.alicdn.com/acd_work/tongyi/assets/logo.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://epicmars.github.io/blog/kotlin/2017-10-29-kotlin-class-inheritance/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script defer crossorigin=anonymous src=/js/custom.f20a5212619392e989b6d24ad9ce42302014debfad4d3c8c01db030c36d03475.js integrity="sha256-8gpSEmGTkumJttJK2c5CMCAU3r+tTTyMAdsDDDbQNHU="></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.3/dist/katex.min.css integrity=sha384-Juol1FqnotbkyZUT5Z7gUPjQ9gzlwCENvUZTpQBAPxtusdwFLRy382PSDx5UUJ4/ crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.3/dist/katex.min.js integrity=sha384-97gW6UIJxnlKemYavrqDHSX3SiygeOwIZhwyOKRfSaf0JWKRVj9hLASHgFTzT+0O crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.3/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-NMEMBZ8R90"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-NMEMBZ8R90")}</script><meta property="og:title" content="Kotlin类与继承"><meta property="og:description" content='类定义 类声明由类名、类首部（指定类型参数，主构造器等）、类正文（用花括号包围）。类首部和正文都是可选的。因此最简单的类定义为：
class Empty // Implicitly inherits from Any 类似所有Java类都继承类Object，所有Kotlin类都继承类Any，但Any不是与特定平台（例如JVM）相关的，它不是一个java.lang.Object，这表明当Kotlin与Java代码进行互操作时，为了使用Object的成员方法，Kotlin提供了扩展函数。
例如为了调用Object的wait()/notify()方法，可以将一个kotlin对象foo转型为Object：
(foo as java.lang.Object).wait() 为了获取一个kotlin对象的Java类，Kotlin1.1之后可以使用class引用的java扩展属性，也可以直接使用扩展属性javaClass:
val fooClass = foo::class.java // class reference val fooClass = foo.javaClass // extension property: javaClass 与Java代码进行互操作，Kotlin在语言层面上是这样设计的，但在编译为Java字节码以及JVM运行时中，每个类总是默认继承了Object。
构造器 Kotlin的构造器分为主构造器（primary constructor）和次要构造器（secondary constructors）。两者都是可选的，即可以不用明确定义任何构造器，这时如果该类不是抽象类，就采用默认生成的无参主构造器。主构造器只能有一个，次要构造器可以有多个，次要构造器必须代理到主构造器，可以是直接的代理或使用其它次要构造器间接代理。造器的可见性默认是public的。
这里讨论下主构造器，先了解下Java对象的初始化，大致说了Java对象初始化机制有三种：实例初始化器（初始化块）、实例变量初始化器、构造器。初始化块和实例变量初始化器可以认为是实例初始化器的两种不同形式，实例变量初始化器只不过定义了实例变量并使用表达式而非块进行了初始化。在对象初始化时，由于存在继承层次结构，每一层级类都需要进行初始化，一个对象从自身开始向上到父类，到父类的父类等等，直到Object类，完成整个类层次的初始化。所以该对象的构造器必须直接或间接地调用父类构造器，这也说明了为什么构造器不属于Java类成员，它不会被子类继承，不然会造成初始化的死循环。构造器是初始化的入口，但不是初始化的全部，并且为了保证初始化过程的顺序，编译器会为每个构造器生成一个<init>方法，包含以下代码：
对另一个构造函数的调用（为了直接或间接调用父类构造器） 初始化器（包括变量初始器器和块初始化器，为了保证初始化器仅运行一次，如果第1步调用是本地另一个构造函数,那么便不需要 初始化器的代码） 构造函数正文 在Kotlin中，初始化块使用init关键字声明：
init { print("This is a intializer block.") } 如果一个Kotlin类未继承其它另外定义的类，那么它默认继承类Any, 如下所示：
未定义主构造器
未定义次要构造器：编译器会为其生成一个无参主构造器 定义了次要构造器：那么它将仅有次要构造器，不会自动生成无参构造器 class Car { // ... constructor(type: String, name: String) { // ... } } 定义了主构造器，并且定义了次要构造器
class Car(type: String, name: String) { // .'><meta property="og:type" content="article"><meta property="og:url" content="https://epicmars.github.io/blog/kotlin/2017-10-29-kotlin-class-inheritance/"><meta property="og:image" content="https://epicmars.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="blog"><meta property="article:published_time" content="2017-10-29T15:27:43+08:00"><meta property="article:modified_time" content="2017-10-29T15:27:43+08:00"><meta property="og:site_name" content="androidpi"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://epicmars.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Kotlin类与继承"><meta name=twitter:description content='类定义 类声明由类名、类首部（指定类型参数，主构造器等）、类正文（用花括号包围）。类首部和正文都是可选的。因此最简单的类定义为：
class Empty // Implicitly inherits from Any 类似所有Java类都继承类Object，所有Kotlin类都继承类Any，但Any不是与特定平台（例如JVM）相关的，它不是一个java.lang.Object，这表明当Kotlin与Java代码进行互操作时，为了使用Object的成员方法，Kotlin提供了扩展函数。
例如为了调用Object的wait()/notify()方法，可以将一个kotlin对象foo转型为Object：
(foo as java.lang.Object).wait() 为了获取一个kotlin对象的Java类，Kotlin1.1之后可以使用class引用的java扩展属性，也可以直接使用扩展属性javaClass:
val fooClass = foo::class.java // class reference val fooClass = foo.javaClass // extension property: javaClass 与Java代码进行互操作，Kotlin在语言层面上是这样设计的，但在编译为Java字节码以及JVM运行时中，每个类总是默认继承了Object。
构造器 Kotlin的构造器分为主构造器（primary constructor）和次要构造器（secondary constructors）。两者都是可选的，即可以不用明确定义任何构造器，这时如果该类不是抽象类，就采用默认生成的无参主构造器。主构造器只能有一个，次要构造器可以有多个，次要构造器必须代理到主构造器，可以是直接的代理或使用其它次要构造器间接代理。造器的可见性默认是public的。
这里讨论下主构造器，先了解下Java对象的初始化，大致说了Java对象初始化机制有三种：实例初始化器（初始化块）、实例变量初始化器、构造器。初始化块和实例变量初始化器可以认为是实例初始化器的两种不同形式，实例变量初始化器只不过定义了实例变量并使用表达式而非块进行了初始化。在对象初始化时，由于存在继承层次结构，每一层级类都需要进行初始化，一个对象从自身开始向上到父类，到父类的父类等等，直到Object类，完成整个类层次的初始化。所以该对象的构造器必须直接或间接地调用父类构造器，这也说明了为什么构造器不属于Java类成员，它不会被子类继承，不然会造成初始化的死循环。构造器是初始化的入口，但不是初始化的全部，并且为了保证初始化过程的顺序，编译器会为每个构造器生成一个<init>方法，包含以下代码：
对另一个构造函数的调用（为了直接或间接调用父类构造器） 初始化器（包括变量初始器器和块初始化器，为了保证初始化器仅运行一次，如果第1步调用是本地另一个构造函数,那么便不需要 初始化器的代码） 构造函数正文 在Kotlin中，初始化块使用init关键字声明：
init { print("This is a intializer block.") } 如果一个Kotlin类未继承其它另外定义的类，那么它默认继承类Any, 如下所示：
未定义主构造器
未定义次要构造器：编译器会为其生成一个无参主构造器 定义了次要构造器：那么它将仅有次要构造器，不会自动生成无参构造器 class Car { // ... constructor(type: String, name: String) { // ... } } 定义了主构造器，并且定义了次要构造器
class Car(type: String, name: String) { // .'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blogs","item":"https://epicmars.github.io/blog/"},{"@type":"ListItem","position":2,"name":"Kotlin","item":"https://epicmars.github.io/blog/kotlin/"},{"@type":"ListItem","position":3,"name":"Kotlin类与继承","item":"https://epicmars.github.io/blog/kotlin/2017-10-29-kotlin-class-inheritance/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Kotlin类与继承","name":"Kotlin类与继承","description":"类定义 类声明由类名、类首部（指定类型参数，主构造器等）、类正文（用花括号包围）。类首部和正文都是可选的。因此最简单的类定义为：\nclass Empty // Implicitly inherits from Any 类似所有Java类都继承类Object，所有Kotlin类都继承类Any，但Any不是与特定平台（例如JVM）相关的，它不是一个java.lang.Object，这表明当Kotlin与Java代码进行互操作时，为了使用Object的成员方法，Kotlin提供了扩展函数。\n例如为了调用Object的wait()/notify()方法，可以将一个kotlin对象foo转型为Object：\n(foo as java.lang.Object).wait() 为了获取一个kotlin对象的Java类，Kotlin1.1之后可以使用class引用的java扩展属性，也可以直接使用扩展属性javaClass:\nval fooClass = foo::class.java // class reference val fooClass = foo.javaClass // extension property: javaClass 与Java代码进行互操作，Kotlin在语言层面上是这样设计的，但在编译为Java字节码以及JVM运行时中，每个类总是默认继承了Object。\n构造器 Kotlin的构造器分为主构造器（primary constructor）和次要构造器（secondary constructors）。两者都是可选的，即可以不用明确定义任何构造器，这时如果该类不是抽象类，就采用默认生成的无参主构造器。主构造器只能有一个，次要构造器可以有多个，次要构造器必须代理到主构造器，可以是直接的代理或使用其它次要构造器间接代理。造器的可见性默认是public的。\n这里讨论下主构造器，先了解下Java对象的初始化，大致说了Java对象初始化机制有三种：实例初始化器（初始化块）、实例变量初始化器、构造器。初始化块和实例变量初始化器可以认为是实例初始化器的两种不同形式，实例变量初始化器只不过定义了实例变量并使用表达式而非块进行了初始化。在对象初始化时，由于存在继承层次结构，每一层级类都需要进行初始化，一个对象从自身开始向上到父类，到父类的父类等等，直到Object类，完成整个类层次的初始化。所以该对象的构造器必须直接或间接地调用父类构造器，这也说明了为什么构造器不属于Java类成员，它不会被子类继承，不然会造成初始化的死循环。构造器是初始化的入口，但不是初始化的全部，并且为了保证初始化过程的顺序，编译器会为每个构造器生成一个\u0026lt;init\u0026gt;方法，包含以下代码：\n对另一个构造函数的调用（为了直接或间接调用父类构造器） 初始化器（包括变量初始器器和块初始化器，为了保证初始化器仅运行一次，如果第1步调用是本地另一个构造函数,那么便不需要 初始化器的代码） 构造函数正文 在Kotlin中，初始化块使用init关键字声明：\ninit { print(\u0026#34;This is a intializer block.\u0026#34;) } 如果一个Kotlin类未继承其它另外定义的类，那么它默认继承类Any, 如下所示：\n未定义主构造器\n未定义次要构造器：编译器会为其生成一个无参主构造器 定义了次要构造器：那么它将仅有次要构造器，不会自动生成无参构造器 class Car { // ... constructor(type: String, name: String) { // ... } } 定义了主构造器，并且定义了次要构造器\nclass Car(type: String, name: String) { // .","keywords":[],"articleBody":"类定义 类声明由类名、类首部（指定类型参数，主构造器等）、类正文（用花括号包围）。类首部和正文都是可选的。因此最简单的类定义为：\nclass Empty // Implicitly inherits from Any 类似所有Java类都继承类Object，所有Kotlin类都继承类Any，但Any不是与特定平台（例如JVM）相关的，它不是一个java.lang.Object，这表明当Kotlin与Java代码进行互操作时，为了使用Object的成员方法，Kotlin提供了扩展函数。\n例如为了调用Object的wait()/notify()方法，可以将一个kotlin对象foo转型为Object：\n(foo as java.lang.Object).wait() 为了获取一个kotlin对象的Java类，Kotlin1.1之后可以使用class引用的java扩展属性，也可以直接使用扩展属性javaClass:\nval fooClass = foo::class.java // class reference val fooClass = foo.javaClass // extension property: javaClass 与Java代码进行互操作，Kotlin在语言层面上是这样设计的，但在编译为Java字节码以及JVM运行时中，每个类总是默认继承了Object。\n构造器 Kotlin的构造器分为主构造器（primary constructor）和次要构造器（secondary constructors）。两者都是可选的，即可以不用明确定义任何构造器，这时如果该类不是抽象类，就采用默认生成的无参主构造器。主构造器只能有一个，次要构造器可以有多个，次要构造器必须代理到主构造器，可以是直接的代理或使用其它次要构造器间接代理。造器的可见性默认是public的。\n这里讨论下主构造器，先了解下Java对象的初始化，大致说了Java对象初始化机制有三种：实例初始化器（初始化块）、实例变量初始化器、构造器。初始化块和实例变量初始化器可以认为是实例初始化器的两种不同形式，实例变量初始化器只不过定义了实例变量并使用表达式而非块进行了初始化。在对象初始化时，由于存在继承层次结构，每一层级类都需要进行初始化，一个对象从自身开始向上到父类，到父类的父类等等，直到Object类，完成整个类层次的初始化。所以该对象的构造器必须直接或间接地调用父类构造器，这也说明了为什么构造器不属于Java类成员，它不会被子类继承，不然会造成初始化的死循环。构造器是初始化的入口，但不是初始化的全部，并且为了保证初始化过程的顺序，编译器会为每个构造器生成一个方法，包含以下代码：\n对另一个构造函数的调用（为了直接或间接调用父类构造器） 初始化器（包括变量初始器器和块初始化器，为了保证初始化器仅运行一次，如果第1步调用是本地另一个构造函数,那么便不需要 初始化器的代码） 构造函数正文 在Kotlin中，初始化块使用init关键字声明：\ninit { print(\"This is a intializer block.\") } 如果一个Kotlin类未继承其它另外定义的类，那么它默认继承类Any, 如下所示：\n未定义主构造器\n未定义次要构造器：编译器会为其生成一个无参主构造器 定义了次要构造器：那么它将仅有次要构造器，不会自动生成无参构造器 class Car { // ... constructor(type: String, name: String) { // ... } } 定义了主构造器，并且定义了次要构造器\nclass Car(type: String, name: String) { // ... constructor(brand: String, type: String, name: String) : this(type, name) { // ... } } 如果一个Kotlin类继承了一个另外定义的类，假设\n未定义主构造器 open class View { constructor(ctx: Context) { // ... } constructor(ctx: Context, attrs: AttributeSet) { // ... } } class CustomView : View { constructor(ctx: Context) : super(ctx) { // ... } constructor(ctx: Context, attrs: AttributeSet) : super(ctx, attrs) { // ... } // ... } 定义了主构造器：\b父类可以（并且必须）使用主构造器的参数在继承时进行初始化 open class Vehicle(type: String) { // ... } class Car(type: String = \"Car\", name: String) : Vehicle(type) { // ... } Kotlin中可以使用一个简洁的语法来从主构造函数中定义属性并进行初始化：\nclass Person(val firstName: String, val lastName: String, var age: Int) { // ... } 嵌套与内部类（Nested and Inner Classes） 类可以嵌套在其它类中：\nclass Outer { private val bar: Int = 1 class Nested { fun foo() = 2 } } val demo = Outer.Nested().foo() // == 2 和Java作点对比，Java中有嵌套类，并且分为静态和非静态的，静态的嵌套类实际上是一个顶级类，只不过为了包管理方便，将其嵌套在另一个包围类中，和静态方法一样，它不能直接访问类对象成员，而非静态的嵌套类可以，因为它持有外部类对象的引用，它有另一个专门的名称就是内部类。那么Kotlin中嵌套类默认是不能访问外部类的成员，它不属于内部类。内部类使用inner声明，此时内部类便持有了一个对外部类对象的引用：\nclass Outer { private val bar: Int = 1 inner class Inner { fun foo() = bar } } val demo = Outer().Inner().foo() // == 1 匿名内部类 匿名内部类使用对象表达式声明，如果对象仅仅是一个Java中的功能接口（即仅有一个抽象方法的接口），那么可以使用一个lambda表达式来创建：\nval listener = ActionListener { println(\"clicked\") } 抽象类 open class Base { open fun f() {} } abstract class Derived : Base() { override abstract fun f() } 接口 与Java8类似，Kotlin接口中的方法可以包含抽象方法，以及方法实现。与抽象类不同的是它们不能保存状态，即没有实例变量或者静态变量。它们可以有属性，但属性需要是抽象的或者提供访问器实现。\n使用interface关键词定义接口：\ninterface MyInterface { fun bar() fun foo() { // optional body } } 一个类可以实现一个或多个接口：\nclass Child : MyInterface { override fun bar() { // body } } 接口中的属性 接口中声明的属性是抽象的，或者提供了自定义访问器实现，其中接口中的属性没有支撑域（backing field）。\ninterface MyInterface { val prop: Int // abstract val propertyWithImplementation: String get() = \"foo\" fun foo() { print(prop) } } class Child : MyInterface { override val prop: Int = 29 } 接口继承冲突 如果一个类有多个超类，那么可能会继承同一个方法的多个实现，例如：\ninterface A { fun foo() { print(\"A\") } fun bar() } interface B { fun foo() { print(\"B\") } fun bar() { print(\"bar\") } } class C : A { override fun bar() { print(\"bar\") } } class D : A, B { override fun foo() { super\u003cA\u003e.foo() super\u003cB\u003e.foo() } override fun bar() { super\u003cB\u003e.bar() } } 接口A和B都声明了函数foo()和bar()，两者都实现了foo()，但只有B实现了bar()，如果定义一个子类C继承A，那么显然我们需要为bar()提供一个实现。\n然而，如果定义一个类D实现A和B两个接口，我们需要实现继承的多个方法，并且明确应该如何实现。这一规则对只有一个实现的方法(bar())和有多个实现的方法(foo())都适用。\n类方法 方法重写（Overriding Methods） 和类一样，Kotlin类中的方法默认是final的，即\b子类不可以重写，父类方法需要使用open声明，然后子类明确使用override声明才可以。子类override方法默认是可以重写的，如果要禁止重写，可以再加上final。\nopen class Base { open fun v() {} fun nv() {} } class Derived() : Base() { \bfinal override fun v() {} } 属性覆盖（Overriding Properties） 可见性修饰符 类、对象、接口、构造器、函数、属性和其setter可以有访问修饰符，getter的可见性总是和其属性一样。Kotlin中有四种可见性修饰符：private, protected, internal 和 public. 如果没有声明，默认是public的。\nprivate, protected, public和Java基本一致，没有包可见性的概念，internal表示模块内可见，即编译为同一模块或同一应用中的代码。\n类扩展 扩展函数 扩展属性 参考：\n类 接口 ","wordCount":"434","inLanguage":"en","datePublished":"2017-10-29T15:27:43+08:00","dateModified":"2017-10-29T15:27:43+08:00","author":{"@type":"Person","name":"LEOY"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://epicmars.github.io/blog/kotlin/2017-10-29-kotlin-class-inheritance/"},"publisher":{"@type":"Organization","name":"AndroidPi","logo":{"@type":"ImageObject","url":"https://acd-assets.alicdn.com/acd_work/tongyi/assets/logo.svg"}}}</script></head><body id=top><script>const hasHeaderBg=!1</script><header class=header><div class=nav-container><nav class=nav><div class=logo><a href=/ accesskey=h title="AndroidPi (Alt + H)"><svg width="25" height="24" viewBox="0 0 25 24" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><linearGradient x1="76.7202373%" y1="41.6070847%" x2="18.306123%" y2="65.5065085%" id="linearGradient-9_1k7ha4jv-1"><stop stop-color="#797beb" offset="0"/><stop stop-color="#373080" offset="100%"/></linearGradient></defs><g id="Symbols" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="_编组-7" fill="url(#linearGradient-9_1k7ha4jv-1)"><path d="M12.2746711.0C12.5125388.0 12.7434104.12583746 12.8693403.33556656l1.3852293 2.3769298h6.1425827C20.63502 2.71249636 20.8658915 2.83833382 20.9918215 3.04806292l1.7420308 2.97815322C22.8597822 6.23594524 22.8597822 6.5016021 22.7338523 6.7113312L22.6988718 6.76725896C22.6708873 6.80920478 22.6359068 6.8511506 22.5939301 6.88610545L21.2156969 9.24905331l3.050303 5.24322749L24.3429571 14.6041363C24.4339065 14.8138654 24.4548948 15.0795223 24.3919298 15.2682785l-1.6021086 2.7404602C22.6638912 18.2184678 22.4400158 18.3443053 22.195152 18.3443053L19.4176972 18.3582872 16.353402 23.6504515C16.227472 23.8601806 16.0035966 23.9860181 15.7587328 23.9860181L12.2886633 24H12.2396906C12.0158151 23.9860181 11.7989358 23.8601806 11.6869981 23.6644334l-1.490171-2.551704H4.13120166C4.0822289 21.1267113 4.04025225 21.1267113 3.9912795 21.1267113 3.75341183 21.1267113 3.52254028 21.0008739 3.39661034 20.7911448L1.79450165 18.0506845C1.66857171 17.8479464 1.66857171 17.5892805 1.79450165 17.3725604l1.37823324-2.3909117L.0944474553 9.69647539c-.1259299404-.20273813-.1259299404-.46140402.0-.678124089999999L1.80849387 6.02621614c.11193772-.2097291.34280928-.33556656.59466916-.33556656C2.466128 5.67666764 2.51510075 5.69064958 2.56407351 5.70463152H5.40449327L8.44080406.46140402C8.45479628.4194582 8.46179238.38450335 8.48278071.35653947L8.49677292.33556656C8.62270286.12583746 8.84657831.0 9.09144209.0H12.2816672 12.2746711zM9.04246933.72706088 5.74730256 6.41071949H2.3751786L8.93752771 17.6871541H5.59338819l-1.61610091 2.789397H10.5606247l1.6790659 2.8942616 6.5623491-11.3043985 1.6790659 2.8802797L23.7203035 14.9327119 20.4181406 9.24905331l1.6650737-2.8662977L9.00049268 6.39673755 10.6795586 3.51645791 9.04946544.72706088H9.04246933zM16.1435187 9.82930382 12.2187023 16.5755899 8.2938858 9.82930382h7.8496329z" id="_形状"/></g></g></svg></a><div class=logo-switches></div></div><ul id=menu><li><a href=/resources title=Resources><span>Resources</span></a></li><li><a href=/blog/ title=Blog><span>Blog</span></a></li><li><a href=/publication title=Publication><span>Publication</span></a></li><li><a href=/about title=About><span>About</span></a></li></ul></nav></div></header><div class=hero-container><div class=hero><h1 class=post-title>Kotlin类与继承</h1><div class=post-meta><span title='2017-10-29 15:27:43 +0800 CST'>October 29, 2017</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;434 words&nbsp;·&nbsp;LEOY</div></div></div><main class=main><article class=post-single><div class=post-content><h2 id=类定义>类定义<a hidden class=anchor aria-hidden=true href=#类定义>#</a></h2><p>类声明由类名、类首部（指定类型参数，主构造器等）、类正文（用花括号包围）。类首部和正文都是可选的。因此最简单的类定义为：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>    <span class=k>class</span> <span class=nc>Empty</span> <span class=c1>// Implicitly inherits from Any
</span></span></span></code></pre></div><p>类似所有Java类都继承类Object，所有Kotlin类都继承类Any，但Any不是与特定平台（例如JVM）相关的，它不是一个java.lang.Object，这表明当Kotlin与Java代码进行互操作时，为了使用Object的成员方法，Kotlin提供了<a href=https://kotlinlang.org/docs/reference/extensions.html>扩展函数</a>。</p><p>例如为了调用Object的wait()/notify()方法，可以将一个kotlin对象foo转型为Object：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>    <span class=p>(</span><span class=n>foo</span> <span class=k>as</span> <span class=n>java</span><span class=p>.</span><span class=n>lang</span><span class=p>.</span><span class=n>Object</span><span class=p>).</span><span class=n>wait</span><span class=p>()</span>
</span></span></code></pre></div><p>为了获取一个kotlin对象的Java类，Kotlin1.1之后可以使用class引用的java扩展属性，也可以直接使用扩展属性javaClass:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>    <span class=k>val</span> <span class=py>fooClass</span> <span class=p>=</span> <span class=n>foo</span><span class=o>::</span><span class=k>class</span><span class=p>.</span><span class=n>java</span>    <span class=c1>// class reference
</span></span></span><span class=line><span class=cl><span class=c1></span>    
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>fooClass</span> <span class=p>=</span> <span class=n>foo</span><span class=p>.</span><span class=n>javaClass</span>      <span class=c1>// extension property: javaClass
</span></span></span></code></pre></div><p>与<a href=https://kotlinlang.org/docs/reference/java-interop.html>Java代码进行互操作</a>，Kotlin在语言层面上是这样设计的，但在编译为Java字节码以及JVM运行时中，每个类总是默认继承了Object。</p><h2 id=构造器>构造器<a hidden class=anchor aria-hidden=true href=#构造器>#</a></h2><p>Kotlin的构造器分为主构造器（primary constructor）和次要构造器（secondary constructors）。两者都是可选的，即可以不用明确定义任何构造器，<strong>这时如果该类不是抽象类</strong>，就采用默认生成的无参主构造器。主构造器只能有一个，次要构造器可以有多个，次要构造器必须代理到主构造器，可以是直接的代理或使用其它次要构造器间接代理。造器的可见性默认是public的。</p><p>这里讨论下主构造器，先了解下<a href=https://www.javaworld.com/article/2076614/core-java/object-initialization-in-java.html>Java对象的初始化</a>，大致说了Java对象初始化机制有三种：实例初始化器（初始化块）、实例变量初始化器、构造器。初始化块和实例变量初始化器可以认为是实例初始化器的两种不同形式，实例变量初始化器只不过定义了实例变量并使用表达式而非块进行了初始化。在对象初始化时，由于存在继承层次结构，每一层级类都需要进行初始化，一个对象从自身开始向上到父类，到父类的父类等等，直到Object类，完成整个类层次的初始化。所以该对象的构造器必须直接或间接地调用父类构造器，这也说明了为什么构造器不属于Java类成员，它不会被子类继承，不然会造成初始化的死循环。构造器是初始化的入口，但不是初始化的全部，并且为了保证初始化过程的顺序，编译器会为每个构造器生成一个<code>&lt;init></code>方法，包含以下代码：</p><blockquote><ol><li>对另一个构造函数的调用（为了直接或间接调用父类构造器）</li><li>初始化器（包括变量初始器器和块初始化器，为了保证初始化器仅运行一次，如果第1步调用是本地另一个构造函数,那么便不需要
初始化器的代码）</li><li>构造函数正文</li></ol></blockquote><p>在Kotlin中，初始化块使用<code>init</code>关键字声明：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>    <span class=k>init</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>print</span><span class=p>(</span><span class=s2>&#34;This is a intializer block.&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span></code></pre></div><p>如果一个Kotlin类未继承其它另外定义的类，那么它默认继承类Any, 如下所示：</p><ol><li><p>未定义主构造器</p><ul><li>未定义次要构造器：编译器会为其生成一个无参主构造器</li><li>定义了次要构造器：那么它将仅有次要构造器，不会自动生成无参构造器</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>            <span class=k>class</span> <span class=nc>Car</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>constructor</span><span class=p>(</span><span class=n>type</span><span class=p>:</span> <span class=n>String</span><span class=p>,</span> <span class=n>name</span><span class=p>:</span> <span class=n>String</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span></code></pre></div></li><li><p>定义了主构造器，并且定义了次要构造器</p></li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>        <span class=k>class</span> <span class=nc>Car</span><span class=p>(</span><span class=n>type</span><span class=p>:</span> <span class=n>String</span><span class=p>,</span> <span class=n>name</span><span class=p>:</span> <span class=n>String</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>constructor</span><span class=p>(</span><span class=n>brand</span><span class=p>:</span> <span class=n>String</span><span class=p>,</span> <span class=n>type</span><span class=p>:</span> <span class=n>String</span><span class=p>,</span> <span class=n>name</span><span class=p>:</span> <span class=n>String</span><span class=p>)</span> <span class=p>:</span> <span class=k>this</span><span class=p>(</span><span class=n>type</span><span class=p>,</span> <span class=n>name</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span></code></pre></div><p>如果一个Kotlin类继承了一个另外定义的类，假设</p><ol><li>未定义主构造器</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>        <span class=k>open</span> <span class=k>class</span> <span class=nc>View</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>constructor</span><span class=p>(</span><span class=n>ctx</span><span class=p>:</span> <span class=n>Context</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>constructor</span><span class=p>(</span><span class=n>ctx</span><span class=p>:</span> <span class=n>Context</span><span class=p>,</span> <span class=n>attrs</span><span class=p>:</span> <span class=n>AttributeSet</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>class</span> <span class=nc>CustomView</span> <span class=p>:</span> <span class=n>View</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>constructor</span><span class=p>(</span><span class=n>ctx</span><span class=p>:</span> <span class=n>Context</span><span class=p>)</span> <span class=p>:</span> <span class=k>super</span><span class=p>(</span><span class=n>ctx</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>constructor</span><span class=p>(</span><span class=n>ctx</span><span class=p>:</span> <span class=n>Context</span><span class=p>,</span> <span class=n>attrs</span><span class=p>:</span> <span class=n>AttributeSet</span><span class=p>)</span> <span class=p>:</span> <span class=k>super</span><span class=p>(</span><span class=n>ctx</span><span class=p>,</span> <span class=n>attrs</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span></code></pre></div><ol start=2><li>定义了主构造器：父类可以（并且必须）使用主构造器的参数在继承时进行初始化</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>        <span class=k>open</span> <span class=k>class</span> <span class=nc>Vehicle</span><span class=p>(</span><span class=n>type</span><span class=p>:</span> <span class=n>String</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>class</span> <span class=nc>Car</span><span class=p>(</span><span class=n>type</span><span class=p>:</span> <span class=n>String</span> <span class=p>=</span> <span class=s2>&#34;Car&#34;</span><span class=p>,</span> <span class=n>name</span><span class=p>:</span> <span class=n>String</span><span class=p>)</span> <span class=p>:</span> <span class=n>Vehicle</span><span class=p>(</span><span class=n>type</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span></code></pre></div><p>Kotlin中可以使用一个简洁的语法来从主构造函数中定义属性并进行初始化：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>    <span class=k>class</span> <span class=nc>Person</span><span class=p>(</span><span class=k>val</span> <span class=py>firstName</span><span class=p>:</span> <span class=n>String</span><span class=p>,</span> <span class=k>val</span> <span class=py>lastName</span><span class=p>:</span> <span class=n>String</span><span class=p>,</span> <span class=k>var</span> <span class=py>age</span><span class=p>:</span> <span class=n>Int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span></code></pre></div><h2 id=嵌套与内部类nested-and-inner-classes>嵌套与内部类（Nested and Inner Classes）<a hidden class=anchor aria-hidden=true href=#嵌套与内部类nested-and-inner-classes>#</a></h2><p>类可以嵌套在其它类中：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>    <span class=k>class</span> <span class=nc>Outer</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>private</span> <span class=k>val</span> <span class=py>bar</span><span class=p>:</span> <span class=n>Int</span> <span class=p>=</span> <span class=m>1</span>
</span></span><span class=line><span class=cl>        <span class=k>class</span> <span class=nc>Nested</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>fun</span> <span class=nf>foo</span><span class=p>()</span> <span class=p>=</span> <span class=m>2</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>demo</span> <span class=p>=</span> <span class=nc>Outer</span><span class=p>.</span><span class=n>Nested</span><span class=p>().</span><span class=n>foo</span><span class=p>()</span> <span class=c1>// == 2
</span></span></span></code></pre></div><p>和Java作点对比，Java中有嵌套类，并且分为静态和非静态的，静态的嵌套类实际上是一个顶级类，只不过为了包管理方便，将其嵌套在另一个包围类中，和静态方法一样，它不能直接访问类对象成员，而非静态的嵌套类可以，因为它持有外部类对象的引用，它有另一个专门的名称就是内部类。那么Kotlin中嵌套类默认是不能访问外部类的成员，它不属于内部类。内部类使用inner声明，此时内部类便持有了一个对外部类对象的引用：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>    <span class=k>class</span> <span class=nc>Outer</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>private</span> <span class=k>val</span> <span class=py>bar</span><span class=p>:</span> <span class=n>Int</span> <span class=p>=</span> <span class=m>1</span>
</span></span><span class=line><span class=cl>        <span class=k>inner</span> <span class=k>class</span> <span class=nc>Inner</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>fun</span> <span class=nf>foo</span><span class=p>()</span> <span class=p>=</span> <span class=n>bar</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>demo</span> <span class=p>=</span> <span class=n>Outer</span><span class=p>().</span><span class=n>Inner</span><span class=p>().</span><span class=n>foo</span><span class=p>()</span> <span class=c1>// == 1
</span></span></span></code></pre></div><h3 id=匿名内部类>匿名内部类<a hidden class=anchor aria-hidden=true href=#匿名内部类>#</a></h3><p>匿名内部类使用对象表达式声明，如果对象仅仅是一个Java中的功能接口（即仅有一个抽象方法的接口），那么可以使用一个lambda表达式来创建：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>    <span class=k>val</span> <span class=py>listener</span> <span class=p>=</span> <span class=n>ActionListener</span> <span class=p>{</span> <span class=n>println</span><span class=p>(</span><span class=s2>&#34;clicked&#34;</span><span class=p>)</span> <span class=p>}</span>
</span></span></code></pre></div><h2 id=抽象类>抽象类<a hidden class=anchor aria-hidden=true href=#抽象类>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>    <span class=k>open</span> <span class=k>class</span> <span class=nc>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>open</span> <span class=k>fun</span> <span class=nf>f</span><span class=p>()</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>abstract</span> <span class=k>class</span> <span class=nc>Derived</span> <span class=p>:</span> <span class=n>Base</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>override</span> <span class=k>abstract</span> <span class=k>fun</span> <span class=nf>f</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span></code></pre></div><h2 id=接口>接口<a hidden class=anchor aria-hidden=true href=#接口>#</a></h2><p>与Java8类似，Kotlin接口中的方法可以包含抽象方法，以及方法实现。与抽象类不同的是它们不能保存状态，即没有实例变量或者静态变量。它们可以有属性，但属性需要是抽象的或者提供访问器实现。</p><p>使用<code>interface</code>关键词定义接口：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>    <span class=k>interface</span> <span class=nc>MyInterface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>fun</span> <span class=nf>bar</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=k>fun</span> <span class=nf>foo</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// optional body
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span></code></pre></div><p>一个类可以实现一个或多个接口：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>    <span class=k>class</span> <span class=nc>Child</span> <span class=p>:</span> <span class=n>MyInterface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>override</span> <span class=k>fun</span> <span class=nf>bar</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// body
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span></code></pre></div><h3 id=接口中的属性>接口中的属性<a hidden class=anchor aria-hidden=true href=#接口中的属性>#</a></h3><p>接口中声明的属性是抽象的，或者提供了自定义访问器实现，其中接口中的属性没有支撑域（backing field）。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>    <span class=k>interface</span> <span class=nc>MyInterface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>val</span> <span class=py>prop</span><span class=p>:</span> <span class=n>Int</span> <span class=c1>// abstract
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>        <span class=k>val</span> <span class=py>propertyWithImplementation</span><span class=p>:</span> <span class=n>String</span>
</span></span><span class=line><span class=cl>            <span class=k>get</span><span class=p>()</span> <span class=p>=</span> <span class=s2>&#34;foo&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>fun</span> <span class=nf>foo</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>print</span><span class=p>(</span><span class=n>prop</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>class</span> <span class=nc>Child</span> <span class=p>:</span> <span class=n>MyInterface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>override</span> <span class=k>val</span> <span class=py>prop</span><span class=p>:</span> <span class=n>Int</span> <span class=p>=</span> <span class=m>29</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span></code></pre></div><h3 id=接口继承冲突>接口继承冲突<a hidden class=anchor aria-hidden=true href=#接口继承冲突>#</a></h3><p>如果一个类有多个超类，那么可能会继承同一个方法的多个实现，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>    <span class=k>interface</span> <span class=nc>A</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>fun</span> <span class=nf>foo</span><span class=p>()</span> <span class=p>{</span> <span class=n>print</span><span class=p>(</span><span class=s2>&#34;A&#34;</span><span class=p>)</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>fun</span> <span class=nf>bar</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>interface</span> <span class=nc>B</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>fun</span> <span class=nf>foo</span><span class=p>()</span> <span class=p>{</span> <span class=n>print</span><span class=p>(</span><span class=s2>&#34;B&#34;</span><span class=p>)</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>fun</span> <span class=nf>bar</span><span class=p>()</span> <span class=p>{</span> <span class=n>print</span><span class=p>(</span><span class=s2>&#34;bar&#34;</span><span class=p>)</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>class</span> <span class=nc>C</span> <span class=p>:</span> <span class=n>A</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>override</span> <span class=k>fun</span> <span class=nf>bar</span><span class=p>()</span> <span class=p>{</span> <span class=n>print</span><span class=p>(</span><span class=s2>&#34;bar&#34;</span><span class=p>)</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>class</span> <span class=nc>D</span> <span class=p>:</span> <span class=n>A</span><span class=p>,</span> <span class=n>B</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>override</span> <span class=k>fun</span> <span class=nf>foo</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>super</span><span class=p>&lt;</span><span class=n>A</span><span class=p>&gt;.</span><span class=n>foo</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=k>super</span><span class=p>&lt;</span><span class=n>B</span><span class=p>&gt;.</span><span class=n>foo</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>override</span> <span class=k>fun</span> <span class=nf>bar</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>super</span><span class=p>&lt;</span><span class=n>B</span><span class=p>&gt;.</span><span class=n>bar</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span></code></pre></div><p>接口A和B都声明了函数<code>foo()</code>和<code>bar()</code>，两者都实现了<code>foo()</code>，但只有B实现了<code>bar()</code>，如果定义一个子类C继承A，那么显然我们需要为<code>bar()</code>提供一个实现。</p><p>然而，如果定义一个类D实现A和B两个接口，我们需要实现继承的多个方法，并且明确应该如何实现。这一规则对只有一个实现的方法(<code>bar()</code>)和有多个实现的方法(<code>foo()</code>)都适用。</p><h2 id=类方法>类方法<a hidden class=anchor aria-hidden=true href=#类方法>#</a></h2><h3 id=方法重写overriding-methods>方法重写（Overriding Methods）<a hidden class=anchor aria-hidden=true href=#方法重写overriding-methods>#</a></h3><p>和类一样，Kotlin类中的方法默认是<code>final</code>的，即子类不可以重写，父类方法需要使用<code>open</code>声明，然后子类明确使用<code>override</code>声明才可以。子类<code>override</code>方法默认是可以重写的，如果要禁止重写，可以再加上<code>final</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>    <span class=k>open</span> <span class=k>class</span> <span class=nc>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>open</span> <span class=k>fun</span> <span class=nf>v</span><span class=p>()</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>        <span class=k>fun</span> <span class=nf>nv</span><span class=p>()</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>class</span> <span class=nc>Derived</span><span class=p>()</span> <span class=p>:</span> <span class=n>Base</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=err></span><span class=k>final</span> <span class=k>override</span> <span class=k>fun</span> <span class=nf>v</span><span class=p>()</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span></code></pre></div><h3 id=属性覆盖overriding-properties>属性覆盖（Overriding Properties）<a hidden class=anchor aria-hidden=true href=#属性覆盖overriding-properties>#</a></h3><h2 id=可见性修饰符>可见性修饰符<a hidden class=anchor aria-hidden=true href=#可见性修饰符>#</a></h2><p>类、对象、接口、构造器、函数、属性和其setter可以有访问修饰符，getter的可见性总是和其属性一样。Kotlin中有四种可见性修饰符：private, protected, internal 和 public. 如果没有声明，默认是public的。</p><p>private, protected, public和Java基本一致，没有包可见性的概念，internal表示模块内可见，即编译为同一模块或同一应用中的代码。</p><h2 id=类扩展>类扩展<a hidden class=anchor aria-hidden=true href=#类扩展>#</a></h2><h3 id=扩展函数>扩展函数<a hidden class=anchor aria-hidden=true href=#扩展函数>#</a></h3><h3 id=扩展属性>扩展属性<a hidden class=anchor aria-hidden=true href=#扩展属性>#</a></h3><p>参考：</p><ul><li><a href=https://kotlinlang.org/docs/reference/classes.html>类</a></li><li><a href=https://kotlinlang.org/docs/reference/interfaces.html>接口</a></li></ul></div></article></main><footer class=footer><span>&copy; 2024 <a href=https://epicmars.github.io/>AndroidPi</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 8" fill="currentcolor"><path d="M12 8H0l6-8z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>