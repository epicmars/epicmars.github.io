<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Kotlin类属性与常量 | AndroidPi</title>
<meta name=keywords content><meta name=description content="参考：
对象表达式与声明 类属性 类属性是定义在类中的变量或不变量，分别使用var和val定义。这里把Kotlin中的不变量和常量作下区分，不变量只是在第一次初始化后便不可改变，其余特性和变量完全一样，但它不是常量，常量的说明在后面的小节给出。
Kotlin对类属性的完整声明是：
(var|val) <propertyName>[: <PropertyType>] [= <property_initializer>][<getter>][<setter>]方括号[]表示该部分是可选的，其中属性初始化器、getter、setter在任何情况下都是可选的，如果属性类型可以从属性初始化器或getter中推断出，那么它也是可选的。使用val所声明的不变量是没有setter的。
类属性可以不显式地初始化，但未显式初始化的属性必须在构造器中初始化：
var allByDefault: Int? // error: explicit initializer required, default getter and setter implied var initialized = 1 // has type Int, default getter and setter val simple: Int? // has type Int, default getter, must be initialized in constructor val inferredType = 1 // has type Int and a default getter 属性访问器 所谓访问，就是对属性的读与写，类会为每个属性提供默认的访问器。称读访问器为getter，写访问器为setter。对于属性变量两者都会提供，不变量只有getter，显然是由于它不可改变。访问器可以在声明属性时进行重写以替换默认访问器：
val isEmpty: Boolean private get() = this."><meta name=author content="LEOY"><link rel=canonical href=https://epicmars.github.io/blog/kotlin/2017-10-30-kotlin-properties/><link crossorigin=anonymous href=/assets/css/stylesheet.8c0deceb290760c5fd82c47a972a18d5ab7cd5d722684689069ae8f152e19b25.css integrity="sha256-jA3s6ykHYMX9gsR6lyoY1at81dciaEaJBpro8VLhmyU=" rel="preload stylesheet" as=style><link rel=icon href=https://acd-assets.alicdn.com/acd_work/tongyi/assets/logo.svg><link rel=icon type=image/png sizes=16x16 href=https://acd-assets.alicdn.com/acd_work/tongyi/assets/logo.svg><link rel=icon type=image/png sizes=32x32 href=https://acd-assets.alicdn.com/acd_work/tongyi/assets/logo.svg%22><link rel=apple-touch-icon href=https://acd-assets.alicdn.com/acd_work/tongyi/assets/logo.svg><link rel=mask-icon href=https://acd-assets.alicdn.com/acd_work/tongyi/assets/logo.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://epicmars.github.io/blog/kotlin/2017-10-30-kotlin-properties/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script defer crossorigin=anonymous src=/js/custom.f20a5212619392e989b6d24ad9ce42302014debfad4d3c8c01db030c36d03475.js integrity="sha256-8gpSEmGTkumJttJK2c5CMCAU3r+tTTyMAdsDDDbQNHU="></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-NMEMBZ8R90"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-NMEMBZ8R90")}</script><meta property="og:title" content="Kotlin类属性与常量"><meta property="og:description" content="参考：
对象表达式与声明 类属性 类属性是定义在类中的变量或不变量，分别使用var和val定义。这里把Kotlin中的不变量和常量作下区分，不变量只是在第一次初始化后便不可改变，其余特性和变量完全一样，但它不是常量，常量的说明在后面的小节给出。
Kotlin对类属性的完整声明是：
(var|val) <propertyName>[: <PropertyType>] [= <property_initializer>][<getter>][<setter>]方括号[]表示该部分是可选的，其中属性初始化器、getter、setter在任何情况下都是可选的，如果属性类型可以从属性初始化器或getter中推断出，那么它也是可选的。使用val所声明的不变量是没有setter的。
类属性可以不显式地初始化，但未显式初始化的属性必须在构造器中初始化：
var allByDefault: Int? // error: explicit initializer required, default getter and setter implied var initialized = 1 // has type Int, default getter and setter val simple: Int? // has type Int, default getter, must be initialized in constructor val inferredType = 1 // has type Int and a default getter 属性访问器 所谓访问，就是对属性的读与写，类会为每个属性提供默认的访问器。称读访问器为getter，写访问器为setter。对于属性变量两者都会提供，不变量只有getter，显然是由于它不可改变。访问器可以在声明属性时进行重写以替换默认访问器：
val isEmpty: Boolean private get() = this."><meta property="og:type" content="article"><meta property="og:url" content="https://epicmars.github.io/blog/kotlin/2017-10-30-kotlin-properties/"><meta property="og:image" content="https://epicmars.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="blog"><meta property="article:published_time" content="2017-10-30T03:37:02+08:00"><meta property="article:modified_time" content="2017-10-30T03:37:02+08:00"><meta property="og:site_name" content="androidpi"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://epicmars.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Kotlin类属性与常量"><meta name=twitter:description content="参考：
对象表达式与声明 类属性 类属性是定义在类中的变量或不变量，分别使用var和val定义。这里把Kotlin中的不变量和常量作下区分，不变量只是在第一次初始化后便不可改变，其余特性和变量完全一样，但它不是常量，常量的说明在后面的小节给出。
Kotlin对类属性的完整声明是：
(var|val) <propertyName>[: <PropertyType>] [= <property_initializer>][<getter>][<setter>]方括号[]表示该部分是可选的，其中属性初始化器、getter、setter在任何情况下都是可选的，如果属性类型可以从属性初始化器或getter中推断出，那么它也是可选的。使用val所声明的不变量是没有setter的。
类属性可以不显式地初始化，但未显式初始化的属性必须在构造器中初始化：
var allByDefault: Int? // error: explicit initializer required, default getter and setter implied var initialized = 1 // has type Int, default getter and setter val simple: Int? // has type Int, default getter, must be initialized in constructor val inferredType = 1 // has type Int and a default getter 属性访问器 所谓访问，就是对属性的读与写，类会为每个属性提供默认的访问器。称读访问器为getter，写访问器为setter。对于属性变量两者都会提供，不变量只有getter，显然是由于它不可改变。访问器可以在声明属性时进行重写以替换默认访问器：
val isEmpty: Boolean private get() = this."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blogs","item":"https://epicmars.github.io/blog/"},{"@type":"ListItem","position":2,"name":"Kotlin","item":"https://epicmars.github.io/blog/kotlin/"},{"@type":"ListItem","position":3,"name":"Kotlin类属性与常量","item":"https://epicmars.github.io/blog/kotlin/2017-10-30-kotlin-properties/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Kotlin类属性与常量","name":"Kotlin类属性与常量","description":"参考：\n对象表达式与声明 类属性 类属性是定义在类中的变量或不变量，分别使用var和val定义。这里把Kotlin中的不变量和常量作下区分，不变量只是在第一次初始化后便不可改变，其余特性和变量完全一样，但它不是常量，常量的说明在后面的小节给出。\nKotlin对类属性的完整声明是：\n(var|val) \u0026lt;propertyName\u0026gt;[: \u0026lt;PropertyType\u0026gt;] [= \u0026lt;property_initializer\u0026gt;]\r[\u0026lt;getter\u0026gt;]\r[\u0026lt;setter\u0026gt;]\r方括号[]表示该部分是可选的，其中属性初始化器、getter、setter在任何情况下都是可选的，如果属性类型可以从属性初始化器或getter中推断出，那么它也是可选的。使用val所声明的不变量是没有setter的。\n类属性可以不显式地初始化，但未显式初始化的属性必须在构造器中初始化：\nvar allByDefault: Int? // error: explicit initializer required, default getter and setter implied var initialized = 1 // has type Int, default getter and setter val simple: Int? // has type Int, default getter, must be initialized in constructor val inferredType = 1 // has type Int and a default getter 属性访问器 所谓访问，就是对属性的读与写，类会为每个属性提供默认的访问器。称读访问器为getter，写访问器为setter。对于属性变量两者都会提供，不变量只有getter，显然是由于它不可改变。访问器可以在声明属性时进行重写以替换默认访问器：\nval isEmpty: Boolean private get() = this.","keywords":[],"articleBody":"参考：\n对象表达式与声明 类属性 类属性是定义在类中的变量或不变量，分别使用var和val定义。这里把Kotlin中的不变量和常量作下区分，不变量只是在第一次初始化后便不可改变，其余特性和变量完全一样，但它不是常量，常量的说明在后面的小节给出。\nKotlin对类属性的完整声明是：\n(var|val) [: ] [= ]\r[]\r[]\r方括号[]表示该部分是可选的，其中属性初始化器、getter、setter在任何情况下都是可选的，如果属性类型可以从属性初始化器或getter中推断出，那么它也是可选的。使用val所声明的不变量是没有setter的。\n类属性可以不显式地初始化，但未显式初始化的属性必须在构造器中初始化：\nvar allByDefault: Int? // error: explicit initializer required, default getter and setter implied var initialized = 1 // has type Int, default getter and setter val simple: Int? // has type Int, default getter, must be initialized in constructor val inferredType = 1 // has type Int and a default getter 属性访问器 所谓访问，就是对属性的读与写，类会为每个属性提供默认的访问器。称读访问器为getter，写访问器为setter。对于属性变量两者都会提供，不变量只有getter，显然是由于它不可改变。访问器可以在声明属性时进行重写以替换默认访问器：\nval isEmpty: Boolean private get() = this.size == 0 var stringRepresentation: String get() = this.toString() @Inject set(value) { setDataFromString(value) // parses the string and assigns values to other properties } Kotlin中访问器虽然有像get和set方法一样的形式，但它们并不是方法，不能显式地调用。如果存在默认的或重写了的访问器，所有对属性的读和写会都会直接调用访问器，包括在访问器的声明中进行的读写。例如，重写类A的两个变量的getter和setter，IDE会提示递归调用导致栈溢出。读x和调用调用x的getter是等价的，对y的写和调用y的setter是等价的。\nclass A { var x = 0 get() { return x //recursive getter call } var y = 0 set(value) { if (value \u003e 0) { y = value //recursive setter call } } } 支撑域（Backing Fields）与支撑属性（Backing Properties） 上面这个例子说明访问器有问题，用Java写POJO类时通常用IDE生成set和get方法就完事了，但有时候也会在这些方法中添加一些额外的逻辑对变量作进一步的操作。但上面的示例告诉我们，在Kotlin中这似乎做不到，因为我们拿不到真正的实例变量，只能通过访问器对变量进行操作，然而直接访问变量的需求还是在的，Kotlin也并不想让人抓狂，给出了两个解决方法，那便是支撑域和支撑属性。\nKotlin明确地告诉我们它是没有域（fields）的，Java中我们一直称对象的变量为域(field)，而Kotlin一直称之为属性（property），那么这两者有什么区别呢？\n在面向Google与面向爆栈编程实践中，我搜到了关于这个问题的一个问答和一份Java官方文档中对这些词汇的说明:\nfield\nA data member of a class. Unless specified otherwise, a field is not static.\ninstance variable\nAny item of data that is associated with a particular object. Each instance of a class has its own copy of the instance variables defined in the class. Also called a field. See also class variable.\nclass variable\nA data item associated with a particular class as a whole–not with particular instances of the class. Class variables are defined in class definitions. Also called a static field. See also instance variable.\nproperty\nCharacteristics of an object that users can set, such as the color of a window.\n也就是说除非特别声明，域指的是类的实例变量（非静态的类变量），属性的概念说的比较抽象，它是一个用户可以改变的对象特征。可以这样理解，由于域可以是私有的和公开的，而上面property词条表明属性是公开的，那么定义为private的域可以通过声明public的get或set方法使其成为对象的一个属性。那么简而言之可以认为属性本质上而言是可以从对象外部公开访问的域。这反应了Kotlin的一种设计意图，即一致性。和Java域相比Kotlin属性的语义约束性更强，Kotlin属性是对外公开的。Kotlin的属性提供了这样一种一致性，即对象的属性只能通过访问器访问。\n所以Kotlin声称它的类没有域，即不能直接访问对象的实例变量。对于public变量，编译器会自动生成访问器，任何对变量的读写，包括访问器自身内部都使用访问器来进行。\n那么类中的private变量算什么呢？根据上述属性的一般性概念，可以认为是的，private实例变量不属于属性，它仅是类内部的一种状态，如果该变量没有明确声明访问器，编译器也不会为其默认生成，此时对变量的访问是直接的，对Kotlin编译出的字节码文件的观察也证实了这一点。但如果为private变量明确声明访问器又会是什么情况？为了保持该变量是对象私有的这种一致性，不允许像Java一样声明public的getter和setter来绕开私有可见性的声明，但不妨碍通过声明其它public方法来访问该变量，而这与对象方法可以访问对象的所有成员是一致的。为了保证这种一致性，这种情况下对该实例变量的读写将分别通过对应的访问器进行访问。\n这种设计原由可以这样理解，在对象内部，对于提供了访问器的私有实例变量而言，访问器是对象中其它成员访问它的唯一途径，那么相对于其它成员而言，它自身是也一个对象，它的值就是它的属性（这里的意思和上面英文词条中的一样，即用户可以改变的对象的特征），这里用户成了对象内部的其它成员，这个可以改变的特征就是它的值，即它的值就是它的属性（Kotlin中的属性），而它的值就是它自身，所以它成了一个属性，这里要加上一个必要条件，即相对对象内部成员。\n那么现在可以将两种情况统一起来，可以认为属性就是指提供了访问器的实例变量。\n那么当真正需要使用域时该怎么办。Kotlin提供了一个自动支撑域，可以通过field标识符在访问器中使用。\nvar counter = 0 // the initializer value is written directly to the backing field set(value) { if (value \u003e= 0) field = value } 但支撑域只能在访问器中使用，如果想像Java那样自由地在任何地方访问原始实例变量又该怎么办，即不通过访问器读写实例变量？从上面的分析中可以看到，这样的变量不是属性，声明一个没有访问器的实例变量就可以了，通过将变量声明为private并且不重写其访问器就可以了，kotlin称其为支撑属性。如下所示：\nprivate var _table: Map\u003cString, Int\u003e? = null public val table: Map\u003cString, Int\u003e get() { if (_table == null) { _table = HashMap() // Type parameters are inferred } return _table ?: throw AssertionError(\"Set to null by another thread\") } 懒初始化 上面的类属性必须在声明时或者构造器中进行初始化，但这样有许多不便之处，例如使用依赖注入进行对象初始化或者单元测试中不能提供一个非空的初始化器，但你仍然想在引用属性时避免null检查。此时，可以使用lateinit关键词修饰属性：\npublic class MyTest { lateinit var subject: TestSubject @SetUp fun setup() { subject = TestSubject() } @Test fun test() { subject.method() // dereference directly } } 它只能用于属性变量，并且属性没有自定义访问器，属性的类型必须是不可为null的，并且不能是基础数据类型。\n编译时常量 使用const关键词修饰，并且满足以下条件的属于编译时常量：\n对象的顶级成员 使用String或基本类型进行初始化 没有自定义getter const val constant: String = \"Constant string.\" ","wordCount":"355","inLanguage":"en","image":"https://epicmars.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2017-10-30T03:37:02+08:00","dateModified":"2017-10-30T03:37:02+08:00","author":{"@type":"Person","name":"LEOY"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://epicmars.github.io/blog/kotlin/2017-10-30-kotlin-properties/"},"publisher":{"@type":"Organization","name":"AndroidPi","logo":{"@type":"ImageObject","url":"https://acd-assets.alicdn.com/acd_work/tongyi/assets/logo.svg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://epicmars.github.io/ accesskey=h title="AndroidPi (Alt + H)">AndroidPi</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://epicmars.github.io/zh/ title=简体中文 aria-label=简体中文>简体中文</a></li></ul></div></div><ul id=menu><li><a href=https://epicmars.github.io/resources title=Resources><span>Resources</span></a></li><li><a href=https://epicmars.github.io/blog/ title=Blog><span>Blog</span></a></li><li><a href=https://epicmars.github.io/publication title=Publication><span>Publication</span></a></li><li><a href=https://epicmars.github.io/about title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Kotlin类属性与常量</h1><div class=post-meta><span title='2017-10-30 03:37:02 +0800 CST'>October 30, 2017</span>&nbsp;·&nbsp;LEOY</div></header><div class=post-content><p>参考：</p><ul><li><a href=https://kotlinlang.org/docs/reference/object-declarations.html>对象表达式与声明</a></li></ul><h2 id=类属性>类属性<a hidden class=anchor aria-hidden=true href=#类属性>#</a></h2><p>类属性是定义在类中的变量或不变量，分别使用<code>var</code>和<code>val</code>定义。这里把Kotlin中的不变量和常量作下区分，不变量只是在第一次初始化后便不可改变，其余特性和变量完全一样，但它不是常量，常量的说明在后面的小节给出。</p><p>Kotlin对类属性的完整声明是：</p><pre><code>(var|val) &lt;propertyName&gt;[: &lt;PropertyType&gt;] [= &lt;property_initializer&gt;]
[&lt;getter&gt;]
[&lt;setter&gt;]
</code></pre><p>方括号<code>[]</code>表示该部分是可选的，其中属性初始化器、getter、setter在任何情况下都是可选的，如果属性类型可以从属性初始化器或getter中推断出，那么它也是可选的。使用val所声明的不变量是没有setter的。</p><p>类属性可以不显式地初始化，但未显式初始化的属性必须在构造器中初始化：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>    <span class=k>var</span> <span class=py>allByDefault</span><span class=p>:</span> <span class=n>Int</span><span class=p>?</span> <span class=c1>// error: explicit initializer required, default getter and setter implied
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>var</span> <span class=py>initialized</span> <span class=p>=</span> <span class=m>1</span>    <span class=c1>// has type Int, default getter and setter
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>simple</span><span class=p>:</span> <span class=n>Int</span><span class=p>?</span>     <span class=c1>// has type Int, default getter, must be initialized in constructor
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>val</span> <span class=py>inferredType</span> <span class=p>=</span> <span class=m>1</span> <span class=c1>// has type Int and a default getter
</span></span></span></code></pre></div><h3 id=属性访问器>属性访问器<a hidden class=anchor aria-hidden=true href=#属性访问器>#</a></h3><p>所谓访问，就是对属性的读与写，类会为每个属性提供默认的访问器。称读访问器为getter，写访问器为setter。对于属性变量两者都会提供，不变量只有getter，显然是由于它不可改变。访问器可以在声明属性时进行重写以替换默认访问器：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>    <span class=k>val</span> <span class=py>isEmpty</span><span class=p>:</span> <span class=n>Boolean</span>
</span></span><span class=line><span class=cl>        <span class=k>private</span> <span class=k>get</span><span class=p>()</span> <span class=p>=</span> <span class=k>this</span><span class=p>.</span><span class=n>size</span> <span class=o>==</span> <span class=m>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>var</span> <span class=py>stringRepresentation</span><span class=p>:</span> <span class=n>String</span>
</span></span><span class=line><span class=cl>        <span class=k>get</span><span class=p>()</span> <span class=p>=</span> <span class=k>this</span><span class=p>.</span><span class=n>toString</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=nd>@Inject</span>
</span></span><span class=line><span class=cl>        <span class=k>set</span><span class=p>(</span><span class=k>value</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>setDataFromString</span><span class=p>(</span><span class=k>value</span><span class=p>)</span> <span class=c1>// parses the string and assigns values to other properties
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span></code></pre></div><p>Kotlin中访问器虽然有像get和set方法一样的形式，但它们并不是方法，不能显式地调用。如果存在默认的或重写了的访问器，所有对属性的读和写会都会直接调用访问器，包括在访问器的声明中进行的读写。例如，重写类A的两个变量的getter和setter，IDE会提示递归调用导致栈溢出。读x和调用调用x的getter是等价的，对y的写和调用y的setter是等价的。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>    <span class=k>class</span> <span class=nc>A</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>var</span> <span class=py>x</span> <span class=p>=</span> <span class=m>0</span>
</span></span><span class=line><span class=cl>            <span class=k>get</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=n>x</span> <span class=c1>//recursive getter call
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>var</span> <span class=py>y</span> <span class=p>=</span> <span class=m>0</span>
</span></span><span class=line><span class=cl>            <span class=k>set</span><span class=p>(</span><span class=k>value</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=k>value</span> <span class=p>&gt;</span> <span class=m>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>y</span> <span class=p>=</span> <span class=k>value</span> <span class=c1>//recursive setter call
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span></code></pre></div><h3 id=支撑域backing-fields与支撑属性backing-properties>支撑域（Backing Fields）与支撑属性（Backing Properties）<a hidden class=anchor aria-hidden=true href=#支撑域backing-fields与支撑属性backing-properties>#</a></h3><p>上面这个例子说明访问器有问题，用Java写POJO类时通常用IDE生成set和get方法就完事了，但有时候也会在这些方法中添加一些额外的逻辑对变量作进一步的操作。但上面的示例告诉我们，在Kotlin中这似乎做不到，因为我们拿不到真正的实例变量，只能通过访问器对变量进行操作，然而直接访问变量的需求还是在的，Kotlin也并不想让人抓狂，给出了两个解决方法，那便是支撑域和支撑属性。</p><p>Kotlin明确地告诉我们它是没有域（fields）的，Java中我们一直称对象的变量为域(field)，而Kotlin一直称之为属性（property），那么这两者有什么区别呢？</p><p>在面向Google与面向爆栈编程实践中，我搜到了关于这个问题的一个<a href=https://stackoverflow.com/questions/10115588/what-is-the-difference-between-field-variable-attribute-and-property-in-java>问答</a>和一份<a href=https://docs.oracle.com/javase/tutorial/information/glossary.html>Java官方文档</a>中对这些词汇的说明:</p><blockquote><ul><li><p>field</p><p>A data member of a class. Unless specified otherwise, a field is not static.</p></li><li><p>instance variable</p><p>Any item of data that is associated with a particular object. Each instance of
a class has its own copy of the instance variables defined in the class.
Also called a field. See also class variable.</p></li><li><p>class variable</p><p>A data item associated with a particular class as a whole&ndash;not with particular
instances of the class. Class variables are defined in class definitions.
Also called a static field. See also instance variable.</p></li><li><p>property</p><p>Characteristics of an object that users can set, such as the color of a window.</p></li></ul></blockquote><p>也就是说除非特别声明，域指的是类的实例变量（非静态的类变量），属性的概念说的比较抽象，它是一个用户可以改变的对象特征。可以这样理解，由于域可以是私有的和公开的，而上面property词条表明属性是公开的，那么定义为private的域可以通过声明public的get或set方法使其成为对象的一个属性。那么简而言之可以认为<strong>属性本质上而言是可以从对象外部公开访问的域</strong>。这反应了Kotlin的一种设计意图，即一致性。和Java域相比Kotlin属性的语义约束性更强，Kotlin属性是对外公开的。Kotlin的属性提供了这样一种一致性，即对象的属性只能通过访问器访问。</p><p>所以Kotlin声称它的类没有域，即不能直接访问对象的实例变量。对于public变量，编译器会自动生成访问器，任何对变量的读写，包括访问器自身内部都使用访问器来进行。</p><p>那么类中的<code>private</code>变量算什么呢？根据上述属性的一般性概念，可以认为是的，<code>private</code>实例变量不属于属性，它仅是类内部的一种状态，如果该变量没有明确声明访问器，编译器也不会为其默认生成，此时对变量的访问是直接的，对Kotlin编译出的字节码文件的观察也证实了这一点。但如果为<code>private</code>变量明确声明访问器又会是什么情况？为了保持该变量是对象私有的这种一致性，不允许像Java一样声明<code>public</code>的getter和setter来绕开私有可见性的声明，但不妨碍通过声明其它public方法来访问该变量，而这与对象方法可以访问对象的所有成员是一致的。为了保证这种一致性，这种情况下对该实例变量的读写将分别通过对应的访问器进行访问。</p><p>这种设计原由可以这样理解，在对象内部，对于提供了访问器的私有实例变量而言，访问器是对象中其它成员访问它的唯一途径，那么相对于其它成员而言，它自身是也一个对象，它的值就是它的属性（这里的意思和上面英文词条中的一样，即用户可以改变的对象的特征），这里用户成了对象内部的其它成员，这个可以改变的特征就是它的值，即它的值就是它的属性（Kotlin中的属性），而它的值就是它自身，所以它成了一个属性，这里要加上一个必要条件，即相对对象内部成员。</p><p>那么现在可以将两种情况统一起来，可以认为<strong>属性就是指提供了访问器的实例变量</strong>。</p><p>那么当真正需要使用域时该怎么办。Kotlin提供了一个自动支撑域，可以通过<code>field</code>标识符在访问器中使用。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>    <span class=k>var</span> <span class=py>counter</span> <span class=p>=</span> <span class=m>0</span> <span class=c1>// the initializer value is written directly to the backing field
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>set</span><span class=p>(</span><span class=k>value</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=k>value</span> <span class=o>&gt;=</span> <span class=m>0</span><span class=p>)</span> <span class=k>field</span> <span class=p>=</span> <span class=k>value</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span></code></pre></div><p>但支撑域只能在访问器中使用，如果想像Java那样自由地在任何地方访问原始实例变量又该怎么办，即不通过访问器读写实例变量？从上面的分析中可以看到，这样的变量不是属性，声明一个没有访问器的实例变量就可以了，通过将变量声明为private并且不重写其访问器就可以了，kotlin称其为支撑属性。如下所示：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>    <span class=k>private</span> <span class=k>var</span> <span class=py>_table</span><span class=p>:</span> <span class=n>Map</span><span class=p>&lt;</span><span class=n>String</span><span class=p>,</span> <span class=n>Int</span><span class=p>&gt;?</span> <span class=p>=</span> <span class=k>null</span>
</span></span><span class=line><span class=cl>    <span class=k>public</span> <span class=k>val</span> <span class=py>table</span><span class=p>:</span> <span class=n>Map</span><span class=p>&lt;</span><span class=n>String</span><span class=p>,</span> <span class=n>Int</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>        <span class=k>get</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>_table</span> <span class=o>==</span> <span class=k>null</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>_table</span> <span class=p>=</span> <span class=n>HashMap</span><span class=p>()</span> <span class=c1>// Type parameters are inferred
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>_table</span> <span class=o>?:</span> <span class=k>throw</span> <span class=n>AssertionError</span><span class=p>(</span><span class=s2>&#34;Set to null by another thread&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span></code></pre></div><h3 id=懒初始化>懒初始化<a hidden class=anchor aria-hidden=true href=#懒初始化>#</a></h3><p>上面的类属性必须在声明时或者构造器中进行初始化，但这样有许多不便之处，例如使用依赖注入进行对象初始化或者单元测试中不能提供一个非空的初始化器，但你仍然想在引用属性时避免null检查。此时，可以使用<code>lateinit</code>关键词修饰属性：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>    <span class=k>public</span> <span class=k>class</span> <span class=nc>MyTest</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>lateinit</span> <span class=k>var</span> <span class=py>subject</span><span class=p>:</span> <span class=n>TestSubject</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=nd>@SetUp</span> <span class=k>fun</span> <span class=nf>setup</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>subject</span> <span class=p>=</span> <span class=n>TestSubject</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=nd>@Test</span> <span class=k>fun</span> <span class=nf>test</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>subject</span><span class=p>.</span><span class=n>method</span><span class=p>()</span>  <span class=c1>// dereference directly
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span></code></pre></div><p>它只能用于属性变量，并且属性没有自定义访问器，属性的类型必须是不可为null的，并且不能是基础数据类型。</p><h2 id=编译时常量>编译时常量<a hidden class=anchor aria-hidden=true href=#编译时常量>#</a></h2><p>使用const关键词修饰，并且满足以下条件的属于编译时常量：</p><ul><li>对象的顶级成员</li><li>使用String或基本类型进行初始化</li><li>没有自定义getter</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>    <span class=k>const</span> <span class=k>val</span> <span class=py>constant</span><span class=p>:</span> <span class=n>String</span> <span class=p>=</span> <span class=s2>&#34;Constant string.&#34;</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://epicmars.github.io/>AndroidPi</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>