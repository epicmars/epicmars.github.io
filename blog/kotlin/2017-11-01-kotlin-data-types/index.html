<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Kotlin数据类型 | AndroidPi</title>
<meta name=keywords content><meta name=description content="参考：
基本类型 相等性 空指针安全性 类型检查与转换 Java中有8种基本类型byte，short，int，long，float，double，boolean，char，还提供了支持字符串的java.lang.String类，最后提供了上述的数组类型。Kotlin中的数据类型与Java基本一致，不过可以将基本数据类型也看做对象。
数字 类型 |位宽度--------|---------Double	|64Float	|32Long |64Int |32Short	|16Byte	|8 注意，Kotlin中字符不是数字。
在Java平台中，数字的以JVM中的基本数据类型保存于物理存储，除非我们想要一个可以为空(nullable)的数字或者使用了泛型，那么这时数字会装箱（boxed）为对应的类型。
数字装箱后不保留同一性（identity），但保留相等性（equality），这与Java中是一样的，两个数字值相等的对象是不同的两个对象，但它们的值是相等的。
与Java中不同的是，同一性比较使用三个等号符号：===或者!==，相等性比较使用：==或者!=。
对于数字的隐式转换和自动拆装箱，对比Java中和Kotlin中有何区别：
Java中，表达式中的数字类型会自动拆箱为对应的基础类型，然后向上转型为表达式中较大的基础类型。自动装箱只能发生在对应的基础类型上。 Integer a = 11; Short b = 12; Long c = 13L; int i = 1; short j = 2; long k = 3; k = a; k = a + b; k = i + j; k += i; a = a + b; a = i + j; c += i; c = 14; // error, right expression is 'int' c = i + j; // error, right expression is 'int' c = a + b; // error, right expression is 'int' Kotlin中，与类型系统是相关的，因为所有数字类型都认为是对象，可以认为没有拆箱的说法，并且也没有隐式的类型提升，运算符事实上都是重载的操作符。 var a: Int?"><meta name=author content="LEOY"><link rel=canonical href=https://epicmars.github.io/blog/kotlin/2017-11-01-kotlin-data-types/><link crossorigin=anonymous href=/assets/css/stylesheet.8c0deceb290760c5fd82c47a972a18d5ab7cd5d722684689069ae8f152e19b25.css integrity="sha256-jA3s6ykHYMX9gsR6lyoY1at81dciaEaJBpro8VLhmyU=" rel="preload stylesheet" as=style><link rel=icon href=https://acd-assets.alicdn.com/acd_work/tongyi/assets/logo.svg><link rel=icon type=image/png sizes=16x16 href=https://acd-assets.alicdn.com/acd_work/tongyi/assets/logo.svg><link rel=icon type=image/png sizes=32x32 href=https://acd-assets.alicdn.com/acd_work/tongyi/assets/logo.svg%22><link rel=apple-touch-icon href=https://acd-assets.alicdn.com/acd_work/tongyi/assets/logo.svg><link rel=mask-icon href=https://acd-assets.alicdn.com/acd_work/tongyi/assets/logo.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://epicmars.github.io/blog/kotlin/2017-11-01-kotlin-data-types/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script defer crossorigin=anonymous src=/js/custom.f20a5212619392e989b6d24ad9ce42302014debfad4d3c8c01db030c36d03475.js integrity="sha256-8gpSEmGTkumJttJK2c5CMCAU3r+tTTyMAdsDDDbQNHU="></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-NMEMBZ8R90"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-NMEMBZ8R90")}</script><meta property="og:title" content="Kotlin数据类型"><meta property="og:description" content="参考：
基本类型 相等性 空指针安全性 类型检查与转换 Java中有8种基本类型byte，short，int，long，float，double，boolean，char，还提供了支持字符串的java.lang.String类，最后提供了上述的数组类型。Kotlin中的数据类型与Java基本一致，不过可以将基本数据类型也看做对象。
数字 类型 |位宽度--------|---------Double	|64Float	|32Long |64Int |32Short	|16Byte	|8 注意，Kotlin中字符不是数字。
在Java平台中，数字的以JVM中的基本数据类型保存于物理存储，除非我们想要一个可以为空(nullable)的数字或者使用了泛型，那么这时数字会装箱（boxed）为对应的类型。
数字装箱后不保留同一性（identity），但保留相等性（equality），这与Java中是一样的，两个数字值相等的对象是不同的两个对象，但它们的值是相等的。
与Java中不同的是，同一性比较使用三个等号符号：===或者!==，相等性比较使用：==或者!=。
对于数字的隐式转换和自动拆装箱，对比Java中和Kotlin中有何区别：
Java中，表达式中的数字类型会自动拆箱为对应的基础类型，然后向上转型为表达式中较大的基础类型。自动装箱只能发生在对应的基础类型上。 Integer a = 11; Short b = 12; Long c = 13L; int i = 1; short j = 2; long k = 3; k = a; k = a + b; k = i + j; k += i; a = a + b; a = i + j; c += i; c = 14; // error, right expression is 'int' c = i + j; // error, right expression is 'int' c = a + b; // error, right expression is 'int' Kotlin中，与类型系统是相关的，因为所有数字类型都认为是对象，可以认为没有拆箱的说法，并且也没有隐式的类型提升，运算符事实上都是重载的操作符。 var a: Int?"><meta property="og:type" content="article"><meta property="og:url" content="https://epicmars.github.io/blog/kotlin/2017-11-01-kotlin-data-types/"><meta property="og:image" content="https://epicmars.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="blog"><meta property="article:published_time" content="2017-11-01T17:09:39+08:00"><meta property="article:modified_time" content="2017-11-01T17:09:39+08:00"><meta property="og:site_name" content="androidpi"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://epicmars.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Kotlin数据类型"><meta name=twitter:description content="参考：
基本类型 相等性 空指针安全性 类型检查与转换 Java中有8种基本类型byte，short，int，long，float，double，boolean，char，还提供了支持字符串的java.lang.String类，最后提供了上述的数组类型。Kotlin中的数据类型与Java基本一致，不过可以将基本数据类型也看做对象。
数字 类型 |位宽度--------|---------Double	|64Float	|32Long |64Int |32Short	|16Byte	|8 注意，Kotlin中字符不是数字。
在Java平台中，数字的以JVM中的基本数据类型保存于物理存储，除非我们想要一个可以为空(nullable)的数字或者使用了泛型，那么这时数字会装箱（boxed）为对应的类型。
数字装箱后不保留同一性（identity），但保留相等性（equality），这与Java中是一样的，两个数字值相等的对象是不同的两个对象，但它们的值是相等的。
与Java中不同的是，同一性比较使用三个等号符号：===或者!==，相等性比较使用：==或者!=。
对于数字的隐式转换和自动拆装箱，对比Java中和Kotlin中有何区别：
Java中，表达式中的数字类型会自动拆箱为对应的基础类型，然后向上转型为表达式中较大的基础类型。自动装箱只能发生在对应的基础类型上。 Integer a = 11; Short b = 12; Long c = 13L; int i = 1; short j = 2; long k = 3; k = a; k = a + b; k = i + j; k += i; a = a + b; a = i + j; c += i; c = 14; // error, right expression is 'int' c = i + j; // error, right expression is 'int' c = a + b; // error, right expression is 'int' Kotlin中，与类型系统是相关的，因为所有数字类型都认为是对象，可以认为没有拆箱的说法，并且也没有隐式的类型提升，运算符事实上都是重载的操作符。 var a: Int?"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blogs","item":"https://epicmars.github.io/blog/"},{"@type":"ListItem","position":2,"name":"Kotlin","item":"https://epicmars.github.io/blog/kotlin/"},{"@type":"ListItem","position":3,"name":"Kotlin数据类型","item":"https://epicmars.github.io/blog/kotlin/2017-11-01-kotlin-data-types/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Kotlin数据类型","name":"Kotlin数据类型","description":"参考：\n基本类型 相等性 空指针安全性 类型检查与转换 Java中有8种基本类型byte，short，int，long，float，double，boolean，char，还提供了支持字符串的java.lang.String类，最后提供了上述的数组类型。Kotlin中的数据类型与Java基本一致，不过可以将基本数据类型也看做对象。\n数字 类型 |位宽度\r--------|---------\rDouble\t|64\rFloat\t|32\rLong |64\rInt |32\rShort\t|16\rByte\t|8 \b注意，Kotlin中字符不是数字。\n在Java平台中，数字的以JVM中的基本数据类型保存于物理存储，除非我们想要一个可以为空(nullable)的数字或者使用了泛型，那么这时数字会装箱（boxed）为对应的类型。\n数字装箱后不保留同一性（identity），但保留相等性（equality），这与Java中是一样的，两个数字值相等的对象是不同的两个对象，但它们的值是相等的。\n与Java中不同的是，同一性比较使用三个等号符号：===或者!==，相等性比较使用：==或者!=。\n对于数字的\b\b隐式转换和自动\b拆装箱，对比\bJava中和Kotlin中有何区别：\nJava中，表达式中的数字类型会自动拆箱为对应的基础类型，然后向上转型为表达式中较大的基础类型。自动装箱只能发生在对应的基础类型上。 Integer a = 11; Short b = 12; Long c = 13L; int i = 1; short j = 2; long k = 3; k = a; k = a + b; k = i + j; k += i; a = a + b; a = i + j; c += i; c = 14; // error, right expression is \u0026#39;int\u0026#39; c = i + j; // error, right expression is \u0026#39;int\u0026#39; c = a + b; // error, right expression is \u0026#39;int\u0026#39; Kotlin中，与类型系统是相关的，因为所有数字类型都认为是对象，可以认为没有拆箱的说法，并且也没有隐式的类型提升，运算符事实上都是重载的操作符。 var a: Int?","keywords":[],"articleBody":"参考：\n基本类型 相等性 空指针安全性 类型检查与转换 Java中有8种基本类型byte，short，int，long，float，double，boolean，char，还提供了支持字符串的java.lang.String类，最后提供了上述的数组类型。Kotlin中的数据类型与Java基本一致，不过可以将基本数据类型也看做对象。\n数字 类型 |位宽度\r--------|---------\rDouble\t|64\rFloat\t|32\rLong |64\rInt |32\rShort\t|16\rByte\t|8 \b注意，Kotlin中字符不是数字。\n在Java平台中，数字的以JVM中的基本数据类型保存于物理存储，除非我们想要一个可以为空(nullable)的数字或者使用了泛型，那么这时数字会装箱（boxed）为对应的类型。\n数字装箱后不保留同一性（identity），但保留相等性（equality），这与Java中是一样的，两个数字值相等的对象是不同的两个对象，但它们的值是相等的。\n与Java中不同的是，同一性比较使用三个等号符号：===或者!==，相等性比较使用：==或者!=。\n对于数字的\b\b隐式转换和自动\b拆装箱，对比\bJava中和Kotlin中有何区别：\nJava中，表达式中的数字类型会自动拆箱为对应的基础类型，然后向上转型为表达式中较大的基础类型。自动装箱只能发生在对应的基础类型上。 Integer a = 11; Short b = 12; Long c = 13L; int i = 1; short j = 2; long k = 3; k = a; k = a + b; k = i + j; k += i; a = a + b; a = i + j; c += i; c = 14; // error, right expression is 'int' c = i + j; // error, right expression is 'int' c = a + b; // error, right expression is 'int' Kotlin中，与类型系统是相关的，因为所有数字类型都认为是对象，可以认为没有拆箱的说法，并且也没有隐式的类型提升，运算符事实上都是重载的操作符。 var a: Int? = 11 var b: Short? = 12 var c: Long? = 13L var i: Int = 1 var j: Short = 2 var k: Long = 3 k = a // error, no unboxing and explicitly conversion k = a + b // error, no unboxing and explicitly conversion k = i + j // error, assignment has no explicitly conversion k += i // ok a = a + b // error, no unboxing and explicitly conversion a = i + j // ok c += i // error, not allow c = 14 // ok c = i + j // error, assignment has no explicitly conversion c = a + b // error, no unboxing and explicitly conversion 正确通过编译的版本：\nvar a: Int? = 11 var b: Short? = 12 var c: Long? = 13L var i: Int = 1 var j: Short = 2 var k: Long = 3 k = a!!.toLong() k = (i + j).toLong() k = (a!! + b!!).toLong() k += i a = a!! + b!! a = i + j c += i // error, not allow c = 14 c = (i + j).toLong() c = (a!! + b!!).toLong() 字符 字符使用Char表示，它们不能被当做数字使用。\n布尔值 布尔值使用Boolean表示。\n字符串 字符串使用String表示。字符串是不可变的的，字符串的元素是\b字符，可以使用序号操作符[]来访问。\n有两种类型字符字面值，一种是脱字符字符串（escaped string），可以包含脱字符。\b另一种是原始字符串（raw string），没有脱字符，可以包含换行符和其它任意字符。\n字符串模板 字符串可以\b包含模板表达式，也就是一段代码运行的结果转换为字符串并插入到字符串中。一个模板表达式以\b一个美元符号（$）开始，并且由一个简单名字或\b花括弧中任意表达式构成：\nval i = 10 val s = \"i = $i\" // evaluates to \"i = 10\" val s = \"abc\" val str = \"$s.length is ${s.length}\" // evaluates to \"abc.length is 3\" val price = \"\"\" ${'$'}9.99 \"\"\" 在原始字符串中，如果要表示美元符号字面值，可以使用单引号，如上所示。\n数组 数字由Array类表示，有get和set方法（通过操作符重载，使用方括号[]来调用)，还有size属性，以及一些有用的方法。\nclass Array\u003cT\u003e private constructor() { val size: Int operator fun get(index: Int): T operator fun set(index: Int, value: T): Unit operator fun iterator(): Iterator\u003cT\u003e // ... } 可以使用库函数来创建数组，有arrayOf()，arrayOfNulls()，以及使用工厂函数，如下所示，它接收一个数组大小，和返回每个序号对应值的方法：\n// Creates an Array with values [\"0\", \"1\", \"4\", \"9\", \"16\"] val asc = Array(5, { i -\u003e (i * i).toString() }) 和Java中不一样，Kotlin中的数组是不变量，这意味着，不能将Array赋值\b给一个Array，这样避免了一个可能的运行时错误，但可以使用Array，见类型投影。\nKotlin还有指定的类用于表示基本数据类型数组，\b可以免去数据装箱的开销，有ByteArray, ShortArray, IntArray等等，这些类与Array类没有继承关系。它们有自己的\b工厂函数：\nval x: IntArray = intArrayOf(1, 2, 3) x[0] = x[1] + x[2] 相等性 Kotlin中有两种形式的相等性：\n引用相等性（即同一性，两个引用指向同一个对象），使用===和!==操作符。 结构相等性（equals()检查），使用==和!=操作符。 通常结构相等性操作符a == b会被翻译为：\na?.equals(b) ?: (b === null) 即如果a不为null，它盗用equals(Any?)函数，否则，a为null，它检查b是否引用相等于null。\n注意没有必要直接与null进行同一性比较，a == null会自动转换为a === null。\n\b空引用安全性（Null safety） Kotlin的类型系统的目的之一是消灭空引用，即传说中的百万美元bug。\n仅有几种情况会引起空指针异常（NullPointerException）：\n代码中直接抛出异常throw NullPointerException() 使用操作符!! 外部Java代码导致的异常 初始化相关的数据不一致问题（一个构造器中未初始化的this使用在了其它地方） 在条件语句中检查null 第一，你可以显式地检查b是否为空，并且分别处理两种情况：\nval l = if (b != null) b.length else -1 注意只有当b不可变（检查和使用间没有被修改的局部变量或者一个有支撑域的不可重写的val成员），因为其它情况下b在使用前检查后可能值被修改了。\n安全调用 使用安全调用操作符（?.）：\nb?.length // 如果b为null则返回null，否则返回b.length // 链式调用，如果有一个为null，就返回null bob?.department?.head?.name // 只在非空的情况下执行某一操作 val listWithNulls: List\u003cString?\u003e = listOf(\"A\", null) for (item in listWithNulls) { item?.let { println(it) } // prints A and ignores null } Elvis操作符 当我们有一个可以为空的引用r，我们可以说“如果r不为null，那么就使用它，否则就使用某个非空的值x”：\nval l: Int = if (b != null) b.length else -1 使用Elvis操作符?:表示为:\nval l = b?.length ?: -1 由于throw和return也是表达式，它们也可以用于该操作符的右边，例如：\nfun foo(node: Node): String? { val parent = node.getParent() ?: return null val name = node.getName() ?: throw IllegalArgumentException(\"name expected\") // ... } !!操作符 对于NPE爱好者还有一个选择，可以使用b!!，如果b不为空那么返回它，否则抛出一个NPE：\nval l = b!!.length 安全转型 常规的类型转换可能导致ClassCastException，另一种选择是使用在尝试转型失败后返回null的安全转换：\nval aInt: Int? = a as? Int 可以为空类型的集合 如果一个集合的元素可以为空，并且你想过滤出非空的元素，可以使用filterNotNull函数：\nval nullableList: List\u003cInt?\u003e = listOf(1, 2, null, 4) val intList: List\u003cInt\u003e = nullableList.filterNotNull() 类型检查与转换：“is\"和\"as” is和!is操作符 使用is和!is操作符可以在运行时检查一个对象是否符合一个给定的类型：\nif (obj is String) { print(obj.length) } if (obj !is String) { // same as !(obj is String) print(\"Not a String\") } else { print(obj.length) } 智能转型 很多情形下，不用显式地进行类型转换，因为编译器会跟踪is检查，在需要的时候为不可变值进行显式地转型并自动插入（安全的）类型转换：\nfun demo(x: Any) { if (x is String) { print(x.length) // x is automatically cast to String } } 注意如果编译器不能保证检查和使用之间变量不能改变，那么智能转型就没法进行。更具体来说，智能转型在以下规则下是适用的：\nval局部变量——总是可行的。 val属性——如果属性是private的或者internal的或者检查在属性声明的同一模块下进行。对于open的属性或自定义了getter的属性不适用。 var局部变量——如果变量在检查和使用间没有被改变，并且没有在一个修改它的lambda中被捕获。 var属性——总是不可行的（因为变量可以在任何时间被其它代码修改）。 “不安全的（Unsafe）”转型操作符 通常，如果转型失败会抛出一个异常。因此，我们称之为_不安全的(unsafe)_。不安全的转型使用中缀操作符as来进行：\nval x: String = y as String 注意null不能被转型为String，因为String类型不是可为空的，也就是说，如果y是null，那么上面的代码会抛出一个异常。为了符合java的转型语义我们在转型操作符的右边有可以为空的类型，例如：\nval x: String? = y as String? “安全的（safe）“转型操作 为了避免抛出一个异常，可以使用_安全的（safe）_转型操作符as?，如果转型失败会返回null：\nval x: String? = y as? String 注意，尽管操作符as?的右边是一个不为null的类型String，转型的结果是可以为空的。\n","wordCount":"661","inLanguage":"en","image":"https://epicmars.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2017-11-01T17:09:39+08:00","dateModified":"2017-11-01T17:09:39+08:00","author":{"@type":"Person","name":"LEOY"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://epicmars.github.io/blog/kotlin/2017-11-01-kotlin-data-types/"},"publisher":{"@type":"Organization","name":"AndroidPi","logo":{"@type":"ImageObject","url":"https://acd-assets.alicdn.com/acd_work/tongyi/assets/logo.svg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://epicmars.github.io/ accesskey=h title="AndroidPi (Alt + H)">AndroidPi</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://epicmars.github.io/zh/ title=简体中文 aria-label=简体中文>简体中文</a></li></ul></div></div><ul id=menu><li><a href=https://epicmars.github.io/resources title=Resources><span>Resources</span></a></li><li><a href=https://epicmars.github.io/blog/ title=Blog><span>Blog</span></a></li><li><a href=https://epicmars.github.io/publication title=Publication><span>Publication</span></a></li><li><a href=https://epicmars.github.io/about title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Kotlin数据类型</h1><div class=post-meta><span title='2017-11-01 17:09:39 +0800 CST'>November 1, 2017</span>&nbsp;·&nbsp;LEOY</div></header><div class=post-content><p>参考：</p><ul><li><a href=https://kotlinlang.org/docs/reference/basic-types.html>基本类型</a></li><li><a href=https://kotlinlang.org/docs/reference/equality.html>相等性</a></li><li><a href=https://kotlinlang.org/docs/reference/null-safety.html>空指针安全性</a></li><li><a href=https://kotlinlang.org/docs/reference/typecasts.html>类型检查与转换</a></li></ul><p>Java中有8种基本类型byte，short，int，long，float，double，boolean，char，还提供了支持字符串的java.lang.String类，最后提供了上述的数组类型。Kotlin中的数据类型与Java基本一致，不过可以将基本数据类型也看做对象。</p><h2 id=数字>数字<a hidden class=anchor aria-hidden=true href=#数字>#</a></h2><pre><code>类型     |位宽度
--------|---------
Double	|64
Float	|32
Long    |64
Int     |32
Short	|16
Byte	|8 
</code></pre><p>注意，Kotlin中字符不是数字。</p><p>在Java平台中，数字的以JVM中的基本数据类型保存于物理存储，除非我们想要一个可以为空(nullable)的数字或者使用了泛型，那么这时数字会装箱（boxed）为对应的类型。</p><p>数字装箱后不保留同一性（identity），但保留相等性（equality），这与Java中是一样的，两个数字值相等的对象是不同的两个对象，但它们的值是相等的。</p><p>与Java中不同的是，同一性比较使用三个等号符号：<code>===</code>或者<code>!==</code>，相等性比较使用：<code>==</code>或者<code>!=</code>。</p><p>对于数字的隐式转换和自动拆装箱，对比Java中和Kotlin中有何区别：</p><ul><li>Java中，表达式中的数字类型会自动拆箱为对应的基础类型，然后向上转型为表达式中较大的基础类型。自动装箱只能发生在对应的基础类型上。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=w>    </span><span class=n>Integer</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>11</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Short</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>12</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Long</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>13L</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>short</span><span class=w> </span><span class=n>j</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>2</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>long</span><span class=w> </span><span class=n>k</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>3</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>k</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>a</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>k</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>b</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>k</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>j</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>k</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=n>i</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>b</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>j</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>c</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=n>i</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>c</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>14</span><span class=p>;</span><span class=w>    </span><span class=c1>// error, right expression is &#39;int&#39;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>c</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>j</span><span class=p>;</span><span class=w> </span><span class=c1>// error, right expression is &#39;int&#39;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>c</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>b</span><span class=p>;</span><span class=w> </span><span class=c1>// error, right expression is &#39;int&#39;</span><span class=w>
</span></span></span></code></pre></div><ul><li>Kotlin中，与类型系统是相关的，因为所有数字类型都认为是对象，可以认为没有拆箱的说法，并且也没有隐式的类型提升，运算符事实上都是重载的操作符。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>    <span class=k>var</span> <span class=py>a</span><span class=p>:</span> <span class=n>Int</span><span class=p>?</span> <span class=p>=</span> <span class=m>11</span>
</span></span><span class=line><span class=cl>    <span class=k>var</span> <span class=py>b</span><span class=p>:</span> <span class=n>Short</span><span class=p>?</span> <span class=p>=</span> <span class=m>12</span>
</span></span><span class=line><span class=cl>    <span class=k>var</span> <span class=py>c</span><span class=p>:</span> <span class=n>Long</span><span class=p>?</span> <span class=p>=</span> <span class=m>13L</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>var</span> <span class=py>i</span><span class=p>:</span> <span class=n>Int</span> <span class=p>=</span> <span class=m>1</span>
</span></span><span class=line><span class=cl>    <span class=k>var</span> <span class=py>j</span><span class=p>:</span> <span class=n>Short</span> <span class=p>=</span> <span class=m>2</span>
</span></span><span class=line><span class=cl>    <span class=k>var</span> <span class=py>k</span><span class=p>:</span> <span class=n>Long</span> <span class=p>=</span> <span class=m>3</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>k</span> <span class=p>=</span> <span class=n>a</span>      <span class=c1>// error, no unboxing and explicitly conversion
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>k</span> <span class=p>=</span> <span class=n>a</span> <span class=p>+</span> <span class=n>b</span>  <span class=c1>// error, no unboxing and explicitly conversion
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>k</span> <span class=p>=</span> <span class=n>i</span> <span class=p>+</span> <span class=n>j</span>  <span class=c1>// error, assignment has no explicitly conversion
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>k</span> <span class=o>+=</span> <span class=n>i</span>     <span class=c1>// ok
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=n>a</span> <span class=p>=</span> <span class=n>a</span> <span class=p>+</span> <span class=n>b</span>  <span class=c1>// error, no unboxing and explicitly conversion
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>a</span> <span class=p>=</span> <span class=n>i</span> <span class=p>+</span> <span class=n>j</span>  <span class=c1>// ok
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=n>c</span> <span class=o>+=</span> <span class=n>i</span>     <span class=c1>// error, not allow
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>c</span> <span class=p>=</span> <span class=m>14</span>     <span class=c1>// ok
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>c</span> <span class=p>=</span> <span class=n>i</span> <span class=p>+</span> <span class=n>j</span>  <span class=c1>// error, assignment has no explicitly conversion
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>c</span> <span class=p>=</span> <span class=n>a</span> <span class=p>+</span> <span class=n>b</span>  <span class=c1>// error, no unboxing and explicitly conversion
</span></span></span></code></pre></div><p>正确通过编译的版本：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>    <span class=k>var</span> <span class=py>a</span><span class=p>:</span> <span class=n>Int</span><span class=p>?</span> <span class=p>=</span> <span class=m>11</span>
</span></span><span class=line><span class=cl>    <span class=k>var</span> <span class=py>b</span><span class=p>:</span> <span class=n>Short</span><span class=p>?</span> <span class=p>=</span> <span class=m>12</span>
</span></span><span class=line><span class=cl>    <span class=k>var</span> <span class=py>c</span><span class=p>:</span> <span class=n>Long</span><span class=p>?</span> <span class=p>=</span> <span class=m>13L</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>var</span> <span class=py>i</span><span class=p>:</span> <span class=n>Int</span> <span class=p>=</span> <span class=m>1</span>
</span></span><span class=line><span class=cl>    <span class=k>var</span> <span class=py>j</span><span class=p>:</span> <span class=n>Short</span> <span class=p>=</span> <span class=m>2</span>
</span></span><span class=line><span class=cl>    <span class=k>var</span> <span class=py>k</span><span class=p>:</span> <span class=n>Long</span> <span class=p>=</span> <span class=m>3</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>k</span> <span class=p>=</span> <span class=n>a</span><span class=o>!!</span><span class=p>.</span><span class=n>toLong</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>k</span> <span class=p>=</span> <span class=p>(</span><span class=n>i</span> <span class=p>+</span> <span class=n>j</span><span class=p>).</span><span class=n>toLong</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>k</span> <span class=p>=</span> <span class=p>(</span><span class=n>a</span><span class=o>!!</span> <span class=p>+</span> <span class=n>b</span><span class=o>!!</span><span class=p>).</span><span class=n>toLong</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>k</span> <span class=o>+=</span> <span class=n>i</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>a</span> <span class=p>=</span> <span class=n>a</span><span class=o>!!</span> <span class=p>+</span> <span class=n>b</span><span class=o>!!</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span> <span class=p>=</span> <span class=n>i</span> <span class=p>+</span> <span class=n>j</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>c</span> <span class=o>+=</span> <span class=n>i</span>         <span class=c1>// error, not allow
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>c</span> <span class=p>=</span> <span class=m>14</span>
</span></span><span class=line><span class=cl>    <span class=n>c</span> <span class=p>=</span> <span class=p>(</span><span class=n>i</span> <span class=p>+</span> <span class=n>j</span><span class=p>).</span><span class=n>toLong</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>c</span> <span class=p>=</span> <span class=p>(</span><span class=n>a</span><span class=o>!!</span> <span class=p>+</span> <span class=n>b</span><span class=o>!!</span><span class=p>).</span><span class=n>toLong</span><span class=p>()</span>
</span></span></code></pre></div><h2 id=字符>字符<a hidden class=anchor aria-hidden=true href=#字符>#</a></h2><p>字符使用<code>Char</code>表示，它们不能被当做数字使用。</p><h2 id=布尔值>布尔值<a hidden class=anchor aria-hidden=true href=#布尔值>#</a></h2><p>布尔值使用<code>Boolean</code>表示。</p><h2 id=字符串>字符串<a hidden class=anchor aria-hidden=true href=#字符串>#</a></h2><p>字符串使用<code>String</code>表示。字符串是不可变的的，字符串的元素是字符，可以使用序号操作符<code>[]</code>来访问。</p><p>有两种类型字符字面值，一种是脱字符字符串（escaped string），可以包含脱字符。另一种是原始字符串（raw string），没有脱字符，可以包含换行符和其它任意字符。</p><h3 id=字符串模板>字符串模板<a hidden class=anchor aria-hidden=true href=#字符串模板>#</a></h3><p>字符串可以包含模板表达式，也就是一段代码运行的结果转换为字符串并插入到字符串中。一个模板表达式以一个美元符号（<code>$</code>）开始，并且由一个简单名字或花括弧中任意表达式构成：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>    <span class=k>val</span> <span class=py>i</span> <span class=p>=</span> <span class=m>10</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>s</span> <span class=p>=</span> <span class=s2>&#34;i = </span><span class=si>$i</span><span class=s2>&#34;</span> <span class=c1>// evaluates to &#34;i = 10&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>val</span> <span class=py>s</span> <span class=p>=</span> <span class=s2>&#34;abc&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>str</span> <span class=p>=</span> <span class=s2>&#34;</span><span class=si>$s</span><span class=s2>.length is </span><span class=si>${s.length}</span><span class=s2>&#34;</span> <span class=c1>// evaluates to &#34;abc.length is 3&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>price</span> <span class=p>=</span> <span class=s>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s>    </span><span class=si>${&#39;$&#39;}</span><span class=s>9.99
</span></span></span><span class=line><span class=cl><span class=s>&#34;&#34;&#34;</span>
</span></span></code></pre></div><p>在原始字符串中，如果要表示美元符号字面值，可以使用单引号，如上所示。</p><h2 id=数组>数组<a hidden class=anchor aria-hidden=true href=#数组>#</a></h2><p>数字由<code>Array</code>类表示，有<code>get</code>和<code>set</code>方法（通过操作符重载，使用方括号[]来调用)，还有<code>size</code>属性，以及一些有用的方法。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>    <span class=k>class</span> <span class=nc>Array</span><span class=p>&lt;</span><span class=n>T</span><span class=p>&gt;</span> <span class=k>private</span> <span class=k>constructor</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>val</span> <span class=py>size</span><span class=p>:</span> <span class=n>Int</span>
</span></span><span class=line><span class=cl>        <span class=k>operator</span> <span class=k>fun</span> <span class=nf>get</span><span class=p>(</span><span class=n>index</span><span class=p>:</span> <span class=n>Int</span><span class=p>):</span> <span class=n>T</span>
</span></span><span class=line><span class=cl>        <span class=k>operator</span> <span class=k>fun</span> <span class=nf>set</span><span class=p>(</span><span class=n>index</span><span class=p>:</span> <span class=n>Int</span><span class=p>,</span> <span class=k>value</span><span class=p>:</span> <span class=n>T</span><span class=p>):</span> <span class=n>Unit</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>operator</span> <span class=k>fun</span> <span class=nf>iterator</span><span class=p>():</span> <span class=n>Iterator</span><span class=p>&lt;</span><span class=n>T</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>        <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span></code></pre></div><p>可以使用库函数来创建数组，有<code>arrayOf()</code>，<code>arrayOfNulls()</code>，以及使用工厂函数，如下所示，它接收一个数组大小，和返回每个序号对应值的方法：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>    <span class=c1>// Creates an Array&lt;String&gt; with values [&#34;0&#34;, &#34;1&#34;, &#34;4&#34;, &#34;9&#34;, &#34;16&#34;]
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>val</span> <span class=py>asc</span> <span class=p>=</span> <span class=n>Array</span><span class=p>(</span><span class=m>5</span><span class=p>,</span> <span class=p>{</span> <span class=n>i</span> <span class=o>-&gt;</span> <span class=p>(</span><span class=n>i</span> <span class=p>*</span> <span class=n>i</span><span class=p>).</span><span class=n>toString</span><span class=p>()</span> <span class=p>})</span>
</span></span></code></pre></div><blockquote><p>和Java中不一样，Kotlin中的数组是不变量，这意味着，不能将<code>Array&lt;String></code>赋值给一个<code>Array&lt;Any></code>，这样避免了一个可能的运行时错误，但可以使用<code>Array&lt;out Any></code>，见<a href=https://kotlinlang.org/docs/reference/generics.html#type-projections>类型投影</a>。</p></blockquote><p>Kotlin还有指定的类用于表示基本数据类型数组，可以免去数据装箱的开销，有<code>ByteArray, ShortArray, IntArray</code>等等，这些类与<code>Array</code>类没有继承关系。它们有自己的工厂函数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>    <span class=k>val</span> <span class=py>x</span><span class=p>:</span> <span class=n>IntArray</span> <span class=p>=</span> <span class=n>intArrayOf</span><span class=p>(</span><span class=m>1</span><span class=p>,</span> <span class=m>2</span><span class=p>,</span> <span class=m>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>x</span><span class=p>[</span><span class=m>0</span><span class=p>]</span> <span class=p>=</span> <span class=n>x</span><span class=p>[</span><span class=m>1</span><span class=p>]</span> <span class=p>+</span> <span class=n>x</span><span class=p>[</span><span class=m>2</span><span class=p>]</span>
</span></span></code></pre></div><h2 id=相等性>相等性<a hidden class=anchor aria-hidden=true href=#相等性>#</a></h2><p>Kotlin中有两种形式的相等性：</p><ul><li>引用相等性（即同一性，两个引用指向同一个对象），使用<code>===</code>和<code>!==</code>操作符。</li><li>结构相等性（equals()检查），使用<code>==</code>和<code>!=</code>操作符。</li></ul><p>通常结构相等性操作符<code>a == b</code>会被翻译为：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>    <span class=n>a</span><span class=o>?.</span><span class=n>equals</span><span class=p>(</span><span class=n>b</span><span class=p>)</span> <span class=o>?:</span> <span class=p>(</span><span class=n>b</span> <span class=o>===</span> <span class=k>null</span><span class=p>)</span>
</span></span></code></pre></div><p>即如果a不为null，它盗用equals(Any?)函数，否则，a为null，它检查b是否引用相等于null。</p><p>注意没有必要直接与null进行同一性比较，<code>a == null</code>会自动转换为<code>a === null</code>。</p><h2 id=空引用安全性null-safety>空引用安全性（Null safety）<a hidden class=anchor aria-hidden=true href=#空引用安全性null-safety>#</a></h2><p>Kotlin的类型系统的目的之一是消灭空引用，即传说中的<a href=http://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions>百万美元bug</a>。</p><p>仅有几种情况会引起空指针异常（<code>NullPointerException</code>）：</p><ul><li>代码中直接抛出异常<code>throw NullPointerException()</code></li><li>使用操作符<code>!!</code></li><li>外部Java代码导致的异常</li><li>初始化相关的数据不一致问题（一个构造器中未初始化的this使用在了其它地方）</li></ul><h3 id=在条件语句中检查null>在条件语句中检查null<a hidden class=anchor aria-hidden=true href=#在条件语句中检查null>#</a></h3><p>第一，你可以显式地检查b是否为空，并且分别处理两种情况：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>    <span class=k>val</span> <span class=py>l</span> <span class=p>=</span> <span class=k>if</span> <span class=p>(</span><span class=n>b</span> <span class=o>!=</span> <span class=k>null</span><span class=p>)</span> <span class=n>b</span><span class=p>.</span><span class=n>length</span> <span class=k>else</span> <span class=p>-</span><span class=m>1</span>
</span></span></code></pre></div><p>注意只有当b不可变（检查和使用间没有被修改的局部变量或者一个有支撑域的不可重写的val成员），因为其它情况下b在使用前检查后可能值被修改了。</p><h3 id=安全调用>安全调用<a hidden class=anchor aria-hidden=true href=#安全调用>#</a></h3><p>使用安全调用操作符（<code>?.</code>）：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>    <span class=n>b</span><span class=o>?.</span><span class=n>length</span>  <span class=c1>// 如果b为null则返回null，否则返回b.length
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>// 链式调用，如果有一个为null，就返回null
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>bob</span><span class=o>?.</span><span class=n>department</span><span class=o>?.</span><span class=n>head</span><span class=o>?.</span><span class=n>name</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 只在非空的情况下执行某一操作
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>val</span> <span class=py>listWithNulls</span><span class=p>:</span> <span class=n>List</span><span class=p>&lt;</span><span class=n>String</span><span class=p>?&gt;</span> <span class=p>=</span> <span class=n>listOf</span><span class=p>(</span><span class=s2>&#34;A&#34;</span><span class=p>,</span> <span class=k>null</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>item</span> <span class=k>in</span> <span class=n>listWithNulls</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>item</span><span class=o>?.</span><span class=n>let</span> <span class=p>{</span> <span class=n>println</span><span class=p>(</span><span class=k>it</span><span class=p>)</span> <span class=p>}</span> <span class=c1>// prints A and ignores null
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span></code></pre></div><h3 id=elvis操作符>Elvis操作符<a hidden class=anchor aria-hidden=true href=#elvis操作符>#</a></h3><p>当我们有一个可以为空的引用r，我们可以说“如果r不为null，那么就使用它，否则就使用某个非空的值x”：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>    <span class=k>val</span> <span class=py>l</span><span class=p>:</span> <span class=n>Int</span> <span class=p>=</span> <span class=k>if</span> <span class=p>(</span><span class=n>b</span> <span class=o>!=</span> <span class=k>null</span><span class=p>)</span> <span class=n>b</span><span class=p>.</span><span class=n>length</span> <span class=k>else</span> <span class=p>-</span><span class=m>1</span>
</span></span></code></pre></div><p>使用Elvis操作符<code>?:</code>表示为:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>    <span class=k>val</span> <span class=py>l</span> <span class=p>=</span> <span class=n>b</span><span class=o>?.</span><span class=n>length</span> <span class=o>?:</span> <span class=p>-</span><span class=m>1</span>
</span></span></code></pre></div><p>由于throw和return也是表达式，它们也可以用于该操作符的右边，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>    <span class=k>fun</span> <span class=nf>foo</span><span class=p>(</span><span class=n>node</span><span class=p>:</span> <span class=n>Node</span><span class=p>):</span> <span class=n>String</span><span class=p>?</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>val</span> <span class=py>parent</span> <span class=p>=</span> <span class=n>node</span><span class=p>.</span><span class=n>getParent</span><span class=p>()</span> <span class=o>?:</span> <span class=k>return</span> <span class=k>null</span>
</span></span><span class=line><span class=cl>        <span class=k>val</span> <span class=py>name</span> <span class=p>=</span> <span class=n>node</span><span class=p>.</span><span class=n>getName</span><span class=p>()</span> <span class=o>?:</span> <span class=k>throw</span> <span class=n>IllegalArgumentException</span><span class=p>(</span><span class=s2>&#34;name expected&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span></code></pre></div><h3 id=操作符><code>!!</code>操作符<a hidden class=anchor aria-hidden=true href=#操作符>#</a></h3><p>对于NPE爱好者还有一个选择，可以使用<code>b!!</code>，如果b不为空那么返回它，否则抛出一个NPE：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>    <span class=k>val</span> <span class=py>l</span> <span class=p>=</span> <span class=n>b</span><span class=o>!!</span><span class=p>.</span><span class=n>length</span>
</span></span></code></pre></div><h3 id=安全转型>安全转型<a hidden class=anchor aria-hidden=true href=#安全转型>#</a></h3><p>常规的类型转换可能导致<code>ClassCastException</code>，另一种选择是使用在尝试转型失败后返回<code>null</code>的安全转换：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>    <span class=k>val</span> <span class=py>aInt</span><span class=p>:</span> <span class=n>Int</span><span class=p>?</span> <span class=p>=</span> <span class=n>a</span> <span class=k>as</span><span class=p>?</span> <span class=n>Int</span>
</span></span></code></pre></div><h3 id=可以为空类型的集合>可以为空类型的集合<a hidden class=anchor aria-hidden=true href=#可以为空类型的集合>#</a></h3><p>如果一个集合的元素可以为空，并且你想过滤出非空的元素，可以使用<code>filterNotNull</code>函数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>    <span class=k>val</span> <span class=py>nullableList</span><span class=p>:</span> <span class=n>List</span><span class=p>&lt;</span><span class=n>Int</span><span class=p>?&gt;</span> <span class=p>=</span> <span class=n>listOf</span><span class=p>(</span><span class=m>1</span><span class=p>,</span> <span class=m>2</span><span class=p>,</span> <span class=k>null</span><span class=p>,</span> <span class=m>4</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>intList</span><span class=p>:</span> <span class=n>List</span><span class=p>&lt;</span><span class=n>Int</span><span class=p>&gt;</span> <span class=p>=</span> <span class=n>nullableList</span><span class=p>.</span><span class=n>filterNotNull</span><span class=p>()</span>
</span></span></code></pre></div><h2 id=类型检查与转换is和as>类型检查与转换：&ldquo;is"和"as&rdquo;<a hidden class=anchor aria-hidden=true href=#类型检查与转换is和as>#</a></h2><h3 id=is和is操作符><code>is</code>和<code>!is</code>操作符<a hidden class=anchor aria-hidden=true href=#is和is操作符>#</a></h3><p>使用<code>is</code>和<code>!is</code>操作符可以在运行时检查一个对象是否符合一个给定的类型：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>obj</span> <span class=k>is</span> <span class=n>String</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>print</span><span class=p>(</span><span class=n>obj</span><span class=p>.</span><span class=n>length</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>obj</span> <span class=o>!is</span> <span class=n>String</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// same as !(obj is String)
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>print</span><span class=p>(</span><span class=s2>&#34;Not a String&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>print</span><span class=p>(</span><span class=n>obj</span><span class=p>.</span><span class=n>length</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span></code></pre></div><h3 id=智能转型>智能转型<a hidden class=anchor aria-hidden=true href=#智能转型>#</a></h3><p>很多情形下，不用显式地进行类型转换，因为编译器会跟踪<code>is</code>检查，在需要的时候为不可变值进行显式地转型并自动插入（安全的）类型转换：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>    <span class=k>fun</span> <span class=nf>demo</span><span class=p>(</span><span class=n>x</span><span class=p>:</span> <span class=n>Any</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>x</span> <span class=k>is</span> <span class=n>String</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>print</span><span class=p>(</span><span class=n>x</span><span class=p>.</span><span class=n>length</span><span class=p>)</span> <span class=c1>// x is automatically cast to String
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span></code></pre></div><p>注意如果编译器不能保证检查和使用之间变量不能改变，那么智能转型就没法进行。更具体来说，智能转型在以下规则下是适用的：</p><ul><li><code>val</code>局部变量——总是可行的。</li><li><code>val</code>属性——如果属性是<code>private</code>的或者<code>internal</code>的或者检查在属性声明的同一模块下进行。对于<code>open</code>的属性或自定义了getter的属性不适用。</li><li><code>var</code>局部变量——如果变量在检查和使用间没有被改变，并且没有在一个修改它的lambda中被捕获。</li><li><code>var</code>属性——总是不可行的（因为变量可以在任何时间被其它代码修改）。</li></ul><h3 id=不安全的unsafe转型操作符>“不安全的（Unsafe）”转型操作符<a hidden class=anchor aria-hidden=true href=#不安全的unsafe转型操作符>#</a></h3><p>通常，如果转型失败会抛出一个异常。因此，我们称之为_不安全的(unsafe)_。不安全的转型使用中缀操作符<code>as</code>来进行：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>    <span class=k>val</span> <span class=py>x</span><span class=p>:</span> <span class=n>String</span> <span class=p>=</span> <span class=n>y</span> <span class=k>as</span> <span class=n>String</span>
</span></span></code></pre></div><p>注意<code>null</code>不能被转型为<code>String</code>，因为<code>String</code>类型不是可为空的，也就是说，如果<code>y</code>是<code>null</code>，那么上面的代码会抛出一个异常。为了符合java的转型语义我们在转型操作符的右边有可以为空的类型，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>    <span class=k>val</span> <span class=py>x</span><span class=p>:</span> <span class=n>String</span><span class=p>?</span> <span class=p>=</span> <span class=n>y</span> <span class=k>as</span> <span class=n>String</span><span class=p>?</span>
</span></span></code></pre></div><h3 id=安全的safe转型操作>&ldquo;安全的（safe）&ldquo;转型操作<a hidden class=anchor aria-hidden=true href=#安全的safe转型操作>#</a></h3><p>为了避免抛出一个异常，可以使用_安全的（safe）_转型操作符<code>as?</code>，如果转型失败会返回<code>null</code>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>    <span class=k>val</span> <span class=py>x</span><span class=p>:</span> <span class=n>String</span><span class=p>?</span> <span class=p>=</span> <span class=n>y</span> <span class=k>as</span><span class=p>?</span> <span class=n>String</span>
</span></span></code></pre></div><p>注意，尽管操作符<code>as?</code>的右边是一个不为<code>null</code>的类型<code>String</code>，转型的结果是可以为空的。</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://epicmars.github.io/>AndroidPi</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>